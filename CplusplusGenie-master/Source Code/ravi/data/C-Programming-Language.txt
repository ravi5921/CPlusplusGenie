
The
C+ +
Programming
Language
Third Edition
Bjarne Stroustrup
AT&T Labs
Murray Hill, New Jersey
Addison-Wesley
An Imprint of Addison Wesley Longman, Inc.
Reading, Massachusetts • Harlow, England • Menlo Park, California
Berkeley, California • Don Mills, Ontario • Sydney
Bonn • Amsterdam • Tokyo • Mexico City
ii
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where
those designations appear in this book, and Addison-Wesley was aware of a trademark claim, the designations have been
printed in initial capital letters or all capital letters
The author and publisher have taken care in the preparation of this book, but make no expressed or implied warranty of any
kind and assume no responsibility for errors or omissions. No liability is assumed for incidental or consequential damages in
connection with or arising out of the use of the information contained herein.
The publisher offers discounts on this book when ordered in quantity for special sales. For more information please contact:
Corporate & Professional Publishing Group
Addison-Wesley Publishing Company
One Jacob Way
Reading, Massachusetts 01867
Library of Congress Cataloging-in-Publication Data
Stroustrup, Bjarne
The C++ Programming Language / Bjarne Stroustrup. — 3rd. ed.
p. cm.
Includes index.
ISBN 0-201-88954-4
1. C++ (Computer Programming Language) I. Title
QA76.73.C153S77 1997 97-20239
005.13’3—dc21 CIP
Copyright © 1997 by AT&T
All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or
by any means, electronic, mechanical, photocopying, recording, or otherwise, without the prior written permission of the
publisher. Printed in the United States of America.
This book was typeset in Times and Courier by the author.
ISBN 0-201-88954-4
Printed on recycled paper
1 2 3 4 5 6 7 8 9—CRW—0100999897
First printing, June 1997
Contents
Contents iii
Preface v
Preface to Second Edition vii
Preface to First Edition ix
Introductory Material 1
1 Notes to the Reader ..................................................................... 3
2 A Tour of C++ ............................................................................. 21
3 A Tour of the Standard Library .................................................. 45
Part I: Basic Facilities 67
4 Types and Declarations ............................................................... 69
5 Pointers, Arrays, and Structures .................................................. 87
6 Expressions and Statements ........................................................ 107
7 Functions ..................................................................................... 143
8 Namespaces and Exceptions ....................................................... 165
9 Source Files and Programs .......................................................... 197
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
iv Contents
Part II: Abstraction Mechanisms 221
10 Classes ........................................................................................ 223
11 Operator Overloading ................................................................. 261
12 Derived Classes ........................................................................... 301
13 Templates .................................................................................... 327
14 Exception Handling .................................................................... 355
15 Class Hierarchies ........................................................................ 389
Part III: The Standard Library 427
16 Library Organization and Containers .......................................... 429
17 Standard Containers .................................................................... 461
18 Algorithms and Function Objects ............................................... 507
19 Iterators and Allocators ............................................................... 549
20 Strings ......................................................................................... 579
21 Streams ........................................................................................ 605
22 Numerics ..................................................................................... 657
Part IV: Design Using C++ 689
23 Development and Design ............................................................ 691
24 Design and Programming ........................................................... 723
25 Roles of Classes .......................................................................... 765
Appendices 791
A The C++ Grammar ...................................................................... 793
B Compatibility .............................................................................. 815
C Technicalities .............................................................................. 827
Index 869
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Preface
Programming is understanding.
– Kristen Nygaard
I find using C++ more enjoyable than ever. C++’s support for design and programming has
improved dramatically over the years, and lots of new helpful techniques have been developed for
its use. However, C++ is not just fun. Ordinary practical programmers have achieved significant
improvements in productivity, maintainability, flexibility, and quality in projects of just about any
kind and scale. By now, C++ has fulfilled most of the hopes I originally had for it, and also succeeded at tasks I hadn’t even dreamt of.
This book introduces standard C++† and the key programming and design techniques supported
by C++. Standard C++ is a far more powerful and polished language than the version of C++ introduced by the first edition of this book. New language features such as namespaces, exceptions,
templates, and run-time type identification allow many techniques to be applied more directly than
was possible before, and the standard library allows the programmer to start from a much higher
level than the bare language.
About a third of the information in the second edition of this book came from the first. This
third edition is the result of a rewrite of even larger magnitude. It offers something to even the
most experienced C++ programmer; at the same time, this book is easier for the novice to approach
than its predecessors were. The explosion of C++ use and the massive amount of experience accumulated as a result makes this possible.
The definition of an extensive standard library makes a difference to the way C++ concepts can
be presented. As before, this book presents C++ independently of any particular implementation,
and as before, the tutorial chapters present language constructs and concepts in a ‘‘bottom up’’
order so that a construct is used only after it has been defined. However, it is much easier to use a
well-designed library than it is to understand the details of its implementation. Therefore, the standard library can be used to provide realistic and interesting examples well before a reader can be
assumed to understand its inner workings. The standard library itself is also a fertile source of programming examples and design techniques.
__________________
† ISO/IEC 14882, Standard for the C++ Programming Language.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
vi Preface
This book presents every major C++ language feature and the standard library. It is organized
around language and library facilities. However, features are presented in the context of their use.
That is, the focus is on the language as the tool for design and programming rather than on the language in itself. This book demonstrates key techniques that make C++ effective and teaches the
fundamental concepts necessary for mastery. Except where illustrating technicalities, examples are
taken from the domain of systems software. A companion, The Annotated C++ Language Standard, presents the complete language definition together with annotations to make it more comprehensible.
The primary aim of this book is to help the reader understand how the facilities offered by C++
support key programming techniques. The aim is to take the reader far beyond the point where he
or she gets code running primarily by copying examples and emulating programming styles from
other languages. Only a good understanding of the ideas behind the language facilities leads to
mastery. Supplemented by implementation documentation, the information provided is sufficient
for completing significant real-world projects. The hope is that this book will help the reader gain
new insights and become a better programmer and designer.
Acknowledgments
In addition to the people mentioned in the acknowledgement sections of the first and second editions, I would like to thank Matt Austern, Hans Boehm, Don Caldwell, Lawrence Crowl, Alan
Feuer, Andrew Forrest, David Gay, Tim Griffin, Peter Juhl, Brian Kernighan, Andrew Koenig,
Mike Mowbray, Rob Murray, Lee Nackman, Joseph Newcomer, Alex Stepanov, David Vandevoorde, Peter Weinberger, and Chris Van Wyk for commenting on draft chapters of this third edition.
Without their help and suggestions, this book would have been harder to understand, contained
more errors, been slightly less complete, and probably been a little bit shorter.
I would also like to thank the volunteers on the C++ standards committees who did an immense
amount of constructive work to make C++ what it is today. It is slightly unfair to single out individuals, but it would be even more unfair not to mention anyone, so I’d like to especially mention
Mike Ball, Dag Br. .
uck, Sean Corfield, Ted Goldstein, Kim Knuttila, Andrew Koenig, José e Lajoie,
Dmitry Lenkov, Nathan Myers, Martin O’Riordan, Tom Plum, Jonathan Shopiro, John Spicer,
Jerry Schwarz, Alex Stepanov, and Mike Vilot, as people who each directly cooperated with me
over some part of C++ and its standard library.
Murray Hill, New Jersey Bjarne Stroustrup
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Preface to the Second Edition
The road goes ever on and on.
– Bilbo Baggins
As promised in the first edition of this book, C++ has been evolving to meet the needs of its users.
This evolution has been guided by the experience of users of widely varying backgrounds working
in a great range of application areas. The C++ user-community has grown a hundredfold during the
six years since the first edition of this book; many lessons have been learned, and many techniques
have been discovered and/or validated by experience. Some of these experiences are reflected here.
The primary aim of the language extensions made in the last six years has been to enhance C++
as a language for data abstraction and object-oriented programming in general and to enhance it as
a tool for writing high-quality libraries of user-defined types in particular. A ‘‘high-quality
library,’’ is a library that provides a concept to a user in the form of one or more classes that are
convenient, safe, and efficient to use. In this context, safe means that a class provides a specific
type-safe interface between the users of the library and its providers; efficient means that use of the
class does not impose significant overheads in run-time or space on the user compared with handwritten C code.
This book presents the complete C++ language. Chapters 1 through 10 give a tutorial introduction; Chapters 11 through 13 provide a discussion of design and software development issues; and,
finally, the complete C++ reference manual is included. Naturally, the features added and resolutions made since the original edition are integral parts of the presentation. They include refined
overloading resolution, memory management facilities, and access control mechanisms, type-safe
linkage, constand staticmember functions, abstract classes, multiple inheritance, templates, and
exception handling.
C++ is a general-purpose programming language; its core application domain is systems programming in the broadest sense. In addition, C++ is successfully used in many application areas
that are not covered by this label. Implementations of C++ exist from some of the most modest
microcomputers to the largest supercomputers and for almost all operating systems. Consequently,
this book describes the C++ language itself without trying to explain a particular implementation,
programming environment, or library.
This book presents many examples of classes that, though useful, should be classified as
‘‘toys.’’ This style of exposition allows general principles and useful techniques to stand out more
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
viii Preface to the Second Edition
clearly than they would in a fully elaborated program, where they would be buried in details. Most
of the useful classes presented here, such as linked lists, arrays, character strings, matrices, graphics
classes, associative arrays, etc., are available in ‘‘bulletproof’’ and/or ‘‘goldplated’’ versions from a
wide variety of commercial and non-commercial sources. Many of these ‘‘industrial strength’’
classes and libraries are actually direct and indirect descendants of the toy versions found here.
This edition provides a greater emphasis on tutorial aspects than did the first edition of this
book. However, the presentation is still aimed squarely at experienced programmers and endeavors
not to insult their intelligence or experience. The discussion of design issues has been greatly
expanded to reflect the demand for information beyond the description of language features and
their immediate use. Technical detail and precision have also been increased. The reference manual, in particular, represents many years of work in this direction. The intent has been to provide a
book with a depth sufficient to make more than one reading rewarding to most programmers. In
other words, this book presents the C++ language, its fundamental principles, and the key techniques needed to apply it. Enjoy!
Acknowledgments
In addition to the people mentioned in the acknowledgements section in the preface to the first edition, I would like to thank Al Aho, Steve Buroff, Jim Coplien, Ted Goldstein, Tony Hansen, Lorraine Juhl, Peter Juhl, Brian Kernighan, Andrew Koenig, Bill Leggett, Warren Montgomery, Mike
Mowbray, Rob Murray, Jonathan Shopiro, Mike Vilot, and Peter Weinberger for commenting on
draft chapters of this second edition. Many people influenced the development of C++ from 1985
to 1991. I can mention only a few: Andrew Koenig, Brian Kernighan, Doug McIlroy, and Jonathan
Shopiro. Also thanks to the many participants of the ‘‘external reviews’’ of the reference manual
drafts and to the people who suffered through the first year of X3J16.
Murray Hill, New Jersey Bjarne Stroustrup
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Preface to the First Edition
Language shapes the way we think,
and determines what we can think about.
– B.L.Whorf
C++ is a general purpose programming language designed to make programming more enjoyable
for the serious programmer. Except for minor details, C++ is a superset of the C programming language. In addition to the facilities provided by C, C++ provides flexible and efficient facilities for
defining new types. A programmer can partition an application into manageable pieces by defining
new types that closely match the concepts of the application. This technique for program construction is often called data abstraction. Objects of some user-defined types contain type information.
Such objects can be used conveniently and safely in contexts in which their type cannot be determined at compile time. Programs using objects of such types are often called object based. When
used well, these techniques result in shorter, easier to understand, and easier to maintain programs.
The key concept in C++ is class. A class is a user-defined type. Classes provide data hiding,
guaranteed initialization of data, implicit type conversion for user-defined types, dynamic typing,
user-controlled memory management, and mechanisms for overloading operators. C++ provides
much better facilities for type checking and for expressing modularity than C does. It also contains
improvements that are not directly related to classes, including symbolic constants, inline substitution of functions, default function arguments, overloaded function names, free store management
operators, and a reference type. C++ retains C’s ability to deal efficiently with the fundamental
objects of the hardware (bits, bytes, words, addresses, etc.). This allows the user-defined types to
be implemented with a pleasing degree of efficiency.
C++ and its standard libraries are designed for portability. The current implementation will run
on most systems that support C. C libraries can be used from a C++ program, and most tools that
support programming in C can be used with C++.
This book is primarily intended to help serious programmers learn the language and use it for
nontrivial projects. It provides a complete description of C++, many complete examples, and many
more program fragments.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
x Preface to the First Edition
Acknowledgments
C++ could never have matured without the constant use, suggestions, and constructive criticism of
many friends and colleagues. In particular, Tom Cargill, Jim Coplien, Stu Feldman, Sandy Fraser,
Steve Johnson, Brian Kernighan, Bart Locanthi, Doug McIlroy, Dennis Ritchie, Larry Rosler, Jerry
Schwarz, and Jon Shopiro provided important ideas for development of the language. Dave Presotto wrote the current implementation of the stream I/O library.
In addition, hundreds of people contributed to the development of C++ and its compiler by
sending me suggestions for improvements, descriptions of problems they had encountered, and
compiler errors. I can mention only a few: Gary Bishop, Andrew Hume, Tom Karzes, Victor
Milenkovic, Rob Murray, Leonie Rose, Brian Schmult, and Gary Walker.
Many people have also helped with the production of this book, in particular, Jon Bentley,
Laura Eaves, Brian Kernighan, Ted Kowalski, Steve Mahaney, Jon Shopiro, and the participants in
the C++ course held at Bell Labs, Columbus, Ohio, June 26-27, 1985.
Murray Hill, New Jersey Bjarne Stroustrup
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Introduction
This introduction gives an overview of the major concepts and features of the C++ programming language and its standard library. It also provides an overview of this book
and explains the approach taken to the description of the language facilities and their
use. In addition, the introductory chapters present some background information about
C++, the design of C++, and the use of C++.
Chapters
1 Notes to the Reader
2 A Tour of C++
3 A Tour of the Standard Library
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
2 Introduction Introduction
‘‘... and you, Marcus, you have given me many things; now I shall give you this good
advice. Be many people. Give up the game of being always Marcus Cocoza. You
have worried too much about Marcus Cocoza, so that you have been really his slave
and prisoner. You have not done anything without first considering how it would
affect Marcus Cocoza’s happiness and prestige. You were always much afraid that
Marcus might do a stupid thing, or be bored. What would it really have mattered? All
over the world people are doing stupid things ... I should like you to be easy, your little heart to be light again. You must from now, be more than one, many people, as
many as you can think of ...’’
– Karen Blixen
(‘‘The Dreamers’’ from ‘‘Seven Gothic Tales’’
written under the pseudonym Isak Dinesen,
Random House, Inc.
Copyright, Isac Dinesen, 1934 renewed 1961)
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
1 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
Notes to the Reader
"The time has come," the Walrus said,
"to talk of many things."
– L.Carroll
Structure of this book — how to learn C++ — the design of C++ — efficiency and structure — philosophical note — historical note — what C++ is used for — C and C++ —
suggestions for C programmers — suggestions for C++ programmers — thoughts about
programming in C++ — advice — references.
1.1 The Structure of This Book
This book consists of six parts:
Introduction: Chapters 1 through 3 give an overview of the C++ language, the key programming
styles it supports, and the C++ standard library.
Part I: Chapters 4 through 9 provide a tutorial introduction to C++’s built-in types and the
basic facilities for constructing programs out of them.
Part II: Chapters 10 through 15 are a tutorial introduction to object-oriented and generic programming using C++.
Part III: Chapters 16 through 22 present the C++ standard library.
Part IV: Chapters 23 through 25 discuss design and software development issues.
Appendices: Appendices A through E provide language-technical details.
Chapter 1 provides an overview of this book, some hints about how to use it, and some background
information about C++ and its use. You are encouraged to skim through it, read what appears interesting, and return to it after reading other parts of the book.
Chapters 2 and 3 provide an overview of the major concepts and features of the C++ programming language and its standard library. Their purpose is to motivate you to spend time on fundamental concepts and basic language features by showing what can be expressed using the complete
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
4 Notes to the Reader Chapter 1
C++ language. If nothing else, these chapters should convince you that C++ isn’t (just) C and that
C++ has come a long way since the first and second editions of this book. Chapter 2 gives a highlevel acquaintance with C++. The discussion focuses on the language features supporting data
abstraction, object-oriented programming, and generic programming. Chapter 3 introduces the
basic principles and major facilities of the standard library. This allows me to use standard library
facilities in the following chapters. It also allows you to use library facilities in exercises rather
than relying directly on lower-level, built-in features.
The introductory chapters provide an example of a general technique that is applied throughout
this book: to enable a more direct and realistic discussion of some technique or feature, I occasionally present a concept briefly at first and then discuss it in depth later. This approach allows me to
present concrete examples before a more general treatment of a topic. Thus, the organization of
this book reflects the observation that we usually learn best by progressing from the concrete to the
abstract – even where the abstract seems simple and obvious in retrospect.
Part I describes the subset of C++ that supports the styles of programming traditionally done in
C or Pascal. It covers fundamental types, expressions, and control structures for C++ programs.
Modularity – as supported by namespaces, source files, and exception handling – is also discussed.
I assume that you are familiar with the fundamental programming concepts used in Part I. For
example, I explain C++’s facilities for expressing recursion and iteration, but I do not spend much
time explaining how these concepts are useful.
Part II describes C++’s facilities for defining and using new types. Concrete and abstract
classes (interfaces) are presented here (Chapter 10, Chapter 12), together with operator overloading
(Chapter 11), polymorphism, and the use of class hierarchies (Chapter 12, Chapter 15). Chapter 13
presents templates, that is, C++’s facilities for defining families of types and functions. It demonstrates the basic techniques used to provide containers, such as lists, and to support generic programming. Chapter 14 presents exception handling, discusses techniques for error handling, and
presents strategies for fault tolerance. I assume that you either aren’t well acquainted with objectoriented programming and generic programming or could benefit from an explanation of how the
main abstraction techniques are supported by C++. Thus, I don’t just present the language features
supporting the abstraction techniques; I also explain the techniques themselves. Part IV goes further in this direction.
Part III presents the C++ standard library. The aim is to provide an understanding of how to use
the library, to demonstrate general design and programming techniques, and to show how to extend
the library. The library provides containers (such as list, vector, and map; Chapter 16, Chapter 17),
standard algorithms (such as sort, find, and merge; Chapter 18, Chapter 19), strings (Chapter 20),
Input/Output (Chapter 21), and support for numerical computation (Chapter 22).
Part IV discusses issues that arise when C++ is used in the design and implementation of large
software systems. Chapter 23 concentrates on design and management issues. Chapter 24 discusses
the relation between the C++ programming language and design issues. Chapter 25 presents some
ways of using classes in design.
Appendix A is C++’s grammar, with a few annotations. Appendix B discusses the relation
between C and C++ and between Standard C++ (also called ISO C++ and ANSI C++) and the versions of C++ that preceded it. Appendix C presents some language-technical examples. Appendix
D explains the standard library’s facilities supporting internationalization. Appendix E discusses
the exception-safety guarantees and requirements of the standard library.
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
Section 1.1.1 Examples and References 5
1.1.1 Examples and References
This book emphasizes program organization rather than the writing of algorithms. Consequently, I
avoid clever or harder-to-understand algorithms. A trivial algorithm is typically better suited to
illustrate an aspect of the language definition or a point about program structure. For example, I
use a Shell sort where, in real code, a quicksort would be better. Often, reimplementation with a
more suitable algorithm is an exercise. In real code, a call of a library function is typically more
appropriate than the code used here for illustration of language features.
Textbook examples necessarily give a warped view of software development. By clarifying and
simplifying the examples, the complexities that arise from scale disappear. I see no substitute for
writing realistically-sized programs for getting an impression of what programming and a programming language are really like. This book concentrates on the language features, the basic techniques from which every program is composed, and the rules for composition.
The selection of examples reflects my background in compilers, foundation libraries, and simulations. Examples are simplified versions of what is found in real code. The simplification is necessary to keep programming language and design points from getting lost in details. There are no
‘‘cute’’ examples without counterparts in real code. Wherever possible, I relegated to Appendix C
language-technical examples of the sort that use variables named xand y, types called Aand B, and
functions called f() and g().
In code examples, a proportional-width font is used for identifiers. For example:
#include<iostream>
int main()
{
std: :cout<< "Hello, new world!\n";
}
At first glance, this presentation style will seem ‘‘unnatural’’ to programmers accustomed to seeing
code in constant-width fonts. However, proportional-width fonts are generally regarded as better
than constant-width fonts for presentation of text. Using a proportional-width font also allows me
to present code with fewer illogical line breaks. Furthermore, my experiments show that most people find the new style more readable after a short while.
Where possible, the C++ language and library features are presented in the context of their use
rather than in the dry manner of a manual. The language features presented and the detail in which
they are described reflect my view of what is needed for effective use of C++. A companion, The
Annotated C++ Language Standard, authored by Andrew Koenig and myself, is the complete definition of the language together with comments aimed at making it more accessible. Logically,
there ought to be another companion, The Annotated C++ Standard Library. However, since both
time and my capacity for writing are limited, I cannot promise to produce that.
References to parts of this book are of the form §2.3.4 (Chapter 2, section 3, subsection 4),
§B.5.6 (Appendix B, subsection 5.6), and §6.6[10] (Chapter 6, exercise 10). Italics are used sparingly for emphasis (e.g., ‘‘a string literal is not acceptable’’), for first occurrences of important concepts (e.g., polymorphism), for nonterminals of the C++ grammar (e.g., for-statement), and for comments in code examples. Semi-bold italics are used to refer to identifiers, keywords, and numeric
values from code examples (e.g., counter, class, and 1712).
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
6 Notes to the Reader Chapter 1
1.1.2 Exercises
Exercises are found at the ends of chapters. The exercises are mainly of the write-a-program variety. Always write enough code for a solution to be compiled and run with at least a few test cases.
The exercises vary considerably in difficulty, so they are marked with an estimate of their difficulty. The scale is exponential so that if a (∗1) exercise takes you ten minutes, a (∗2) might take an
hour, and a (∗3) might take a day. The time needed to write and test a program depends more on
your experience than on the exercise itself. A (∗1) exercise might take a day if you first have to get
acquainted with a new computer system in order to run it. On the other hand, a (∗5) exercise might
be done in an hour by someone who happens to have the right collection of programs handy.
Any book on programming in C can be used as a source of extra exercises for Part I. Any book
on data structures and algorithms can be used as a source of exercises for Parts II and III.
1.1.3 Implementation Note
The language used in this book is ‘‘pure C++’’ as defined in the C++ standard [C++,1998]. Therefore, the examples ought to run on every C++ implementation. The major program fragments in
this book were tried using several C++ implementations. Examples using features only recently
adopted into C++ didn’t compile on every implementation. However, I see no point in mentioning
which implementations failed to compile which examples. Such information would soon be out of
date because implementers are working hard to ensure that their implementations correctly accept
every C++ feature. See Appendix B for suggestions on how to cope with older C++ compilers and
with code written for C compilers.
1.2 Learning C++
The most important thing to do when learning C++ is to focus on concepts and not get lost in
language-technical details. The purpose of learning a programming language is to become a better
programmer; that is, to become more effective at designing and implementing new systems and at
maintaining old ones. For this, an appreciation of programming and design techniques is far more
important than an understanding of details; that understanding comes with time and practice.
C++ supports a variety of programming styles. All are based on strong static type checking, and
most aim at achieving a high level of abstraction and a direct representation of the programmer’s
ideas. Each style can achieve its aims effectively while maintaining run-time and space efficiency.
A programmer coming from a different language (say C, Fortran, Smalltalk, Lisp, ML, Ada, Eiffel,
Pascal, or Modula-2) should realize that to gain the benefits of C++, they must spend time learning
and internalizing programming styles and techniques suitable to C++. The same applies to programmers used to an earlier and less expressive version of C++.
Thoughtlessly applying techniques effective in one language to another typically leads to awkward, poorly performing, and hard-to-maintain code. Such code is also most frustrating to write
because every line of code and every compiler error message reminds the programmer that the language used differs from ‘‘the old language.’’ You can write in the style of Fortran, C, Smalltalk,
etc., in any language, but doing so is neither pleasant nor economical in a language with a different
philosophy. Every language can be a fertile source of ideas of how to write C++ programs.
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
Section 1.2 Learning C++ 7
However, ideas must be transformed into something that fits with the general structure and type
system of C++ in order to be effective in the different context. Over the basic type system of a language, only Pyrrhic victories are possible.
C++ supports a gradual approach to learning. How you approach learning a new programming
language depends on what you already know and what you aim to learn. There is no one approach
that suits everyone. My assumption is that you are learning C++ to become a better programmer
and designer. That is, I assume that your purpose in learning C++ is not simply to learn a new syntax for doing things the way you used to, but to learn new and better ways of building systems.
This has to be done gradually because acquiring any significant new skill takes time and requires
practice. Consider how long it would take to learn a new natural language well or to learn to play a
new musical instrument well. Becoming a better system designer is easier and faster, but not as
much easier and faster as most people would like it to be.
It follows that you will be using C++ – often for building real systems – before understanding
every language feature and technique. By supporting several programming paradigms (Chapter 2),
C++ supports productive programming at several levels of expertise. Each new style of programming adds another tool to your toolbox, but each is effective on its own and each adds to your
effectiveness as a programmer. C++ is organized so that you can learn its concepts in a roughly linear order and gain practical benefits along the way. This is important because it allows you to gain
benefits roughly in proportion to the effort expended.
In the continuing debate on whether one needs to learn C before C++, I am firmly convinced
that it is best to go directly to C++. C++ is safer, more expressive, and reduces the need to focus on
low-level techniques. It is easier for you to learn the trickier parts of C that are needed to compensate for its lack of higher-level facilities after you have been exposed to the common subset of C
and C++ and to some of the higher-level techniques supported directly in C++. Appendix B is a
guide for programmers going from C++ to C, say, to deal with legacy code.
Several independently developed and distributed implementations of C++ exist. A wealth of
tools, libraries, and software development environments are also available. A mass of textbooks,
manuals, journals, newsletters, electronic bulletin boards, mailing lists, conferences, and courses
are available to inform you about the latest developments in C++, its use, tools, libraries, implementations, etc. If you plan to use C++ seriously, I strongly suggest that you gain access to such
sources. Each has its own emphasis and bias, so use at least two. For example, see [Barton,1994],
[Booch,1994], [Henricson,1997], [Koenig,1997], [Martin,1995].
1.3 The Design of C++
Simplicity was an important design criterion: where there was a choice between simplifying the
language definition and simplifying the compiler, the former was chosen. However, great importance was attached to retaining a high degree of compatibility with C [Koenig,1989] [Stroustrup,1994] (Appendix B); this precluded cleaning up the C syntax.
C++ has no built-in high-level data types and no high-level primitive operations. For example,
the C++ language does not provide a matrix type with an inversion operator or a string type with a
concatenation operator. If a user wants such a type, it can be defined in the language itself. In fact,
defining a new general-purpose or application-specific type is the most fundamental programming
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
8 Notes to the Reader Chapter 1
activity in C++. A well-designed user-defined type differs from a built-in type only in the way it is
defined, not in the way it is used. The C++ standard library described in Part III provides many
examples of such types and their uses. From a user’s point of view, there is little difference
between a built-in type and a type provided by the standard library.
Features that would incur run-time or memory overheads even when not used were avoided in
the design of C++. For example, constructs that would make it necessary to store ‘‘housekeeping
information’’ in every object were rejected, so if a user declares a structure consisting of two 16-bit
quantities, that structure will fit into a 32-bit register.
C++ was designed to be used in a traditional compilation and run-time environment, that is, the
C programming environment on the UNIX system. Fortunately, C++ was never restricted to UNIX;
it simply used UNIX and C as a model for the relationships between language, libraries, compilers,
linkers, execution environments, etc. That minimal model helped C++ to be successful on essentially every computing platform. There are, however, good reasons for using C++ in environments
that provide significantly more support. Facilities such as dynamic loading, incremental compilation, and a database of type definitions can be put to good use without affecting the language.
C++ type-checking and data-hiding features rely on compile-time analysis of programs to prevent accidental corruption of data. They do not provide secrecy or protection against someone who
is deliberately breaking the rules. They can, however, be used freely without incurring run-time or
space overheads. The idea is that to be useful, a language feature must not only be elegant; it must
also be affordable in the context of a real program.
For a systematic and detailed description of the design of C++, see [Stroustrup,1994].
1.3.1 Efficiency and Structure
C++ was developed from the C programming language and, with few exceptions, retains C as a
subset. The base language, the C subset of C++, is designed to ensure a very close correspondence
between its types, operators, and statements and the objects that computers deal with directly: numbers, characters, and addresses. Except for the new, delete, typeid, dynamic_cast, and throwoperators and the try-block, individual C++ expressions and statements need no run-time support.
C++ can use the same function call and return sequences as C – or more efficient ones. When
even such relatively efficient mechanisms are too expensive, a C++ function can be substituted
inline, so that we can enjoy the notational convenience of functions without run-time overhead.
One of the original aims for C was to replace assembly coding for the most demanding systems
programming tasks. When C++ was designed, care was taken not to compromise the gains in this
area. The difference between C and C++ is primarily in the degree of emphasis on types and structure. C is expressive and permissive. C++ is even more expressive. However, to gain that increase
in expressiveness, you must pay more attention to the types of objects. Knowing the types of
objects, the compiler can deal correctly with expressions when you would otherwise have had to
specify operations in painful detail. Knowing the types of objects also enables the compiler to
detect errors that would otherwise persist until testing – or even later. Note that using the type system to check function arguments, to protect data from accidental corruption, to provide new types,
to provide new operators, etc., does not increase run-time or space overheads in C++.
The emphasis on structure in C++ reflects the increase in the scale of programs written since C
was designed. You can make a small program (say, 1,000 lines) work through brute force even
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
Section 1.3.1 Efficiency and Structure 9
when breaking every rule of good style. For a larger program, this is simply not so. If the structure
of a 100,000-line program is bad, you will find that new errors are introduced as fast as old ones are
removed. C++ was designed to enable larger programs to be structured in a rational way so that it
would be reasonable for a single person to cope with far larger amounts of code. In addition, the
aim was to have an average line of C++ code express much more than the average line of C or Pascal code. C++ has by now been shown to over-fulfill these goals.
Not every piece of code can be well-structured, hardware-independent, easy-to-read, etc. C++
possesses features that are intended for manipulating hardware facilities in a direct and efficient
way without regard for safety or ease of comprehension. It also possesses facilities for hiding such
code behind elegant and safe interfaces.
Naturally, the use of C++ for larger programs leads to the use of C++ by groups of programmers. C++’s emphasis on modularity, strongly typed interfaces, and flexibility pays off here. C++
has as good a balance of facilities for writing large programs as any language has. However, as
programs get larger, the problems associated with their development and maintenance shift from
being language problems to more global problems of tools and management. Part IV explores
some of these issues.
This book emphasizes techniques for providing general-purpose facilities, generally useful
types, libraries, etc. These techniques will serve programmers of small programs as well as programmers of large ones. Furthermore, because all nontrivial programs consist of many semiindependent parts, the techniques for writing such parts serve programmers of all applications.
You might suspect that specifying a program by using a more detailed type structure would lead
to a larger program source text. With C++, this is not so. A C++ program declaring function argument types, using classes, etc., is typically a bit shorter than the equivalent C program not using
these facilities. Where libraries are used, a C++ program will appear much shorter than its C equivalent, assuming, of course, that a functioning C equivalent could have been built.
1.3.2 Philosophical Note
A programming language serves two related purposes: it provides a vehicle for the programmer to
specify actions to be executed, and it provides a set of concepts for the programmer to use when
thinking about what can be done. The first purpose ideally requires a language that is ‘‘close to the
machine’’ so that all important aspects of a machine are handled simply and efficiently in a way
that is reasonably obvious to the programmer. The C language was primarily designed with this in
mind. The second purpose ideally requires a language that is ‘‘close to the problem to be solved’’
so that the concepts of a solution can be expressed directly and concisely. The facilities added to C
to create C++ were primarily designed with this in mind.
The connection between the language in which we think/program and the problems and solutions we can imagine is very close. For this reason, restricting language features with the intent of
eliminating programmer errors is at best dangerous. As with natural languages, there are great benefits from being at least bilingual. A language provides a programmer with a set of conceptual
tools; if these are inadequate for a task, they will simply be ignored. Good design and the absence
of errors cannot be guaranteed merely by the presence or the absence of specific language features.
The type system should be especially helpful for nontrivial tasks. The C++ class concept has, in
fact, proven itself to be a powerful conceptual tool.
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
10 Notes to the Reader Chapter 1
1.4 Historical Note
I invented C++, wrote its early definitions, and produced its first implementation. I chose and formulated the design criteria for C++, designed all its major facilities, and was responsible for the
processing of extension proposals in the C++ standards committee.
Clearly, C++ owes much to C [Kernighan,1978]. Except for closing a few serious loopholes in
the type system (see Appendix B), C is retained as a subset. I also retained C’s emphasis on facilities that are low-level enough to cope with the most demanding systems programming tasks. C in
turn owes much to its predecessor BCPL [Richards,1980]; in fact, BCPL’s / / comment convention
was (re)introduced in C++. The other main source of inspiration for C++ was Simula67
[Dahl,1970] [Dahl,1972]; the class concept (with derived classes and virtual functions) was borrowed from it. C++’s facility for overloading operators and the freedom to place a declaration
wherever a statement can occur resembles Algol68 [Woodward,1974].
Since the original edition of this book, the language has been extensively reviewed and refined.
The major areas for revision were overload resolution, linking, and memory management facilities.
In addition, several minor changes were made to increase C compatibility. Several generalizations
and a few major extensions were added: these included multiple inheritance, staticmember functions, constmember functions, protectedmembers, templates, exception handling, run-time type
identification, and namespaces. The overall theme of these extensions and revisions was to make
C++ a better language for writing and using libraries. The evolution of C++ is described in [Stroustrup,1994].
The template facility was primarily designed to support statically typed containers (such as lists,
vectors, and maps) and to support elegant and efficient use of such containers (generic programming). A key aim was to reduce the use of macros and casts (explicit type conversion). Templates
were partly inspired by Ada’s generics (both their strengths and their weaknesses) and partly by
Clu’s parameterized modules. Similarly, the C++ exception-handling mechanism was inspired
partly by Ada [Ichbiah,1979], Clu [Liskov,1979], and ML [Wikstr. .
om,1987]. Other developments
in the 1985 to 1995 time span – such as multiple inheritance, pure virtual functions, and namespaces – were primarily generalizations driven by experience with the use of C++ rather than ideas
imported from other languages.
Earlier versions of the language, collectively known as ‘‘C with Classes’’ [Stroustrup,1994],
have been in use since 1980. The language was originally invented because I wanted to write some
event-driven simulations for which Simula67 would have been ideal, except for efficiency considerations. ‘‘C with Classes’’ was used for major projects in which the facilities for writing programs
that use minimal time and space were severely tested. It lacked operator overloading, references,
virtual functions, templates, exceptions, and many details. The first use of C++ outside a research
organization started in July 1983.
The name C++ (pronounced ‘‘see plus plus’’) was coined by Rick Mascitti in the summer of
1983. The name signifies the evolutionary nature of the changes from C; ‘‘++’’ is the C increment
operator. The slightly shorter name ‘‘C+’’ is a syntax error; it has also been used as the name of an
unrelated language. Connoisseurs of C semantics find C++ inferior to ++C. The language is not
called D, because it is an extension of C, and it does not attempt to remedy problems by removing
features. For yet another interpretation of the name C++, see the appendix of [Orwell,1949].
C++ was designed primarily so that my friends and I would not have to program in assembler,
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
Section 1.4 Historical Note 11
C, or various modern high-level languages. Its main purpose was to make writing good programs
easier and more pleasant for the individual programmer. In the early years, there was no C++ paper
design; design, documentation, and implementation went on simultaneously. There was no ‘‘C++
project’’ either, or a ‘‘C++ design committee.’’ Throughout, C++ evolved to cope with problems
encountered by users and as a result of discussions between my friends, my colleagues, and me.
Later, the explosive growth of C++ use caused some changes. Sometime during 1987, it
became clear that formal standardization of C++ was inevitable and that we needed to start preparing the ground for a standardization effort [Stroustrup,1994]. The result was a conscious effort to
maintain contact between implementers of C++ compilers and major users through paper and electronic mail and through face-to-face meetings at C++ conferences and elsewhere.
AT&T Bell Laboratories made a major contribution to this by allowing me to share drafts of
revised versions of the C++ reference manual with implementers and users. Because many of these
people work for companies that could be seen as competing with AT&T, the significance of this
contribution should not be underestimated. A less enlightened company could have caused major
problems of language fragmentation simply by doing nothing. As it happened, about a hundred
individuals from dozens of organizations read and commented on what became the generally
accepted reference manual and the base document for the ANSI C++ standardization effort. Their
names can be found in The Annotated C++ Reference Manual [Ellis,1989]. Finally, the X3J16
committee of ANSI was convened in December 1989 at the initiative of Hewlett-Packard. In June
1991, this ANSI (American national) standardization of C++ became part of an ISO (international)
standardization effort for C++. From 1990, these joint C++ standards committees have been the
main forum for the evolution of C++ and the refinement of its definition. I served on these committees throughout. In particular, as the chairman of the working group for extensions, I was directly
responsible for the handling of proposals for major changes to C++ and the addition of new language features. An initial draft standard for public review was produced in April 1995. The ISO
C++ standard (ISO/IEC 14882) was ratified in 1998.
C++ evolved hand-in-hand with some of the key classes presented in this book. For example, I
designed complex, vector, and stack classes together with the operator overloading mechanisms.
String and list classes were developed by Jonathan Shopiro and me as part of the same effort.
Jonathan’s string and list classes were the first to see extensive use as part of a library. The string
class from the standard C++ library has its roots in these early efforts. The task library described in
[Stroustrup,1987] and in §12.7[11] was part of the first ‘‘C with Classes’’ program ever written. I
wrote it and its associated classes to support Simula-style simulations. The task library has been
revised and reimplemented, notably by Jonathan Shopiro, and is still in extensive use. The stream
library as described in the first edition of this book was designed and implemented by me. Jerry
Schwarz transformed it into the iostreams library (Chapter 21) using Andrew Koenig’s manipulator
technique (§21.4.6) and other ideas. The iostreams library was further refined during standardization, when the bulk of the work was done by Jerry Schwarz, Nathan Myers, and Norihiro Kumagai.
The development of the template facility was influenced by the vector, map, list, and sorttemplates devised by Andrew Koenig, Alex Stepanov, me, and others. In turn, Alex Stepanov’s work
on generic programming using templates led to the containers and algorithms parts of the standard
C++ library (§16.3, Chapter 17, Chapter 18, §19.2). The valarraylibrary for numerical computation (Chapter 22) is primarily the work of Kent Budge.
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
12 Notes to the Reader Chapter 1
1.5 Use of C++
C++ is used by hundreds of thousands of programmers in essentially every application domain.
This use is supported by about a dozen independent implementations, hundreds of libraries, hundreds of textbooks, several technical journals, many conferences, and innumerable consultants.
Training and education at a variety of levels are widely available.
Early applications tended to have a strong systems programming flavor. For example, several
major operating systems have been written in C++ [Campbell,1987] [Rozier,1988] [Hamilton,1993]
[Berg,1995] [Parrington,1995] and many more have key parts done in C++. I considered uncompromising low-level efficiency essential for C++. This allows us to use C++ to write device drivers
and other software that rely on direct manipulation of hardware under real-time constraints. In such
code, predictability of performance is at least as important as raw speed. Often, so is compactness
of the resulting system. C++ was designed so that every language feature is usable in code under
severe time and space constraints [Stroustrup,1994,§4.5].
Most applications have sections of code that are critical for acceptable performance. However,
the largest amount of code is not in such sections. For most code, maintainability, ease of extension, and ease of testing is key. C++’s support for these concerns has led to its widespread use
where reliability is a must and in areas where requirements change significantly over time. Examples are banking, trading, insurance, telecommunications, and military applications. For years, the
central control of the U.S. long-distance telephone system has relied on C++ and every 800 call
(that is, a call paid for by the called party) has been routed by a C++ program [Kamath,1993].
Many such applications are large and long-lived. As a result, stability, compatibility, and scalability have been constant concerns in the development of C++. Million-line C++ programs are not
uncommon.
Like C, C++ wasn’t specifically designed with numerical computation in mind. However, much
numerical, scientific, and engineering computation is done in C++. A major reason for this is that
traditional numerical work must often be combined with graphics and with computations relying on
data structures that don’t fit into the traditional Fortran mold [Budge,1992] [Barton,1994]. Graphics and user interfaces are areas in which C++ is heavily used. Anyone who has used either an
Apple Macintosh or a PC running Windows has indirectly used C++ because the primary user interfaces of these systems are C++ programs. In addition, some of the most popular libraries supporting X for UNIX are written in C++. Thus, C++ is a common choice for the vast number of applications in which the user interface is a major part.
All of this points to what may be C++’s greatest strength: its ability to be used effectively for
applications that require work in a variety of application areas. It is quite common to find an application that involves local and wide-area networking, numerics, graphics, user interaction, and database access. Traditionally, such application areas have been considered distinct, and they have
most often been served by distinct technical communities using a variety of programming languages. However, C++ has been widely used in all of those areas. Furthermore, it is able to coexist
with code fragments and programs written in other languages.
C++ is widely used for teaching and research. This has surprised some who – correctly – point
out that C++ isn’t the smallest or cleanest language ever designed. It is, however
– clean enough for successful teaching of basic concepts,
– realistic, efficient, and flexible enough for demanding projects,
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
Section 1.5 Use of C++ 13
– available enough for organizations and collaborations relying on diverse development and
execution environments,
– comprehensive enough to be a vehicle for teaching advanced concepts and techniques, and
– commercial enough to be a vehicle for putting what is learned into non-academic use.
C++ is a language that you can grow with.
1.6 C and C++
C was chosen as the base language for C++ because it
[1] is versatile, terse, and relatively low-level;
[2] is adequate for most systems programming tasks;
[3] runs everywhere and on everything; and
[4] fits into the UNIX programming environment.
C has its problems, but a language designed from scratch would have some too, and we know C’s
problems. Importantly, working with C enabled ‘‘C with Classes’’ to be a useful (if awkward) tool
within months of the first thought of adding Simula-like classes to C.
As C++ became more widely used, and as the facilities it provided over and above those of C
became more significant, the question of whether to retain compatibility was raised again and
again. Clearly some problems could be avoided if some of the C heritage was rejected (see, e.g.,
[Sethi,1981]). This was not done because
[1] there are millions of lines of C code that might benefit from C++, provided that a complete
rewrite from C to C++ were unnecessary;
[2] there are millions of lines of library functions and utility software code written in C that
could be used from/on C++ programs provided C++ were link-compatible with and syntactically very similar to C;
[3] there are hundreds of thousands of programmers who know C and therefore need only learn
to use the new features of C++ and not relearn the basics; and
[4] C++ and C will be used on the same systems by the same people for years, so the differences should be either very large or very small so as to minimize mistakes and confusion.
The definition of C++ has been revised to ensure that a construct that is both legal C and legal C++
has the same meaning in both languages (with a few minor exceptions; see §B.2).
The C language has itself evolved, partly under the influence of the development of C++
[Rosler,1984]. The ANSI C standard [C,1990] contains a function declaration syntax borrowed
from ‘‘C with Classes.’’ Borrowing works both ways. For example, the void* pointer type was
invented for ANSI C and first implemented in C++. As promised in the first edition of this book,
the definition of C++ has been reviewed to remove gratuitous incompatibilities; C++ is now more
compatible with C than it was originally. The ideal was for C++ to be as close to ANSI C as possible – but no closer [Koenig,1989]. One hundred percent compatibility was never a goal because
that would compromise type safety and the smooth integration of user-defined and built-in types.
Knowing C is not a prerequisite for learning C++. Programming in C encourages many techniques and tricks that are rendered unnecessary by C++ language features. For example, explicit
type conversion (casting) is less frequently needed in C++ than it is in C (§1.6.1). However, good
C programs tend to be C++ programs. For example, every program in Kernighan and Ritchie, The
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
14 Notes to the Reader Chapter 1
C Programming Language (2nd Edition) [Kernighan,1988], is a C++ program. Experience with
any statically typed language will be a help when learning C++.
1.6.1 Suggestions for C Programmers
The better one knows C, the harder it seems to be to avoid writing C++ in C style, thereby losing
some of the potential benefits of C++. Please take a look at Appendix B, which describes the differences between C and C++. Here are a few pointers to the areas in which C++ has better ways of
doing something than C has:
[1] Macros are almost never necessary in C++. Use const(§5.4) or enum(§4.8) to define manifest constants, inline(§7.1.1) to avoid function-calling overhead, templates (Chapter 13) to
specify families of functions and types, and namespaces (§8.2) to avoid name clashes.
[2] Don’t declare a variable before you need it so that you can initialize it immediately. A
declaration can occur anywhere a statement can (§6.3.1), in for-statement initializers
(§6.3.3), and in conditions (§6.3.2.1).
[3] Don’t use malloc(). The newoperator (§6.2.6) does the same job better, and instead of
realloc(), try a vector(§3.8).
[4] Try to avoid void*, pointer arithmetic, unions, and casts, except deep within the implementation of some function or class. In most cases, a cast is an indication of a design error. If
you must use an explicit type conversion, try using one of the ‘‘new casts’’ (§6.2.7) for a
more precise statement of what you are trying to do.
[5] Minimize the use of arrays and C-style strings. The C++ standard library string(§3.5) and
vector(§3.7.1) classes can often be used to simplify programming compared to traditional C
style. In general, try not to build yourself what has already been provided by the standard
library.
To obey C linkage conventions, a C++ function must be declared to have C linkage (§9.2.4).
Most important, try thinking of a program as a set of interacting concepts represented as classes
and objects, instead of as a bunch of data structures with functions twiddling their bits.
1.6.2 Suggestions for C++ Programmers
By now, many people have been using C++ for a decade. Many more are using C++ in a single
environment and have learned to live with the restrictions imposed by early compilers and firstgeneration libraries. Often, what an experienced C++ programmer has failed to notice over the
years is not the introduction of new features as such, but rather the changes in relationships between
features that make fundamental new programming techniques feasible. In other words, what you
didn’t think of when first learning C++ or found impractical just might be a superior approach
today. You find out only by re-examining the basics.
Read through the chapters in order. If you already know the contents of a chapter, you can be
through in minutes. If you don’t already know the contents, you’ll have learned something unexpected. I learned a fair bit writing this book, and I suspect that hardly any C++ programmer knows
every feature and technique presented. Furthermore, to use the language well, you need a perspective that brings order to the set of features and techniques. Through its organization and examples,
this book offers such a perspective.
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
Section 1.7 Thinking about Programming in C++ 15
1.7 Thinking about Programming in C++
Ideally, you approach the task of designing a program in three stages. First, you gain a clear understanding of the problem (analysis), then you identify the key concepts involved in a solution
(design), and finally you express that solution in a program (programming). However, the details
of the problem and the concepts of the solution often become clearly understood only through the
effort to express them in a program and trying to get it to run acceptably. This is where the choice
of programming language matters.
In most applications, there are concepts that are not easily represented as one of the fundamental
types or as a function without associated data. Given such a concept, declare a class to represent it
in the program. A C++ class is a type. That is, it specifies how objects of its class behave: how they
are created, how they can be manipulated, and how they are destroyed. A class may also specify
how objects are represented, although in the early stages of the design of a program that should not
be the major concern. The key to writing good programs is to design classes so that each cleanly
represents a single concept. Often, this means that you must focus on questions such as: How are
objects of this class created? Can objects of this class be copied and/or destroyed? What operations can be applied to such objects? If there are no good answers to such questions, the concept
probably wasn’t ‘‘clean’’ in the first place. It might then be a good idea to think more about the
problem and its proposed solution instead of immediately starting to ‘‘code around’’ the problems.
The concepts that are easiest to deal with are the ones that have a traditional mathematical formalism: numbers of all sorts, sets, geometric shapes, etc. Text-oriented I/O, strings, basic containers, the fundamental algorithms on such containers, and some mathematical classes are part of the
standard C++ library (Chapter 3, §16.1.2). In addition, a bewildering variety of libraries supporting
general and domain-specific concepts are available.
A concept does not exist in a vacuum; there are always clusters of related concepts. Organizing
the relationship between classes in a program – that is, determining the exact relationship between
the different concepts involved in a solution – is often harder than laying out the individual classes
in the first place. The result had better not be a muddle in which every class (concept) depends on
every other. Consider two classes, A and B. Relationships such as ‘‘A calls functions from B,’’
‘‘A creates Bs,’’ and ‘‘A has a B member’’ seldom cause major problems, while relationships such
as ‘‘A uses data from B’’ can typically be eliminated.
One of the most powerful intellectual tools for managing complexity is hierarchical ordering,
that is, organizing related concepts into a tree structure with the most general concept as the root.
In C++, derived classes represent such structures. A program can often be organized as a set of
trees or directed acyclic graphs of classes. That is, the programmer specifies a number of base
classes, each with its own set of derived classes. Virtual functions (§2.5.5, §12.2.6) can often be
used to define operations for the most general version of a concept (a base class). When necessary,
the interpretation of these operations can be refined for particular special cases (derived classes).
Sometimes even a directed acyclic graph seems insufficient for organizing the concepts of a
program; some concepts seem to be inherently mutually dependent. In that case, we try to localize
cyclic dependencies so that they do not affect the overall structure of the program. If you cannot
eliminate or localize such mutual dependencies, then you are most likely in a predicament that no
programming language can help you out of. Unless you can conceive of some easily stated relationships between the basic concepts, the program is likely to become unmanageable.
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
16 Notes to the Reader Chapter 1
One of the best tools for untangling dependency graphs is the clean separation of interface and
implementation. Abstract classes (§2.5.4, §12.3) are C++’s primary tool for doing that.
Another form of commonality can be expressed through templates (§2.7, Chapter 13). A class
template specifies a family of classes. For example, a list template specifies ‘‘list of T,’’ where
‘‘T’’ can be any type. Thus, a template is a mechanism for specifying how one type is generated
given another type as an argument. The most common templates are container classes such as lists,
vectors, and associative arrays (maps) and the fundamental algorithms using such containers. It is
usually a mistake to express parameterization of a class and its associated functions with a type
using inheritance. It is best done using templates.
Remember that much programming can be simply and clearly done using only primitive types,
data structures, plain functions, and a few library classes. The whole apparatus involved in defining new types should not be used except when there is a real need.
The question ‘‘How does one write good programs in C++?’’ is very similar to the question
‘‘How does one write good English prose?’’ There are two answers: ‘‘Know what you want to
say’’ and ‘‘Practice. Imitate good writing.’’ Both appear to be as appropriate for C++ as they are
for English – and as hard to follow.
1.8 Advice
Here is a set of ‘‘rules’’ you might consider while learning C++. As you get more proficient you
can evolve them into something suitable for your kind of applications and your style of programming. They are deliberately very simple, so they lack detail. Don’t take them too literally. To
write a good program takes intelligence, taste, and patience. You are not going to get it right the
first time. Experiment!
[1] When you program, you create a concrete representation of the ideas in your solution to some
problem. Let the structure of the program reflect those ideas as directly as possible:
[a] If you can think of ‘‘it’’ as a separate idea, make it a class.
[b] If you can think of ‘‘it’’ as a separate entity, make it an object of some class.
[c] If two classes have a common interface, make that interface an abstract class.
[d] If the implementations of two classes have something significant in common, make that
commonality a base class.
[e] If a class is a container of objects, make it a template.
[f] If a function implements an algorithm for a container, make it a template function implementing the algorithm for a family of containers.
[g] If a set of classes, templates, etc., are logically related, place them in a common namespace.
[2] When you define either a class that does not implement either a mathematical entity like a
matrix or a complex number or a low-level type such as a linked list:
[a] Don’t use global data (use members).
[b] Don’t use global functions.
[c] Don’t use public data members.
[d] Don’t use friends, except to avoid [a] or [c].
[e] Don’t put a ‘‘type field’’ in a class; use virtual functions.
[f] Don’t use inline functions, except as a significant optimization.
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
Section 1.8 Advice 17
More specific or detailed rules of thumb can be found in the ‘‘Advice’’ section of each chapter.
Remember, this advice is only rough rules of thumb, not immutable laws. A piece of advice should
be applied only ‘‘where reasonable.’’ There is no substitute for intelligence, experience, common
sense, and good taste.
I find rules of the form ‘‘never do this’’ unhelpful. Consequently, most advice is phrased as
suggestions of what to do, while negative suggestions tend not to be phrased as absolute prohibitions. I know of no major feature of C++ that I have not seen put to good use. The ‘‘Advice’’ sections do not contain explanations. Instead, each piece of advice is accompanied by a reference to
the appropriate section of the book. Where negative advice is given, that section usually provides a
suggested alternative.
1.8.1 References
There are few direct references in the text, but here is a short list of books and papers that are mentioned directly or indirectly.
[Barton,1994] John J. Barton and Lee R. Nackman: Scientific and Engineering C++.
Addison-Wesley. Reading, Mass. 1994. ISBN 0-201-53393-6.
[Berg,1995] William Berg, Marshall Cline, and Mike Girou: Lessons Learned from the
OS/400 OO Project. CACM. Vol. 38 No. 10. October 1995.
[Booch,1994] Grady Booch: Object-Oriented Analysis and Design. Benjamin/Cummings.
Menlo Park, Calif. 1994. ISBN 0-8053-5340-2.
[Budge,1992] Kent Budge, J. S. Perry, and A. C. Robinson: High-Performance Scientific
Computation using C++. Proc. USENIX C++ Conference. Portland, Oregon.
August 1992.
[C,1990] X3 Secretariat: Standard – The C Language. X3J11/90-013. ISO Standard
ISO/IEC 9899. Computer and Business Equipment Manufacturers Association.
Washington, DC, USA.
[C++,1998] X3 Secretariat: International Standard – The C++ Language. X3J16-14882.
Information Technology Council (NSITC). Washington, DC, USA.
[Campbell,1987] Roy Campbell, et al.: The Design of a Multiprocessor Operating System. Proc.
USENIX C++ Conference. Santa Fe, New Mexico. November 1987.
[Coplien,1995] James O. Coplien and Douglas C. Schmidt (editors): Pattern Languages of
Program Design. Addison-Wesley. Reading, Mass. 1995. ISBN 0-201-
60734-4.
[Dahl,1970] O-J. Dahl, B. Myrhaug, and K. Nygaard: SIMULA Common Base Language.
Norwegian Computing Center S-22. Oslo, Norway. 1970.
[Dahl,1972] O-J. Dahl and C. A. R. Hoare: Hierarchical Program Construction in Structured Programming. Academic Press, New York. 1972.
[Ellis,1989] Margaret A. Ellis and Bjarne Stroustrup: The Annotated C++ Reference Manual. Addison-Wesley. Reading, Mass. 1990. ISBN 0-201-51459-1.
[Gamma,1995] Erich Gamma, et al.: Design Patterns. Addison-Wesley. Reading, Mass.
1995. ISBN 0-201-63361-2.
[Goldberg,1983] A. Goldberg and D. Robson: SMALLTALK-80 – The Language and Its Implementation. Addison-Wesley. Reading, Mass. 1983.
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
18 Notes to the Reader Chapter 1
[Griswold,1970] R. E. Griswold, et al.: The Snobol4 Programming Language. Prentice-Hall.
Englewood Cliffs, New Jersey. 1970.
[Griswold,1983] R. E. Griswold and M. T. Griswold: The ICON Programming Language.
Prentice-Hall. Englewood Cliffs, New Jersey. 1983.
[Hamilton,1993] G. Hamilton and P. Kougiouris: The Spring Nucleus: A Microkernel for
Objects. Proc. 1993 Summer USENIX Conference. USENIX.
[Henricson,1997] Mats Henricson and Erik Nyquist: Industrial Strength C++: Rules and Recommendations. Prentice-Hall. Englewood Cliffs, New Jersey. 1997. ISBN 0-
13-120965-5.
[Ichbiah,1979] Jean D. Ichbiah, et al.: Rationale for the Design of the ADA Programming Language. SIGPLAN Notices. Vol. 14 No. 6. June 1979.
[Kamath,1993] Yogeesh H. Kamath, Ruth E. Smilan, and Jean G. Smith: Reaping Benefits with
Object-Oriented Technology. AT&T Technical Journal. Vol. 72 No. 5.
September/October 1993.
[Kernighan,1978] Brian W. Kernighan and Dennis M. Ritchie: The C Programming Language.
Prentice-Hall. Englewood Cliffs, New Jersey. 1978.
[Kernighan,1988] Brian W. Kernighan and Dennis M. Ritchie: The C Programming Language
(Second Edition). Prentice-Hall. Englewood Cliffs, New Jersey. 1988. ISBN
0-13-110362-8.
[Koenig,1989] Andrew Koenig and Bjarne Stroustrup: C++: As close to C as possible – but no
closer. The C++ Report. Vol. 1 No. 7. July 1989.
[Koenig,1997] Andrew Koenig and Barbara Moo: Ruminations on C++. Addison Wesley
Longman. Reading, Mass. 1997. ISBN 0-201-42339-1.
[Knuth,1968] Donald Knuth: The Art of Computer Programming. Addison-Wesley. Reading, Mass.
[Liskov,1979] Barbara Liskov et al.: Clu Reference Manual. MIT/LCS/TR-225. MIT Cambridge. Mass. 1979.
[Martin,1995] Robert C. Martin: Designing Object-Oriented C++ Applications Using the
Booch Method. Prentice-Hall. Englewood Cliffs, New Jersey. 1995. ISBN
0-13-203837-4.
[Orwell,1949] George Orwell: 1984. Secker and Warburg. London. 1949.
[Parrington,1995] Graham Parrington et al.: The Design and Implementation of Arjuna. Computer Systems. Vol. 8 No. 3. Summer 1995.
[Richards,1980] Martin Richards and Colin Whitby-Strevens: BCPL – The Language and Its
Compiler. Cambridge University Press, Cambridge. England. 1980. ISBN
0-521-21965-5.
[Rosler,1984] L. Rosler: The Evolution of C – Past and Future. AT&T Bell Laboratories
Technical Journal. Vol. 63 No. 8. Part 2. October 1984.
[Rozier,1988] M. Rozier, et al.: CHORUS Distributed Operating Systems. Computing Systems. Vol. 1 No. 4. Fall 1988.
[Sethi,1981] Ravi Sethi: Uniform Syntax for Type Expressions and Declarations. Software
Practice & Experience. Vol. 11. 1981.
[Stepanov,1994] Alexander Stepanov and Meng Lee: The Standard Template Library. HP Labs
Technical Report HPL-94-34 (R. 1). August, 1994.
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
Section 1.8.1 References 19
[Stroustrup,1986] Bjarne Stroustrup: The C++ Programming Language. Addison-Wesley.
Reading, Mass. 1986. ISBN 0-201-12078-X.
[Stroustrup,1987] Bjarne Stroustrup and Jonathan Shopiro: A Set of C Classes for Co-Routine
Style Programming. Proc. USENIX C++ Conference. Santa Fe, New Mexico.
November 1987.
[Stroustrup,1991] Bjarne Stroustrup: The C++ Programming Language (Second Edition).
Addison-Wesley. Reading, Mass. 1991. ISBN 0-201-53992-6.
[Stroustrup,1994] Bjarne Stroustrup: The Design and Evolution of C++. Addison-Wesley. Reading, Mass. 1994. ISBN 0-201-54330-3.
[Tarjan,1983] Robert E. Tarjan: Data Structures and Network Algorithms. Society for Industrial and Applied Mathematics. Philadelphia, Penn. 1983. ISBN 0-898-
71187-8.
[Unicode,1996] The Unicode Consortium: The Unicode Standard, Version 2.0. AddisonWesley Developers Press. Reading, Mass. 1996. ISBN 0-201-48345-9.
[UNIX,1985] UNIX Time-Sharing System: Programmer’s Manual. Research Version, Tenth
Edition. AT&T Bell Laboratories, Murray Hill, New Jersey. February 1985.
[Wilson,1996] Gregory V. Wilson and Paul Lu (editors): Parallel Programming Using C++.
The MIT Press. Cambridge. Mass. 1996. ISBN 0-262-73118-5.
[Wikstr. .
om,1987] A˚ ke Wikstr. .
om: Functional Programming Using ML. Prentice-Hall. Englewood Cliffs, New Jersey. 1987.
[Woodward,1974] P. M. Woodward and S. G. Bond: Algol 68-R Users Guide. Her Majesty’s Stationery Office. London. England. 1974.
References to books relating to design and larger software development issues can be found at the
end of Chapter 23.
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
20 Notes to the Reader Chapter 1
The C++ Programming Language, Special Edition by Bjarne Stroustrup. Copyright 2000 by AT&T.
Published by Addison Wesley, Inc. ISBN 0-201-70073-5. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
2 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
A Tour of C+ +
The first thing we do, let´s
kill all the language lawyers.
– Henry VI, part II
What is C++? — programming paradigms — procedural programming — modularity —
separate compilation — exception handling — data abstraction — user-defined types —
concrete types — abstract types — virtual functions — object-oriented programming —
generic programming — containers — algorithms — language and programming —
advice.
2.1 What is C++? [tour.intro]
C++ is a general-purpose programming language with a bias towards systems programming that
– is a better C,
– supports data abstraction,
– supports object-oriented programming, and
– supports generic programming.
This chapter explains what this means without going into the finer details of the language definition. Its purpose is to give you a general overview of C++ and the key techniques for using it, not
to provide you with the detailed information necessary to start programming in C++.
If you find some parts of this chapter rough going, just ignore those parts and plow on. All will
be explained in detail in later chapters. However, if you do skip part of this chapter, do yourself a
favor by returning to it later.
Detailed understanding of language features – even of all features of a language – cannot compensate for lack of an overall view of the language and the fundamental techniques for using it.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
22 A Tour of C++ Chapter 2
2.2 Programming Paradigms [tour.paradigm]
Object-oriented programming is a technique for programming – a paradigm for writing ‘‘good’’
programs for a set of problems. If the term ‘‘object-oriented programming language’’ means anything, it must mean a programming language that provides mechanisms that support the objectoriented style of programming well.
There is an important distinction here. A language is said to support a style of programming if
it provides facilities that make it convenient (reasonably easy, safe, and efficient) to use that style.
A language does not support a technique if it takes exceptional effort or skill to write such programs; it merely enables the technique to be used. For example, you can write structured programs
in Fortran77 and object-oriented programs in C, but it is unnecessarily hard to do so because these
languages do not directly support those techniques.
Support for a paradigm comes not only in the obvious form of language facilities that allow
direct use of the paradigm, but also in the more subtle form of compile-time and/or run-time checks
against unintentional deviation from the paradigm. Type checking is the most obvious example of
this; ambiguity detection and run-time checks are also used to extend linguistic support for paradigms. Extra-linguistic facilities such as libraries and programming environments can provide further support for paradigms.
One language is not necessarily better than another because it possesses a feature the other does
not. There are many examples to the contrary. The important issue is not so much what features a
language possesses, but that the features it does possess are sufficient to support the desired programming styles in the desired application areas:
[1] All features must be cleanly and elegantly integrated into the language.
[2] It must be possible to use features in combination to achieve solutions that would otherwise
require extra, separate features.
[3] There should be as few spurious and ‘‘special-purpose’’ features as possible.
[4] A feature’s implementation should not impose significant overheads on programs that do
not require it.
[5] A user should need to know only about the subset of the language explicitly used to write a
program.
The first principle is an appeal to aesthetics and logic. The next two are expressions of the ideal of
minimalism. The last two can be summarized as ‘‘what you don’t know won’t hurt you.’’
C++ was designed to support data abstraction, object-oriented programming, and generic programming in addition to traditional C programming techniques under these constraints. It was not
meant to force one particular programming style upon all users.
The following sections consider some programming styles and the key language mechanisms
supporting them. The presentation progresses through a series of techniques starting with procedural programming and leading up to the use of class hierarchies in object-oriented programming and
generic programming using templates. Each paradigm builds on its predecessors, each adds something new to the C++ programmer’s toolbox, and each reflects a proven design approach.
The presentation of language features is not exhaustive. The emphasis is on design approaches
and ways of organizing programs rather than on language details. At this stage, it is far more
important to gain an idea of what can be done using C++ than to understand exactly how it can be
achieved.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 2.3 Procedural Programming 23
2.3 Procedural Programming [tour.proc]
The original programming paradigm is:
Decide which procedures you want;
use the best algorithms you can find.
The focus is on the processing – the algorithm needed to perform the desired computation. Languages support this paradigm by providing facilities for passing arguments to functions and returning values from functions. The literature related to this way of thinking is filled with discussion of
ways to pass arguments, ways to distinguish different kinds of arguments, different kinds of functions (e.g., procedures, routines, and macros), etc.
A typical example of ‘‘good style’’ is a square-root function. Given a double-precision
floating-point argument, it produces a result. To do this, it performs a well-understood mathematical computation:
double sqrt(double arg)
{
/ / code for calculating a square root
}
void f()
{
double root2= sqrt(2) ;
/ / ...
}
Curly braces, { }, express grouping in C++. Here, they indicate the start and end of the function
bodies. The double slash, / /, begins a comment that extends to the end of the line. The keyword
voidindicates that a function does not return a value.
From the point of view of program organization, functions are used to create order in a maze of
algorithms. The algorithms themselves are written using function calls and other language facilities. The following subsections present a thumb-nail sketch of C++’s most basic facilities for
expressing computation.
2.3.1 Variables and Arithmetic [tour.var]
Every name and every expression has a type that determines the operations that may be performed
on it. For example, the declaration
int inch;
specifies that inchis of type int; that is, inchis an integer variable.
A declaration is a statement that introduces a name into the program. It specifies a type for that
name. A type defines the proper use of a name or an expression.
C++ offers a variety of fundamental types, which correspond directly to hardware facilities. For
example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
24 A Tour of C++ Chapter 2
bool/ / Boolean, possible values are true and false
char/ / character, for example, ’a’, ’z’, and ’9’
int/ / integer, for example, 1, 42, and 1216
double/ / double-precision floating-point number, for example, 3.14 and 299793.0
A charvariable is of the natural size to hold a character on a given machine (typically a byte), and
an intvariable is of the natural size for integer arithmetic on a given machine (typically a word).
The arithmetic operators can be used for any combination of these types:
+ / / plus, both unary and binary
- / / minus, both unary and binary
* / / multiply
/ / / divide
% / / remainder
So can the comparison operators:
== / / equal
!= / / not equal
< / / less than
> / / greater than
<= / / less than or equal
>= / / greater than or equal
In assignments and in arithmetic operations, C++ performs all meaningful conversions between the
basic types so that they can be mixed freely:
void some_function() / / function that doesn’t return a value
{
double d= 2.2; / / initialize floating-point number
int i= 7; / / initialize integer
d= d+i; / / assign sum to d
i= d*i; / / assign product to i
}
As in C, = is the assignment operator and == tests equality.
2.3.2 Tests and Loops [tour.loop]
C++ provides a conventional set of statements for expressing selection and looping. For example,
here is a simple function that prompts the user and returns a Boolean indicating the response:
bool accept()
{
cout<< "Do you want to proceed(y or n)?\n"; / / write question
char answer= 0;
cin>> answer; / / read answer
if(answer== ´y´) return true;
return false;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 2.3.2 Tests and Loops 25
The << operator (‘‘put to’’) is used as an output operator; coutis the standard output stream. The
>> operator (‘‘get from’’) is used as an input operator; cinis the standard input stream. The type of
the right-hand operand of >> determines what input is accepted and is the target of the input operation. The \ncharacter at the end of the output string represents a newline.
The example could be slightly improved by taking an ‘n’ answer into account:
bool accept2()
{
cout<< "Do you want to proceed(y or n)?\n"; / / write question
char answer= 0;
cin>> answer; / / read answer
switch(answer) {
case´y´:
return true;
case´n´:
return false;
default:
cout<< "I´ll take that for a no.\n";
return false;
}
}
A switch-statement tests a value against a set of constants. The case constants must be distinct, and
if the value tested does not match any of them, the defaultis chosen. The programmer need not
provide a default.
Few programs are written without loops. In this case, we might like to give the user a few tries:
bool accept3()
{
int tries= 1;
while(tries< 4) {
cout<< "Do you want to proceed(y or n)?\n"; / / write question
char answer= 0;
cin>> answer; / / read answer
switch(answer) {
case´y´:
return true;
case´n´:
return false;
default:
cout<< "Sorry, I don´t understand that.\n";
tries= tries+ 1;
}
}
cout<< "I´ll take that for a no.\n";
return false;
}
The while-statement executes until its condition becomes false.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
26 A Tour of C++ Chapter 2
2.3.3 Pointers and Arrays [tour.ptr]
An array can be declared like this:
char v[10] ; / / array of 10 characters
Similarly, a pointer can be declared like this:
char* p; / / pointer to character
In declarations, [] means ‘‘array of’’ and * means ‘‘pointer to.’’ All arrays have 0as their lower
bound, so vhas ten elements, v[0]...v[9]. A pointer variable can hold the address of an object of
the appropriate type:
p= &v[3] ; / / p points to v’s fourth element
Unary & is the address-of operator.
Consider copying ten elements from one array to another:
void another_function()
{
int v1[10] ;
int v2[10] ;
/ / ...
for(int i=0; i<10; ++i) v1[i]=v2[i] ;
}
This for-statement can be read as ‘‘set ito zero, while iis less than 10, copy the ith element and
increment i.’’ When applied to an integer variable, the increment operator ++ simply adds 1.
2.4 Modular Programming [tour.module]
Over the years, the emphasis in the design of programs has shifted from the design of procedures
and toward the organization of data. Among other things, this reflects an increase in program size.
A set of related procedures with the data they manipulate is often called a module. The programming paradigm becomes:
Decide which modules you want;
partition the program so that data is hidden within modules.
This paradigm is also known as the data-hiding principle. Where there is no grouping of procedures with related data, the procedural programming style suffices. Also, the techniques for designing ‘‘good procedures’’ are now applied for each procedure in a module. The most common example of a module is the definition of a stack. The main problems that have to be solved are:
[1] Provide a user interface for the stack (e.g., functions push() and pop()).
[2] Ensure that the representation of the stack (e.g., an array of elements) can be accessed only
through this user interface.
[3] Ensure that the stack is initialized before its first use.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 2.4 Modular Programming 27
C++ provides a mechanism for grouping related data, functions, etc., into separate namespaces. For
example, the user interface of a Stackmodule could be declared and used like this:
namespace Stack{ / / interface
void push(char) ;
char pop() ;
}
void f()
{
Stack: :push(´c´) ;
if(Stack: :pop() != ´c´) error("impossible") ;
}
The Stack: : qualification indicates that the push() and pop() are those from the Stacknamespace. Other uses of those names will not interfere or cause confusion.
The definition of the Stackcould be provided in a separately-compiled part of the program:
namespace Stack{ / / implementation
const int max_size= 200;
char v[max_size] ;
int top= 0;
void push(char c) { /* check for overflow and push c */ }
char pop() { /* check for underflow and pop */ }
}
The key point about this Stackmodule is that the user code is insulated from the data representation
of Stackby the code implementing Stack: :push() and Stack: :pop(). The user doesn’t need to
know that the Stackis implemented using an array, and the implementation can be changed without
affecting user code.
Because data is only one of the things one might want to ‘‘hide,’’ the notion of data hiding is
trivially extended to the notion of information hiding; that is, the names of functions, types, etc.,
can also be made local to a module. Consequently, C++ allows any declaration to be placed in a
namespace (§8.2).
This Stackmodule is one way of representing a stack. The following sections use a variety of
stacks to illustrate different programming styles.
2.4.1 Separate Compilation [tour.comp]
C++ supports C’s notion of separate compilation. This can be used to organize a program into a set
of semi-independent fragments.
Typically, we place the declarations that specify the interface to a module in a file with a name
indicating its intended use. Thus,
namespace Stack{ / / interface
void push(char) ;
char pop() ;
}
would be placed in a file stack.h, and users will include that file, called a header file, like this:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
28 A Tour of C++ Chapter 2
#include"stack.h" / / get the interface
void f()
{
Stack: :push(´c´) ;
if(Stack: :pop() != ´c´) error("impossible") ;
}
To help the compiler ensure consistency, the file providing the implementation of the Stackmodule
will also include the interface:
#include"stack.h" / / get the interface
namespace Stack{ / / representation
const int max_size= 200;
char v[max_size] ;
int top= 0;
}
void Stack: :push(char c) { /* check for overflow and push c */ }
char Stack: :pop() { /* check for underflow and pop */ }
The user code goes in a third file, say user.c. The code in user.cand stack.cshares the stack
interface information presented in stack.h, but the two files are otherwise independent and can be
separately compiled. Graphically, the program fragments can be represented like this:
Stack interface
. .
#include "stack.h"
use stack
. .
#include "stack.h"
define stack
.
stack.h:
user.c: stack.c:
Separate compilation is an issue in all real programs. It is not simply a concern in programs that
present facilities, such as a Stack, as modules. Strictly speaking, using separate compilation isn’t a
language issue; it is an issue of how best to take advantage of a particular language implementation.
However, it is of great practical importance. The best approach is to maximize modularity, represent that modularity logically through language features, and then exploit the modularity physically
through files for effective separate compilation (Chapter 8, Chapter 9).
2.4.2 Exception Handling [tour.except]
When a program is designed as a set of modules, error handling must be considered in light of these
modules. Which module is responsible for handling what errors? Often, the module that detects an
error doesn’t know what action to take. The recovery action depends on the module that invoked
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 2.4.2 Exception Handling 29
the operation rather than on the module that found the error while trying to perform the operation.
As programs grow, and especially when libraries are used extensively, standards for handling errors
(or, more generally, ‘‘exceptional circumstances’’) become important.
Consider again the Stackexample. What ought to be done when we try to push() one too
many characters? The writer of the Stackmodule doesn’t know what the user would like to be
done in this case, and the user cannot consistently detect the problem (if the user could, the overflow wouldn’t happen in the first place). The solution is for the Stackimplementer to detect the
overflow and then tell the (unknown) user. The user can then take appropriate action. For example:
namespace Stack{ / / interface
void push(char) ;
char pop() ;
class Overflow{ }; / / type representing overflow exceptions
}
When detecting an overflow, Stack: :push() can invoke the exception-handling code; that is,
‘‘throw an Overflowexception:’’
void Stack: :push(char c)
{
if(top== max_size) throw Overflow() ;
/ / push c
}
The throwtransfers control to a handler for exceptions of type Stack: :Overflowin some function
that directly or indirectly called Stack: :push(). To do that, the implementation will unwind the
function call stack as needed to get back to the context of that caller. Thus, the throwacts as a multilevel return. For example:
void f()
{
/ / ...
try{ / / exceptions here are handled by the handler defined below
while(true) Stack: :push(´c´) ;
}
catch(Stack: :Overflow) {
/ / oops: stack overflow; take appropriate action
}
/ / ...
}
The whileloop will try to loop forever. Therefore, the catch-clause providing a handler for
Stack: :Overflowwill be entered after some call of Stack: :push() causes a throw.
Use of the exception-handling mechanisms can make error handling more regular and readable.
See §8.3 and Chapter 14 for further discussion and details.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
30 A Tour of C++ Chapter 2
2.5 Data Abstraction [tour.da]
Modularity is a fundamental aspect of all successful large programs. It remains a focus of all
design discussions throughout this book. However, modules in the form described previously are
not sufficient to express complex systems cleanly. Here, I first present a way of using modules to
provide a form of user-defined types and then show how to overcome some problems with that
approach by defining user-defined types directly.
2.5.1 Modules Defining Types [tour.types]
Programming with modules leads to the centralization of all data of a type under the control of a
type manager module. For example, if we wanted many stacks – rather than the single one provided by the Stackmodule above – we could define a stack manager with an interface like this:
namespace Stack{
struct Rep; / / definition of stack layout is elsewhere
typedef Rep& stack;
stack create() ; / / make a new stack
void destroy(stack s) ; / / delete s
void push(stack s, char c) ; / / push c onto s
char pop(stack s) ; / / pop s
}
The declaration
struct Rep;
says that Repis the name of a type, but it leaves the type to be defined later (§5.7). The declaration
typedef Rep& stack;
gives the name stackto a ‘‘reference to Rep’’ (details in §5.5). The idea is that a stack is identified
by its Stack: :stackand that further details are hidden from users.
A Stack: :stackacts much like a variable of a built-in type:
struct Bad_pop{ };
void f()
{
Stack: :stack s1= Stack: :create() ; / / make a new stack
Stack: :stack s2= Stack: :create() ; / / make another new stack
Stack: :push(s1,´c´) ;
Stack: :push(s2,´k´) ;
if(Stack: :pop(s1) != ´c´) throw Bad_pop() ;
if(Stack: :pop(s2) != ´k´) throw Bad_pop() ;
Stack: :destroy(s1) ;
Stack: :destroy(s2) ;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 2.5.1 Modules Defining Types 31
We could implement this Stackin several ways. It is important that a user doesn’t need to know
how we do it. As long as we keep the interface unchanged, a user will not be affected if we decide
to re-implement Stack.
An implementation might preallocate a few stack representations and let Stack: :create() hand
out a reference to an unused one. Stack: :destroy() could then mark a representation ‘‘unused’’
so that Stack: :create() can recycle it:
namespace Stack{ / / representation
const int max_size= 200;
struct Rep{
char v[max_size] ;
int top;
};
const int max= 16; / / maximum number of stacks
Rep stacks[max] ; / / preallocated stack representations
bool used[max] ; / / used[i] is true if stacks[i] is in use
}
void Stack: :push(stack s, char c) { /* check s for overflow and push c */ }
char Stack: :pop(stack s) { /* check s for underflow and pop */ }
Stack: :stack Stack: :create()
{
/ / pick an unused Rep, mark it used, initialize it, and return a reference to it
}
void Stack: :destroy(stack s) { /* mark s unused */ }
What we have done is to wrap a set of interface functions around the representation type. How the
resulting ‘‘stack type’’ behaves depends partly on how we defined these interface functions, partly
on how we presented the representation type to the users of Stacks, and partly on the design of the
representation type itself.
This is often less than ideal. A significant problem is that the presentation of such ‘‘fake types’’
to the users can vary greatly depending on the details of the representation type – and users ought
to be insulated from knowledge of the representation type. For example, had we chosen to use a
more elaborate data structure to identify a stack, the rules for assignment and initialization of
Stack: :stacks would have changed dramatically. This may indeed be desirable at times. However, it shows that we have simply moved the problem of providing convenient Stacks from the
Stackmodule to the Stack: :stackrepresentation type.
More fundamentally, user-defined types implemented through a module providing access to an
implementation type don’t behave like built-in types and receive less and different support than do
built-in types. For example, the time that a Stack: :Repcan be used is controlled through
Stack: :create() and Stack: :destroy() rather than by the usual language rules.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
32 A Tour of C++ Chapter 2
2.5.2 User-Defined Types [tour.udt]
C++ attacks this problem by allowing a user to directly define types that behave in (nearly) the
same way as built-in types. Such a type is often called an abstract data type. I prefer the term
user-defined type. A more reasonable definition of abstract data type would require a mathematical ‘‘abstract’’ specification. Given such a specification, what are called types here would be concrete examples of such truly abstract entities. The programming paradigm becomes:
Decide which types you want;
provide a full set of operations for each type.
Where there is no need for more than one object of a type, the data-hiding programming style using
modules suffices.
Arithmetic types such as rational and complex numbers are common examples of user-defined
types. Consider:
class complex{
double re, im;
public:
complex(double r, double i) { re=r; im=i; } / / construct complex from two scalars
complex(double r) { re=r; im=0; } / / construct complex from one scalar
complex() { re= im= 0; } / / default complex: (0,0)
friend complex operator+(complex, complex) ;
friend complex operator-(complex, complex) ; / / binary
friend complex operator-(complex) ; / / unary
friend complex operator*(complex, complex) ;
friend complex operator/(complex, complex) ;
friend bool operator==(complex, complex) ; / / equal
friend bool operator!=(complex, complex) ; / / not equal
/ / ...
};
The declaration of class (that is, user-defined type) complexspecifies the representation of a complex number and the set of operations on a complex number. The representation is private; that is,
reand imare accessible only to the functions specified in the declaration of class complex. Such
functions can be defined like this:
complex operator+(complex a1, complex a2)
{
return complex(a1.re+a2.re,a1.im+a2.im) ;
}
A member function with the same name as its class is called a constructor. A constructor defines a
way to initialize an object of its class. Class complexprovides three constructors. One makes a
complexfrom a double, another takes a pair of doubles, and the third makes a complexwith a
default value.
Class complexcan be used like this:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 2.5.2 User-Defined Types 33
void f(complex z)
{
complex a= 2.3;
complex b= 1/a;
complex c= a+b*complex(1,2.3) ;
/ / ...
if(c!= b) c= -(b/a)+2*b;
}
The compiler converts operators involving complexnumbers into appropriate function calls. For
example, c!=bmeans operator!=(c,b) and 1/ameans operator/(complex(1) ,a).
Most, but not all, modules are better expressed as user-defined types.
2.5.3 Concrete Types [tour.concrete]
User-defined types can be designed to meet a wide variety of needs. Consider a user-defined Stack
type along the lines of the complextype. To make the example a bit more realistic, this Stacktype
is defined to take its number of elements as an argument:
class Stack{
char* v;
int top;
int max_size;
public:
class Underflow{ }; / / used as exception
class Overflow{ }; / / used as exception
class Bad_size{ }; / / used as exception
Stack(int s) ; / / constructor
~Stack() ; / / destructor
void push(char c) ;
char pop() ;
};
The constructor Stack(int) will be called whenever an object of the class is created. This takes
care of initialization. If any cleanup is needed when an object of the class goes out of scope, a complement to the constructor – called the destructor – can be declared:
Stack: :Stack(int s) / / constructor
{
top= 0;
if(10000<s) throw Bad_size() ;
max_size= s;
v= new char[s] ; / / allocate elements on the free store (heap, dynamic store)
}
Stack: :~Stack() / / destructor
{
delete[] v; / / free the elements for possible reuse of their space (§6.2.6)
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
34 A Tour of C++ Chapter 2
The constructor initializes a new Stackvariable. To do so, it allocates some memory on the free
store (also called the heap or dynamic store) using the newoperator. The destructor cleans up by
freeing that memory. This is all done without intervention by users of Stacks. The users simply
create and use Stacks much as they would variables of built-in types. For example:
Stack s_var1(10) ; / / global stack with 10 elements
void f(Stack& s_ref, int i) / / reference to Stack
{
Stack s_var2(i) ; / / local stack with i elements
Stack* s_ptr= new Stack(20) ; / / pointer to Stack allocated on free store
s_var1.push(´a´) ;
s_var2.push(´b´) ;
s_ref.push(´c´) ;
s_ptr->push(´d´) ;
/ / ...
}
This Stacktype obeys the same rules for naming, scope, allocation, lifetime, copying, etc., as does
a built-in type such as intand char.
Naturally, the push() and pop() member functions must also be defined somewhere:
void Stack: :push(char c)
{
if(top== max_size) throw Overflow() ;
v[top] = c;
top= top+ 1;
}
char Stack: :pop()
{
if(top== 0) throw Underflow() ;
top= top- 1;
return v[top] ;
}
Types such as complexand Stackare called concrete types, in contrast to abstract types, where the
interface more completely insulates a user from implementation details.
2.5.4 Abstract Types [tour.abstract]
One property was lost in the transition from Stackas a ‘‘fake type’’ implemented by a module
(§2.5.1) to a proper type (§2.5.3). The representation is not decoupled from the user interface;
rather, it is a part of what would be included in a program fragment using Stacks. The representation is private, and therefore accessible only through the member functions, but it is present. If it
changes in any significant way, a user must recompile. This is the price to pay for having concrete
types behave exactly like built-in types. In particular, we cannot have genuine local variables of a
type without knowing the size of the type’s representation.
For types that don’t change often, and where local variables provide much-needed clarity and
efficiency, this is acceptable and often ideal. However, if we want to completely isolate users of a
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 2.5.4 Abstract Types 35
stack from changes to its implementation, this last Stackis insufficient. Then, the solution is to
decouple the interface from the representation and give up genuine local variables.
First, we define the interface:
class Stack{
public:
class Underflow{ }; / / used as exception
class Overflow{ }; / / used as exception
virtual void push(char c) = 0;
virtual char pop() = 0;
};
The word virtualmeans ‘‘may be redefined later in a class derived from this one’’ in Simula and
C++. A class derived from Stackprovides an implementation for the Stackinterface. The curious
=0syntax says that some class derived from Stack must define the function. Thus, this Stackcan
serve as the interface to any class that implements its push() and pop() functions.
This Stackcould be used like this:
void f(Stack& s_ref)
{
s_ref.push(´c´) ;
if(s_ref.pop() != ´c´) throw bad_stack() ;
}
Note how f() uses the Stackinterface in complete ignorance of implementation details. A class
that provides the interface to a variety of other classes is often called a polymorphic type.
Not surprisingly, the implementation could consist of everything from the concrete class Stack
that we left out of the interface Stack:
class Array_stack: public Stack{ / / Array_stack implements Stack
char* p;
int max_size;
int top;
public:
Array_stack(int s) ;
~Array_stack() ;
void push(char c) ;
char pop() ;
};
The ‘‘:public’’ can be read as ‘‘is derived from,’’ ‘‘implements,’’ and ‘‘is a subtype of.’’
For a function like f() to use a Stackin complete ignorance of implementation details, some
other function will have to make an object on which it can operate. For example:
void g()
{
Array_stack as(200) ;
f(as) ;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
36 A Tour of C++ Chapter 2
Since f() doesn’t know about Array_stacks but only knows the Stackinterface, it will work just as
well for a different implementation of a Stack. For example:
class List_stack: public Stack{ / / List_stack implements Stack
list<char> lc; / / (standard library) list of characters (§3.7.3)
public:
List_stack() { }
void push(char c) { lc.push_front(c) ; }
char pop() ;
};
char List_stack: :pop()
{
char x= lc.front() ; / / get first element
lc.pop_front() ; / / remove first element
return x;
}
Here, the representation is a list of characters. The lc.push_front(c) adds cas the first element of
lc, the call lc.pop_front() removes the first element, and lc.front() denotes lc’s first element.
A function can create a List_stackand have f() use it:
void h()
{
List_stack ls;
f(ls) ;
}
2.5.5 Virtual Functions [tour.virtual]
How is the call s_set.pop() in f() resolved to the right function definition? When f() is called
from h(), List_stack: :pop() must be called. When f() is called from g(),
Array_stack: :pop() must be called. To achieve this resolution, a Stackobject must contain
information to indicate the function to be called at run-time. A common implementation technique
is for the compiler to convert the name of a virtualfunction into an index into a table of pointers to
functions. That table is usually called ‘‘a virtual function table’’ or simply, a vtbl. Each class with
virtual functions has its own vtblidentifying its virtual functions. This can be represented graphically like this:
p
max_size
top
. . Array_stack::push()
Array_stack::pop()
Array_stack object:vtbl:
.
lc
. . List_stack::push()
List_stack::pop()
List_stack object:vtbl:
.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 2.5.5 Virtual Functions 37
The functions in the vtblallow the object to be used correctly even when the size of the object and
the layout of its data are unknown to the caller. All the caller needs to know is the location of the
vtblin a Stackand the index used for each virtual function. This virtual call mechanism can be
made essentially as efficient as the ‘‘normal function call’’ mechanism. Its space overhead is one
pointer in each object of a class with virtual functions plus one vtblfor each such class.
2.6 Object-Oriented Programming [tour.oop]
Data abstraction is fundamental to good design and will remain a focus of design throughout this
book. However, user-defined types by themselves are not flexible enough to serve our needs. This
section first demonstrates a problem with simple user-defined data types and then shows how to
overcome that problem by using class hierarchies.
2.6.1 Problems with Concrete Types [tour.problems]
A concrete type, like a ‘‘fake type’’ defined through a module, defines a sort of black box. Once
the black box has been defined, it does not really interact with the rest of the program. There is no
way of adapting it to new uses except by modifying its definition. This situation can be ideal, but it
can also lead to severe inflexibility. Consider defining a type Shapefor use in a graphics system.
Assume for the moment that the system has to support circles, triangles, and squares. Assume also
that we have
class Point{ /* ... */ };
class Color{ /* ... */ };
The /* and */ specify the beginning and end, respectively, of a comment. This comment notation
can be used for multi-line comments and comments that end before the end of a line.
We might define a shape like this:
enum Kind{ circle, triangle, square}; / / enumeration (§4.8)
class Shape{
Kind k; / / type field
Point center;
Color col;
/ / ...
public:
void draw() ;
void rotate(int) ;
/ / ...
};
The ‘‘type field’’ kis necessary to allow operations such as draw() and rotate() to determine
what kind of shape they are dealing with (in a Pascal-like language, one might use a variant record
with tag k). The function draw() might be defined like this:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
38 A Tour of C++ Chapter 2
void Shape: :draw()
{
switch(k) {
case circle:
/ / draw a circle
break;
case triangle:
/ / draw a triangle
break;
case square:
/ / draw a square
break;
}
}
This is a mess. Functions such as draw() must ‘‘know about’’ all the kinds of shapes there are.
Therefore, the code for any such function grows each time a new shape is added to the system. If
we define a new shape, every operation on a shape must be examined and (possibly) modified. We
are not able to add a new shape to a system unless we have access to the source code for every
operation. Because adding a new shape involves ‘‘touching’’ the code of every important operation
on shapes, doing so requires great skill and potentially introduces bugs into the code that handles
other (older) shapes. The choice of representation of particular shapes can get severely cramped by
the requirement that (at least some of) their representation must fit into the typically fixed-sized
framework presented by the definition of the general type Shape.
2.6.2 Class Hierarchies [tour.hierarchies]
The problem is that there is no distinction between the general properties of every shape (that is, a
shape has a color, it can be drawn, etc.) and the properties of a specific kind of shape (a circle is a
shape that has a radius, is drawn by a circle-drawing function, etc.). Expressing this distinction and
taking advantage of it defines object-oriented programming. Languages with constructs that allow
this distinction to be expressed and used support object-oriented programming. Other languages
don’t.
The inheritance mechanism (borrowed for C++ from Simula) provides a solution. First, we
specify a class that defines the general properties of all shapes:
class Shape{
Point center;
Color col;
/ / ...
public:
Point where() { return center; }
void move(Point to) { center= to; /* ... */ draw() ; }
virtual void draw() = 0;
virtual void rotate(int angle) = 0;
/ / ...
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 2.6.2 Class Hierarchies 39
As in the abstract type Stackin §2.5.4, the functions for which the calling interface can be defined
– but where the implementation cannot be defined yet – are virtual. In particular, the functions
draw() and rotate() can be defined only for specific shapes, so they are declared virtual.
Given this definition, we can write general functions manipulating vectors of pointers to shapes:
void rotate_all(vector<Shape*>& v, int angle) / / rotate v’s elements angle degrees
{
for(int i= 0; i<v.size() ; ++i) v[i]->rotate(angle) ;
}
To define a particular shape, we must say that it is a shape and specify its particular properties
(including the virtual functions):
class Circle: public Shape{
int radius;
public:
void draw() { /* ... */ }
void rotate(int) {} / / yes, the null function
};
In C++, class Circleis said to be derived from class Shape, and class Shapeis said to be a base of
class Circle. An alternative terminology calls Circleand Shapesubclass and superclass, respectively. The derived class is said to inherit members from its base class, so the use of base and
derived classes is commonly referred to as inheritance.
The programming paradigm is:
Decide which classes you want;
provide a full set of operations for each class;
make commonality explicit by using inheritance.
Where there is no such commonality, data abstraction suffices. The amount of commonality
between types that can be exploited by using inheritance and virtual functions is the litmus test of
the applicability of object-oriented programming to a problem. In some areas, such as interactive
graphics, there is clearly enormous scope for object-oriented programming. In other areas, such as
classical arithmetic types and computations based on them, there appears to be hardly any scope for
more than data abstraction, and the facilities needed for the support of object-oriented programming
seem unnecessary.
Finding commonality among types in a system is not a trivial process. The amount of commonality to be exploited is affected by the way the system is designed. When a system is designed –
and even when the requirements for the system are written – commonality must be actively sought.
Classes can be designed specifically as building blocks for other types, and existing classes can be
examined to see if they exhibit similarities that can be exploited in a common base class.
For attempts to explain what object-oriented programming is without recourse to specific programming language constructs, see [Kerr,1987] and [Booch,1994] in §23.6.
Class hierarchies and abstract classes (§2.5.4) complement each other instead of being mutually
exclusive (§12.5). In general, the paradigms listed here tend to be complementary and often
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
40 A Tour of C++ Chapter 2
mutually supportive. For example, classes and modules contain functions, while modules contain
classes and functions. The experienced designer applies a variety of paradigms as need dictates.
2.7 Generic Programming [tour.generic]
Someone who wants a stack is unlikely always to want a stack of characters. A stack is a general
concept, independent of the notion of a character. Consequently, it ought to be represented independently.
More generally, if an algorithm can be expressed independently of representation details and if
it can be done so affordably and without logical contortions, it ought to be done so.
The programming paradigm is:
Decide which algorithms you want;
parameterize them so that they work for
a variety of suitable types and data structures.
2.7.1 Containers [tour.containers]
We can generalize a stack-of-characters type to a stack-of-anything type by making it a template
and replacing the specific type charwith a template parameter. For example:
template<class T> class Stack{
T* v;
int max_size;
int top;
public:
class Underflow{ };
class Overflow{ };
Stack(int s) ; / / constructor
~Stack() ; / / destructor
void push(T) ;
T pop() ;
};
The template<class T> prefix makes Ta parameter of the declaration it prefixes.
The member functions might be defined similarly:
template<class T> void Stack<T>: :push(T c)
{
if(top== max_size) throw Overflow() ;
v[top] = c;
top= top+ 1;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 2.7.1 Containers 41
template<class T> T Stack<T>: :pop()
{
if(top== 0) throw Underflow() ;
top= top- 1;
return v[top] ;
}
Given these definitions, we can use stacks like this:
Stack<char> sc; / / stack of characters
Stack<complex> scplx; / / stack of complex numbers
Stack< list<int> > sli; / / stack of list of integers
void f()
{
sc.push(´c´) ;
if(sc.pop() != ´c´) throw Bad_pop() ;
scplx.push(complex(1,2)) ;
if(scplx.pop() != complex(1,2)) throw Bad_pop() ;
}
Similarly, we can define lists, vectors, maps (that is, associative arrays), etc., as templates. A class
holding a collection of elements of some type is commonly called a container class, or simply a
container.
Templates are a compile-time mechanism so that their use incurs no run-time overhead compared to ‘‘hand-written code.’’
2.7.2 Generic Algorithms [tour.algorithms]
The C++ standard library provides a variety of containers, and users can write their own (Chapter 3,
Chapter 17, Chapter 18). Thus, we find that we can apply the generic programming paradigm once
more to parameterize algorithms by containers. For example, we want to sort, copy, and search
vectors, lists, and arrays without having to write sort(), copy(), and search() functions for each
container. We also don’t want to convert to a specific data structure accepted by a single sort function. Therefore, we must find a generalized way of defining our containers that allows us to manipulate one without knowing exactly which kind of container it is.
One approach, the approach taken for the containers and non-numerical algorithms in the C++
standard library (§3.8, Chapter 18) is to focus on the notion of a sequence and manipulate
sequences through iterators.
Here is a graphical representation of the notion of a sequence:
begin end
... . . . . ..
.
. .. . . . .
.
.
. elements:
A sequence has a beginning and an end. An iterator refers to an element, and provides an operation
that makes the iterator refer to the next element of the sequence. The end of a sequence is an
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
42 A Tour of C++ Chapter 2
iterator that refers one beyond the last element of the sequence. The physical representation of
‘‘the end’’ may be a sentinel element, but it doesn’t have to be. In fact, the point is that this notion
of sequences covers a wide variety of representations, including lists and arrays.
We need some standard notation for operations such as ‘‘access an element through an iterator’’
and ‘‘make the iterator refer to the next element.’’ The obvious choices (once you get the idea) are
to use the dereference operator * to mean ‘‘access an element through an iterator’’ and the increment operator ++ to mean ‘‘make the iterator refer to the next element.’’
Given that, we can write code like this:
template<class In, class Out> void copy(In from, In too_far, Out to)
{
while(from!= too_far) {
*to= *from; / / copy element pointed to
++to; / / next input
++from; / / next output
}
}
This copies any container for which we can define iterators with the right syntax and semantics.
C++’s built-in, low-level array and pointer types have the right operations for that, so we can
write
char vc1[200] ; / / array of 200 characters
char vc2[500] ; / / array of 500 characters
void f()
{
copy(&vc1[0] ,&vc1[200] ,&vc2[0]) ;
}
This copies vc1from its first element until its last into vc2starting at vc2’s first element.
All standard library containers (§16.3, Chapter 17) support this notion of iterators and
sequences.
Two template parameters Inand Outare used to indicate the types of the source and the target
instead of a single argument. This was done because we often want to copy from one kind of container into another. For example:
complex ac[200] ;
void g(vector<complex>& vc, list<complex>& lc)
{
copy(&ac[0] ,&ac[200] ,lc.begin()) ;
copy(lc.begin() ,lc.end() ,vc.begin()) ;
}
This copies the array to the listand the listto the vector. For a standard container, begin() is an
iterator pointing to the first element.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 2.8 Postscript 43
2.8 Postscript [tour.post]
No programming language is perfect. Fortunately, a programming language does not have to be
perfect to be a good tool for building great systems. In fact, a general-purpose programming language cannot be perfect for all of the many tasks to which it is put. What is perfect for one task is
often seriously flawed for another because perfection in one area implies specialization. Thus, C++
was designed to be a good tool for building a wide variety of systems and to allow a wide variety of
ideas to be expressed directly.
Not everything can be expressed directly using the built-in features of a language. In fact, that
isn’t even the ideal. Language features exist to support a variety of programming styles and techniques. Consequently, the task of learning a language should focus on mastering the native and
natural styles for that language – not on the understanding of every little detail of all the language
features.
In practical programming, there is little advantage in knowing the most obscure language features or for using the largest number of features. A single language feature in isolation is of little
interest. Only in the context provided by techniques and by other features does the feature acquire
meaning and interest. Thus, when reading the following chapters, please remember that the real
purpose of examining the details of C++ is to be able to use them in concert to support good programming style in the context of sound designs.
2.9 Advice [tour.advice]
[1] Don’t panic! All will become clear in time; §2.1.
[2] You don’t have to know every detail of C++ to write good programs; §1.7.
[3] Focus on programming techniques, not on language features; §2.1.
.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
44 A Tour of C++ Chapter 2
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
3 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
A Tour of the Standard Library
Why waste time learning
when ignorance is instantaneous?
– Hobbes
Standard libraries — output — strings — input — vectors — range checking — lists —
maps — container overview — algorithms — iterators — I/O iterators — traversals and
predicates — algorithms using member functions — algorithm overview — complex
numbers — vector arithmetic— standard library overview — advice.
3.1 Introduction [tour2.lib]
No significant program is written in just a bare programming language. First, a set of supporting
libraries are developed. These then form the basis for further work.
Continuing Chapter 2, this chapter gives a quick tour of key library facilities to give you an idea
what can be done using C++ and its standard library. Useful library types, such as string, vector,
list, and map, are presented as well as the most common ways of using them. Doing this allows me
to give better examples and to set better exercises in the following chapters. As in Chapter 2, you
are strongly encouraged not to be distracted or discouraged by an incomplete understanding of
details. The purpose of this chapter is to give you a taste of what is to come and to convey an
understanding of the simplest uses of the most useful library facilities. A more detailed introduction to the standard library is given in §16.1.2.
The standard library facilities described in this book are part of every complete C++ implementation. In addition to the standard C++ library, most implementations offer ‘‘graphical user interface’’ systems, often referred to as GUIs or window systems, for interaction between a user and a
program. Similarly, most application development environments provide ‘‘foundation libraries’’
that support corporate or industrial ‘‘standard’’ development and/or execution environments. I do
not describe such systems and libraries. The intent is to provide a self-contained description of C++
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
46 A Tour of the Standard Library Chapter 3
as defined by the standard and to keep the examples portable, except where specifically noted. Naturally, a programmer is encouraged to explore the more extensive facilities available on most systems, but that is left to exercises.
3.2 Hello, world! [tour2.hello]
The minimal C++ program is
int main() { }
It defines a function called main, which takes no arguments and does nothing.
Every C++ program must have a function named main(). The program starts by executing that
function. The intvalue returned by main(), if any, is the program’s return value to ‘‘the system.’’
If no value is returned, the system will receive a value indicating successful completion. A nonzero
value from main() indicates failure.
Typically, a program produces some output. Here is a program that writes out Hello, world!:
#include<iostream>
int main()
{
std: :cout<< "Hello, world!\n";
}
The line #include<iostream> instructs the compiler to include the declarations of the standard
stream I/O facilities as found in iostream. Without these declarations, the expression
std: :cout<< "Hello, world!\n"
would make no sense. The operator << (‘‘put to’’) writes its second argument onto its first. In this
case, the string literal "Hello, world!\n" is written onto the standard output stream std: :cout. A
string literal is a sequence of characters surrounded by double quotes. In a string literal, the backslash character \followed by another character denotes a single special character. In this case, \nis
the newline character, so that the characters written are Hello, world! followed by a newline.
3.3 The Standard Library Namespace [tour2.name]
The standard library is defined in a namespace (§2.4, §8.2) called std. That is why I wrote
std: :coutrather than plain cout. I was being explicit about using the standard cout, rather than
some other cout.
Every standard library facility is provided through some standard header similar to <iostream>.
For example:
#include<string>
#include<list>
This makes the standard stringand listavailable. To use them, the std: : prefix can be used:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 3.3 The Standard Library Namespace 47
std: :string s= "Four legs Good; two legs Baaad!";
std: :list<std: :string> slogans;
For simplicity, I will rarely use the std: : prefix explicitly in examples. Neither will I always
#includethe necessary headers explicitly. To compile and run the program fragments here, you
must #includethe appropriate headers (as listed in §3.7.5, §3.8.6, and Chapter 16). In addition,
you must either use the std: : prefix or make every name from stdglobal (§8.2.3). For example:
#include<string> / / make the standard string facilities accessible
using namespace std; / / make std names available without std:: prefix
string s= "Ignorance is bliss!"; / / ok: string is std::string
It is generally in poor taste to dump every name from a namespace into the global namespace.
However, to keep short the program fragments used to illustrate language and library features, I
omit repetitive #includes and std: : qualifications. In this book, I use the standard library almost
exclusively, so if a name from the standard library is used, it either is a use of what the standard
offers or part of an explanation of how the standard facility might be defined.
3.4 Output [tour2.ostream]
The iostream library defines output for every built-in type. Further, it is easy to define output of a
user-defined type. By default, values output to coutare converted to a sequence of characters. For
example,
void f()
{
cout<< 10;
}
will place the character 1followed by the character 0on the standard output stream. So will
void g()
{
int i= 10;
cout<< i;
}
Output of different types can be combined in the obvious way:
void h(int i)
{
cout<< "the value of i is";
cout<< i;
cout<< ´\n´;
}
If ihas the value 10, the output will be
the value of i is 10
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
48 A Tour of the Standard Library Chapter 3
A character constant is a character enclosed in single quotes. Note that a character constant is output as a character rather than as a numerical value. For example,
void k()
{
cout<< ´a´;
cout<< ´b´;
cout<< ´c´;
}
will output abc.
People soon tire of repeating the name of the output stream when outputting several related
items. Fortunately, the result of an output expression can itself be used for further output. For
example:
void h2(int i)
{
cout<< "the value of i is" << i<< ´\n´;
}
This is equivalent to h(). Streams are explained in more detail in Chapter 21.
3.5 Strings [tour2.string]
The standard library provides a stringtype to complement the string literals used earlier. The
stringtype provides a variety of useful string operations, such as concatenation. For example:
string s1= "Hello";
string s2= "world";
void m1()
{
string s3= s1+ ", " + s2+ "!\n";
cout<< s3;
}
Here, s3is initialized to the character sequence
Hello, world!
followed by a newline. Addition of strings means concatenation. You can add strings, string literals, and characters to a string.
In many applications, the most common form of concatenation is adding something to the end
of a string. This is directly supported by the += operation. For example:
void m2(string& s1, string& s2)
{
s1= s1+ ´\n´; / / append newline
s2+= ´\n´; / / append newline
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 3.5 Strings 49
The two ways of adding to the end of a string are semantically equivalent, but I prefer the latter
because it is more concise and likely to be more efficiently implemented.
Naturally, strings can be compared against each other and against string literals. For example:
string incantation;
void respond(const string& answer)
{
if(answer== incantation) {
/ / perform magic
}
else if(answer== "yes") {
/ / ...
}
/ / ...
}
The standard library string class is described in Chapter 20. Among other useful features, it provides the ability to manipulate substrings. For example:
string name= "Niels Stroustrup";
void m3()
{
string s= name.substr(6,10) ; / / s = "Stroustrup"
name.replace(0,5,"Nicholas") ; / / name becomes "Nicholas Stroustrup"
}
The substr() operation returns a string that is a copy of the substring indicated by its arguments.
The first argument is an index into the string (a position), and the second argument is the length of
the desired substring. Since indexing starts from 0, sgets the value Stroustrup.
The replace() operation replaces a substring with a value. In this case, the substring starting at
0with length 5is Niels; it is replaced by Nicholas. Thus, the final value of nameis Nicholas
Stroustrup. Note that the replacement string need not be the same size as the substring that it is
replacing.
3.5.1 C-Style Strings [tour2.cstring]
A C-style string is a zero-terminated array of characters (§5.2.2). As shown, we can easily enter a
C-style string into a string. To call functions that take C-style strings, we need to be able to extract
the value of a stringin the form of a C-style string. The c_str() function does that (§20.4.1). For
example, we can print the nameusing the C output function printf() (§21.8) like this:
void f()
{
printf("name: %s\n",name.c_str()) ;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
50 A Tour of the Standard Library Chapter 3
3.6 Input [tour2.istream]
The standard library offers istreams for input. Like ostreams, istreams deal with character string
representations of built-in types and can easily be extended to cope with user-defined types.
The operator >> (‘‘get from’’) is used as an input operator; cinis the standard input stream.
The type of the right-hand operand of >> determines what input is accepted and what is the target
of the input operation. For example,
void f()
{
int i;
cin>> i; / / read an integer into i
double d;
cin>> d; / / read a double-precision, floating-point number into d
}
reads a number, such as 1234, from the standard input into the integer variable iand a floatingpoint number, such as 12.34e5, into the double-precision, floating-point variable d.
Here is an example that performs inch-to-centimeter and centimeter-to-inch conversions. You
input a number followed by a character indicating the unit: centimeters or inches. The program
then outputs the corresponding value in the other unit:
int main()
{
const float factor= 2.54; / / 1 inch equals 2.54 cm
float x, in, cm;
char ch= 0;
cout<< "enter length: ";
cin>> x; / / read a floating-point number
cin>> ch; / / read a suffix
switch(ch) {
case´i´: / / inch
in= x;
cm= x*factor;
break;
case´c´: / / cm
in= x/factor;
cm= x;
break;
default:
in= cm= 0;
break;
}
cout<< in<< " in= " << cm<< " cm\n";
}
The switch-statement tests a value against a set of constants. The break-statements are used to exit
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 3.6 Input 51
the switch-statement. The case constants must be distinct. If the value tested does not match any of
them, the defaultis chosen. The programmer need not provide a default.
Often, we want to read a sequence of characters. A convenient way of doing that is to read into
a string. For example:
int main()
{
string str;
cout<< "Please enter your name\n";
cin>> str;
cout<< "Hello, " << str<< "!\n";
}
If you type in
Eric
the response is
Hello, Eric!
By default, a whitespace character (§5.2.2) such as a space terminates the read, so if you enter
Eric Bloodaxe
pretending to be the ill-fated king of York, the response is still
Hello, Eric!
You can read a whole line using the getline() function. For example:
int main()
{
string str;
cout<< "Please enter your name\n";
getline(cin,str) ;
cout<< "Hello, " << str<< "!\n";
}
With this program, the input
Eric Bloodaxe
yields the desired output:
Hello, Eric Bloodaxe!
The standard strings have the nice property of expanding to hold what you put in them, so if you
enter a couple of megabytes of semicolons, the program will echo pages of semicolons back at you
– unless your machine or operating system runs out of some critical resource first.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
52 A Tour of the Standard Library Chapter 3
3.7 Containers [tour2.stl]
Much computing involves creating collections of various forms of objects and then manipulating
such collections. Reading characters into a string and printing out the string is a simple example.
A class with the main purpose of holding objects is commonly called a container. Providing suitable containers for a given task and supporting them with useful fundamental operations are important steps in the construction of any program.
To illustrate the standard library’s most useful containers, consider a simple program for keeping names and telephone numbers. This is the kind of program for which different approaches
appear ‘‘simple and obvious’’ to people of different backgrounds.
3.7.1 Vector [tour2.vector]
For many C programmers, a built-in array of (name,number) pairs would seem to be a suitable
starting point:
struct Entry{
string name;
int number;
};
Entry phone_book[1000] ;
void print_entry(int i) / / simple use
{
cout<< phone_book[i].name<< ´ ´ << phone_book[i].number<< ´\n´;
}
However, a built-in array has a fixed size. If we choose a large size, we waste space; if we choose a
smaller size, the array will overflow. In either case, we will have to write low-level memorymanagement code. The standard library provides a vector(§16.3) that takes care of that:
vector<Entry> phone_book(1000) ;
void print_entry(int i) / / simple use, exactly as for array
{
cout<< phone_book[i].name<< ´ ´ << phone_book[i].number<< ´\n´;
}
void add_entries(int n) / / increase size by n
{
phone_book.resize(phone_book.size()+n) ;
}
The vectormember function size() gives the number of elements.
Note the use of parentheses in the definition of phone_book. We made a single object of type
vector<Entry> and supplied its initial size as an initializer. This is very different from declaring a
built-in array:
vector<Entry> book(1000) ; / / vector of 1000 elements
vector<Entry> books[1000] ; / / 1000 empty vectors
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 3.7.1 Vector 53
Should you make the mistake of using [] where you meant () when declaring a vector, your compiler will almost certainly catch the mistake and issue an error message when you try to use the
vector.
A vectoris a single object that can be assigned. For example:
void f(vector<Entry>& v)
{
vector<Entry> v2= phone_book;
v= v2;
/ / ...
}
Assigning a vectorinvolves copying its elements. Thus, after the initialization and assignment in
f(), vand v2each holds a separate copy of every Entryin the phone book. When a vectorholds
many elements, such innocent-looking assignments and initializations can be prohibitively expensive. Where copying is undesirable, references or pointers should be used.
3.7.2 Range Checking [tour2.range]
The standard library vectordoes not provide range checking by default (§16.3.3). For example:
void f()
{
int i= phone_book[1001].number; / / 1001 is out of range
/ / ...
}
The initialization is likely to place some random value in irather than giving an error. This is
undesirable, so I will use a simple range-checking adaptation of vector, called Vec, in the following
chapters. A Vecis like a vector, except that it throws an exception of type out_of_rangeif a subscript is out of range.
Techniques for implementing types such as Vecand for using exceptions effectively are discussed in §11.12, §8.3, and Chapter 14. However, the definition here is sufficient for the examples
in this book:
template<class T> class Vec: public vector<T> {
public:
Vec() : vector<T>() { }
Vec(int s) : vector<T>(s) { }
T& operator[](int i) { return at(i) ; } / / range-checked
const T& operator[](int i) const{ return at(i) ; } / / range-checked
};
The at() operation is a vectorsubscript operation that throws an exception of type out_of_range
if its argument is out of the vector’s range (§16.3.3).
Returning to the problem of keeping names and telephone numbers, we can now use a Vecto
ensure that out-of-range accesses are caught. For example:
Vec<Entry> phone_book(1000) ;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
54 A Tour of the Standard Library Chapter 3
void print_entry(int i) / / simple use, exactly as for vector
{
cout<< phone_book[i].name<< ´ ´ << phone_book[i].number<< ´\n´;
}
An out-of-range access will throw an exception that the user can catch. For example:
void f()
{
try{
for(int i= 0; i<10000; i++) print_entry(i) ;
}
catch(out_of_range) {
cout<< "range error\n";
}
}
The exception will be thrown, and then caught, when phone_book[i] is tried with i==1000.
If the user doesn’t catch this kind of exception, the program will terminate in a well-defined manner
rather than proceeding or failing in an undefined manner. One way to minimize surprises from
exceptions is to use a main() with a try-block as its body:
int main()
try{
/ / your code
}
catch(out_of_range) {
cerr<< "range error\n";
}
catch(...) {
cerr<< "unknown exception thrown\n";
}
This provides default exception handlers so that if we fail to catch some exception, an error message is printed on the standard error-diagnostic output stream cerr(§21.2.1).
3.7.3 List [tour2.list]
Insertion and deletion of phone book entries could be common. Therefore, a list could be more
appropriate than a vector for representing a simple phone book. For example:
list<Entry> phone_book;
When we use a list, we tend not to access elements using subscripting the way we commonly do for
vectors. Instead, we might search the list looking for an element with a given value. To do this, we
take advantage of the fact that a listis a sequence as described in §3.8:
void print_entry(const string& s)
{
typedef list<Entry>: :const_iterator LI;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 3.7.3 List 55
for(LI i= phone_book.begin() ; i!= phone_book.end() ; ++i) {
Entry& e= *i; / / reference used as shorthand
if(s== e.name) cout<< e.name<< ´ ´ << e.number<< ´\n´;
}
}
The search for sstarts at the beginning of the list and proceeds until either sis found or the end is
reached. Every standard library container provides the functions begin() and end(), which return
an iterator to the first and to one-past-the-last element, respectively (§16.3.2). Given an iterator i,
the next element is ++i. Given an iterator i, the element it refers to is *i.
A user need not know the exact type of the iterator for a standard container. That iterator type is
part of the definition of the container and can be referred to by name. When we don’t need to modify an element of the container, const_iteratoris the type we want. Otherwise, we use the plain
iteratortype (§16.3.1).
Adding elements to a listis easy:
void add_entry(Entry& e, list<Entry>: :iterator i)
{
phone_book.push_front(e) ; / / add at beginning
phone_book.push_back(e) ; / / add at end
phone_book.insert(i,e) ; / / add before the element ‘i’ refers to
}
3.7.4 Map [tour2.map]
Writing code to look up a name in a list of (name,number) pairs is really quite tedious. In addition,
a linear search is quite inefficient for all but the shortest lists. Other data structures directly support
insertion, deletion, and searching based on values. In particular, the standard library provides the
maptype (§17.4.1). A mapis a container of pairs of values. For example:
map<string,int> phone_book;
In other contexts, a mapis known as an associative array or a dictionary.
When indexed by a value of its first type (called the key) a mapreturns the corresponding value
of the second type (called the value or the mapped type). For example:
void print_entry(const string& s)
{
if(int i= phone_book[s]) cout<< s<< ´ ´ << i<< ´\n´;
}
If no match was found for the key s, a default value is returned from the phone_book. The default
value for an integer type in a mapis 0. Here, I assume that 0isn’t a valid telephone number.
3.7.5 Standard Containers [tour2.stdcontainer]
A map, a list, and a vectorcan each be used to represent a phone book. However, each has
strengths and weaknesses. For example, subscripting a vectoris cheap and easy. On the other
hand, inserting an element between two elements tends to be expensive. A listhas exactly the
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
56 A Tour of the Standard Library Chapter 3
opposite properties. A mapresembles a listof (key,value) pairs except that it is optimized for finding values based on keys.
The standard library provides some of the most general and useful container types to allow the
programmer to select a container that best serves the needs of an application: _ ________________________________________________________________
_ ________________________________________________________________ Standard Container Summary _ ________________________________________________________________
vector<T>A variable-sized vector (§16.3)
list<T>A doubly-linked list (§17.2.2)
queue<T>A queue (§17.3.2)
stack<T>A stack (§17.3.1)
deque<T>A double-ended queue (§17.2.3)
priority_queue<T>A queue sorted by value (§17.3.3)
set<T>A set (§17.4.3)
multiset<T>A set in which a value can occur many times (§17.4.4)
map<key,val>An associative array (§17.4.1)
_ ________________________________________________________________ multimap<key,val>A map in which a key can occur many times (§17.4.2) 



























The standard containers are presented in §16.2, §16.3, and Chapter 17. The containers are defined
in namespace stdand presented in headers <vector>, <list>, <map>, etc. (§16.2).
The standard containers and their basic operations are designed to be similar from a notational
point of view. Furthermore, the meanings of the operations are equivalent for the various containers. In general, basic operations apply to every kind of container. For example, push_back() can
be used (reasonably efficiently) to add elements to the end of a vectoras well as for a list, and
every container has a size() member function that returns its number of elements.
This notational and semantic uniformity enables programmers to provide new container types
that can be used in a very similar manner to the standard ones. The range-checked vector, Vec
(§3.7.2), is an example of that. Chapter 17 demonstrates how a hash_mapcan be added to the
framework. The uniformity of container interfaces also allows us to specify algorithms independently of individual container types.
3.8 Algorithms [tour2.algorithms]
A data structure, such as a list or a vector, is not very useful on its own. To use one, we need operations for basic access such as adding and removing elements. Furthermore, we rarely just store
objects in a container. We sort them, print them, extract subsets, remove elements, search for
objects, etc. Consequently, the standard library provides the most common algorithms for containers in addition to providing the most common container types. For example, the following sorts a
vectorand places a copy of each unique vectorelement on a list:
void f(vector<Entry>& ve, list<Entry>& le)
{
sort(ve.begin() ,ve.end()) ;
unique_copy(ve.begin() ,ve.end() ,le.begin()) ;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 3.8 Algorithms 57
The standard algorithms are described in Chapter 18. They are expressed in terms of sequences of
elements (§2.7.2). A sequence is represented by a pair of iterators specifying the first element and
the one-beyond-the-last element. In the example, sort() sorts the sequence from ve.begin() to
ve.end() – which just happens to be all the elements of a vector. For writing, you need only to
specify the first element to be written. If more than one element is written, the elements following
that initial element will be overwritten.
If we wanted to add the new elements to the end of a container, we could have written:
void f(vector<Entry>& ve, list<Entry>& le)
{
sort(ve.begin() ,ve.end()) ;
unique_copy(ve.begin() ,ve.end() ,back_inserter(le)) ; / / append to le
}
A back_inserter() adds elements at the end of a container, extending the container to make room
for them (§19.2.4). C programmers will appreciate that the standard containers plus
back_inserter()s eliminate the need to use error-prone, explicit C-style memory management
using realloc() (§16.3.5). Forgetting to use a back_inserter() when appending can lead to
errors. For example:
void f(list<Entry>& ve, vector<Entry>& le)
{
copy(ve.begin() ,ve.end() ,le) ; / / error: le not an iterator
copy(ve.begin() ,ve.end() ,le.end()) ; / / bad: writes beyond the end
copy(ve.begin() ,ve.end() ,le.begin()) ; / / overwrite elements
}
3.8.1 Use of Iterators [tour2.iteruse]
When you first encounter a container, a few iterators referring to useful elements can be obtained;
begin() and end() are the best examples of this. In addition, many algorithms return iterators.
For example, the standard algorithm findlooks for a value in a sequence and returns an iterator to
the element found. Using find, we can write a function that counts the number of occurrences of a
character in a string:
int count(const string& s, char c)
{
string: :const_iterator i= find(s.begin() ,s.end() ,c) ;
int n= 0;
while(i!= s.end()) {
++n;
i= find(i+1,s.end() ,c) ;
}
return n;
}
The findalgorithm returns an iterator to the first occurrence of a value in a sequence or the onepast-the-end iterator. Consider what happens for a simple call of count:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
58 A Tour of the Standard Library Chapter 3
void f()
{
string m= "Mary had a little lamb";
int a_count= count(m,´a´) ;
}
The first call to find() finds the ´a´ in Mary. Thus, the iterator points to that character and not to
s.end(), so we enter the loop. In the loop, we start the search at i+1; that is, we start one past
where we found the ´a´. We then loop finding the other three ´a´s. That done, find() reaches
the end and returns s.end() so that the condition i!=s.end() fails and we exit the loop.
That call of count() could be graphically represented like this:
M a r y h a d a l i t t l e l a m b . . . . ..
.
. .. . . . .
.
.
.
The arrows indicate the initial, intermediate, and final values of the iterator i.
Naturally, the findalgorithm will work equivalently on every standard container. Consequently, we could generalize the count() function in the same way:
template<class C, class T> int count(const C& v, T val)
{
typename C: :const_iterator i= find(v.begin() ,v.end() ,val) ; / / "typename;" see §C.13.5
int n= 0;
while(i!= v.end()) {
++n;
++i; / / skip past the element we just found
i= find(i,v.end() ,val) ;
}
return n;
}
This works, so we can say:
void f(list<complex>& lc, vector<string>& vc, string s)
{
int i1= count(lc,complex(1,3)) ;
int i2= count(vc,"Chrysippus") ;
int i3= count(s,´x´) ;
}
However, we don’t have to define a counttemplate. Counting occurrences of an element is so generally useful that the standard library provides that algorithm. To be fully general, the standard
library counttakes a sequence as its argument, rather than a container, so we would say:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 3.8.1 Use of Iterators 59
void f(list<complex>& lc, vector<string>& vs, string s)
{
int i1= count(lc.begin() ,lc.end() ,complex(1,3)) ;
int i2= count(vs.begin() ,vs.end() ,"Diogenes") ;
int i3= count(s.begin() ,s.end() ,´x´) ;
}
The use of a sequence allows us to use countfor a built-in array and also to count parts of a container. For example:
void g(char cs[] , int sz)
{
int i1= count(&cs[0] ,&cs[sz] ,´z´) ; / / ’z’s in array
int i2= count(&cs[0] ,&cs[sz/2] ,´z´) ; / / ’z’s in first half of array
}
3.8.2 Iterator Types [tour2.iter]
What are iterators really? Any particular iterator is an object of some type. There are, however,
many different iterator types because an iterator needs to hold the information necessary for doing
its job for a particular container type. These iterator types can be as different as the containers and
the specialized needs they serve. For example, a vector’s iterator is most likely an ordinary pointer
because a pointer is quite a reasonable way of referring to an element of a vector:
vector: P i e t H e i n
iterator: p
Alternatively, a vectoriterator could be implemented as a pointer to the vectorplus an index:
vector: P i e t H e i n
iterator: (start == p, position == 3)
. . . . . . . . . . . . .
Using such an iterator would allow range checking (§19.3).
A list iterator must be something more complicated than a simple pointer to an element because
an element of a list in general does not know where the next element of that list is. Thus, a list iterator might be a pointer to a link:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
60 A Tour of the Standard Library Chapter 3
list: link link link link ...
iterator: p
elements: P i e t
What is common for all iterators is their semantics and the naming of their operations. For example, applying ++ to any iterator yields an iterator that refers to the next element. Similarly, * yields
the element to which the iterator refers. In fact, any object that obeys a few simple rules like these
is an iterator (§19.2.1). Furthermore, users rarely need to know the type of a specific iterator; each
container ‘‘knows’’ its iterator types and makes them available under the conventional names iteratorand const_iterator. For example, list<Entry>: :iteratoris the general iterator type for
list<Entry>. I rarely have to worry about the details of how that type is defined.
3.8.3 Iterators and I/O [tour2.ioiterators]
Iterators are a general and useful concept for dealing with sequences of elements in containers.
However, containers are not the only place where we find sequences of elements. For example, an
input stream produces a sequence of values and we write a sequence of values to an output stream.
Consequently, the notion of iterators can be usefully applied to input and output.
To make an ostream_iterator, we need to specify which stream will be used and the type of
objects written to it. For example, we can define an iterator that refers to the standard output
stream, cout:
ostream_iterator<string> oo(cout) ;
The effect of assigning to *oois to write the assigned value to cout. For example:
int main()
{
*oo= "Hello, "; / / meaning cout << "Hello, "
++oo;
*oo= "world!\n"; / / meaning cout << "world!\n"
}
This is yet another way of writing the canonical message to standard output. The ++oois done to
mimic writing into an array through a pointer. This way wouldn’t be my first choice for that simple
task, but the utility of treating output as a write-only container will soon be obvious – if it isn’t
already.
Similarly, an istream_iteratoris something that allows us to treat an input stream as a readonly container. Again, we must specify the stream to be used and the type of values expected:
istream_iterator<string> ii(cin) ;
Because input iterators invariably appear in pairs representing a sequence, we must provide an
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 3.8.3 Iterators and I/O 61
istream_iteratorto indicate the end of input. This is the default istream_iterator:
istream_iterator<string> eos;
We could now read Hello, world! from input and write it out again like this:
int main()
{
string s1= *ii;
++ii;
string s2= *ii;
cout<< s1<< ´ ´ << s2<< ´\n´;
}
Actually, istream_iterators and ostream_iterators are not meant to be used directly. Instead, they
are typically provided as arguments to algorithms. For example, we can write a simple program to
read a file, sort the words read, eliminate duplicates, and write the result to another file:
int main()
{
string from, to;
cin>> from>> to; / / get source and target file names
ifstream is(from.c_str()) ; / / input stream (c_str(); see §3.5)
istream_iterator<string> ii(is) ; / / input iterator for stream
istream_iterator<string> eos; / / input sentinel
vector<string> b(ii,eos) ; / / b is a vector initialized from input
sort(b.begin() ,b.end()) ; / / sort the buffer
ofstream os(to.c_str()) ; / / output stream
ostream_iterator<string> oo(os,"\n") ; / / output iterator for stream
unique_copy(b.begin() ,b.end() ,oo) ; / / copy buffer to output,
/ / discard replicated values
return!is.eof() && !os; / / return error state (§3.2, §21.3.3)
}
An ifstreamis an istreamthat can be attached to a file, and an ofstreamis an ostreamthat can be
attached to a file. The ostream_iterator’s second argument is used to delimit output values.
3.8.4 Traversals and Predicates [tour2.traverse]
Iterators allow us to write loops to iterate through a sequence. However, writing loops can be
tedious, so the standard library provides ways for a function to be called for each element of a
sequence.
Consider writing a program that reads words from input and records the frequency of their
occurrence. The obvious representation of the strings and their associated frequencies is a map:
map<string,int> histogram;
The obvious action to be taken for each string to record its frequency is:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
62 A Tour of the Standard Library Chapter 3
void record(const string& s)
{
histogram[s]++; / / record frequency of ‘‘s’’
}
Once the input has been read, we would like to output the data we have gathered. The mapconsists
of a sequence of (string,int) pairs. Consequently, we would like to call
void print(const pair<const string,int>& r)
{
cout<< r.first<< ´ ´ << r.second<< ´\n´;
}
for each element in the map (the first element of a pairis called first, and the second element is
called second). The first element of the pairis a const stringrather than a plain stringbecause all
mapkeys are constants.
Thus, the main program becomes:
int main()
{
istream_iterator<string> ii(cin) ;
istream_iterator<string> eos;
for_each(ii,eos,record) ;
for_each(histogram.begin() ,histogram.end() ,print) ;
}
Note that we don’t need to sort the mapto get the output in order. A mapkeeps its elements
ordered so that an iteration traverses the mapin (increasing) order.
Many programming tasks involve looking for something in a container rather than simply doing
something to every element. For example, the findalgorithm (§18.5.2) provides a convenient way
of looking for a specific value. A more general variant of this idea looks for an element that fulfills
a specific requirement. For example, we might want to search a mapfor the first value larger than
42. A mapis a sequence of (key,value) pairs, so we search that list for a pair<const string,int>
where the intis greater than 42:
bool gt_42(const pair<const string,int>& r)
{
return r.second>42;
}
void f(map<string,int>& m)
{
typedef map<string,int>: :const_iterator MI;
MI i= find_if(m.begin() ,m.end() ,gt_42) ;
/ / ...
}
Alternatively, we could count the number of words with a frequency higher than 42:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 3.8.4 Traversals and Predicates 63
void g(const map<string,int>& m)
{
int c42= count_if(m.begin() ,m.end() ,gt_42) ;
/ / ...
}
A function, such as gt_42(), that is used to control the algorithm is called a predicate. A predicate
is called for each element and returns a Boolean value, which the algorithm uses to perform its
intended action. For example, find_if() searches until its predicate returns trueto indicate that an
element of interest has been found. Similarly, count_if() counts the number of times its predicate
is true.
The standard library provides a few useful predicates and some templates that are useful for creating more (§18.4.2).
3.8.5 Algorithms Using Member Functions [tour2.memp]
Many algorithms apply a function to elements of a sequence. For example, in §3.8.4
for_each(ii,eos,record) ;
calls record() to read strings from input.
Often, we deal with containers of pointers and we really would like to call a member function of
the object pointed to, rather than a global function on the pointer. For example, we might want to
call the member function Shape: :draw() for each element of a list<Shape*>. To handle this
specific example, we simply write a nonmember function that invokes the member function. For
example:
void draw(Shape* p)
{
p->draw() ;
}
void f(list<Shape*>& sh)
{
for_each(sh.begin() ,sh.end() ,draw) ;
}
By generalizing this technique, we can write the example like this:
void g(list<Shape*>& sh)
{
for_each(sh.begin() ,sh.end() ,mem_fun(&Shape: :draw)) ;
}
The standard library mem_fun() template (§18.4.4.2) takes a pointer to a member function (§15.5)
as its argument and produces something that can be called for a pointer to the member’s class. The
result of mem_fun(&Shape: :draw) takes a Shape* argument and returns whatever
Shape: :draw() returns.
The mem_fun() mechanism is important because it allows the standard algorithms to be used
for containers of polymorphic objects.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
64 A Tour of the Standard Library Chapter 3
3.8.6 Standard Library Algorithms [tour2.algolist]
What is an algorithm? A general definition of an algorithm is ‘‘a finite set of rules which gives a
sequence of operations for solving a specific set of problems [and] has five important features:
Finiteness ... Definiteness ... Input ... Output ... Effectiveness’’ [Knuth,1968,§1.1]. In the context of
the C++ standard library, an algorithm is a set of templates operating on sequences of elements.
The standard library provides dozens of algorithms. The algorithms are defined in namespace
stdand presented in the <algorithm> header. Here are a few I have found particularly useful: _____________________________________________________________________
_____________________________________________________________________ Selected Standard Algorithms _____________________________________________________________________
for_each()Invoke function for each element (§18.5.1)
find()Find first occurrence of arguments (§18.5.2)
find_if()Find first match of predicate (§18.5.2)
count()Count occurrences of element (§18.5.3)
count_if()Count matches of predicate (§18.5.3)
replace()Replace element with new value (§18.6.4)
replace_if()Replace element that matches predicate with new value (§18.6.4)
copy()Copy elements (§18.6.1)
unique_copy()Copy elements that are not duplicates (§18.6.1)
sort()Sort elements (§18.7.1)
equal_range()Find all elements with equivalent values (§18.7.2)
_____________________________________________________________________ merge()Merge sorted sequences (§18.7.3) 































These algorithms, and many more (see Chapter 18), can be applied to elements of containers,
strings, and built-in arrays.
3.9 Math [tour2.math]
Like C, C++ wasn’t designed primarily with numerical computation in mind. However, a lot of
numerical work is done in C++, and the standard library reflects that.
3.9.1 Complex Numbers [tour2.complex]
The standard library supports a family of complex number types along the lines of the complex
class described in §2.5.2. To support complex numbers where the scalars are single-precision,
floating-point numbers (floats), double precision numbers (doubles), etc., the standard library complexis a template:
template<class scalar> class complex{
public:
complex(scalar re, scalar im) ;
/ / ...
};
The usual arithmetic operations and the most common mathematical functions are supported for
complex numbers. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 3.9.1 Complex Numbers 65
/ / standard exponentiation function from <complex>:
template<class C> complex<C> pow(const complex<C>&, int) ;
void f(complex<float> fl, complex<double> db)
{
complex<long double> ld= fl+sqrt(db) ;
db+= fl*3;
fl= pow(1/fl,2) ;
/ / ...
}
For more details, see §22.5.
3.9.2 Vector Arithmetic [tour2.valarray]
The vectordescribed in §3.7.1 was designed to be a general mechanism for holding values, to be
flexible, and to fit into the architecture of containers, iterators, and algorithms. However, it does
not support mathematical vector operations. Adding such operations to vectorwould be easy, but
its generality and flexibility precludes optimizations that are often considered essential for serious
numerical work. Consequently, the standard library provides a vector, called valarray, that is less
general and more amenable to optimization for numerical computation:
template<class T> class valarray{
/ / ...
T& operator[](size_t) ;
/ / ...
};
The type size_tis the unsigned integer type that the implementation uses for array indices.
The usual arithmetic operations and the most common mathematical functions are supported for
valarrays. For example:
/ / standard absolute value function from <valarray>:
template<class T> valarray<T> abs(const valarray<T>&) ;
void f(valarray<double>& a1, valarray<double>& a2)
{
valarray<double> a= a1*3.14+a2/a1;
a2+= a1*3.14;
a= abs(a) ;
double d= a2[7] ;
/ / ...
}
For more details, see §22.4.
3.9.3 Basic Numeric Support [tour2.basicnum]
Naturally, the standard library contains the most common mathematical functions – such as log(),
pow(), and cos() – for floating-point types; see §22.3. In addition, classes that describe the
properties of built-in types – such as the maximum exponent of a float– are provided; see §22.2.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
66 A Tour of the Standard Library Chapter 3
3.10 Standard Library Facilities [tour2.post]
The facilities provided by the standard library can be classified like this:
[1] Basic run-time language support (e.g., for allocation and run-time type information); see
§16.1.3.
[2] The C standard library (with very minor modifications to minimize violations of the type
system); see §16.1.2.
[3] Strings and I/O streams (with support for international character sets and localization); see
Chapter 20 and Chapter 21.
[4] A framework of containers (such as vector, list, and map) and algorithms using containers
(such as general traversals, sorts, and merges); see Chapter 16, Chapter 17, Chapter 18, and
Chapter 19.
[5] Support for numerical computation (complex numbers plus vectors with arithmetic operations, BLAS-like and generalized slices, and semantics designed to ease optimization); see
Chapter 22.
The main criterion for including a class in the library was that it would somehow be used by almost
every C++ programmer (both novices and experts), that it could be provided in a general form that
did not add significant overhead compared to a simpler version of the same facility, and that simple
uses should be easy to learn. Essentially, the C++ standard library provides the most common fundamental data structures together with the fundamental algorithms used on them.
Every algorithm works with every container without the use of conversions. This framework,
conventionally called the STL [Stepanov,1994], is extensible in the sense that users can easily provide containers and algorithms in addition to the ones provided as part of the standard and have
these work directly with the standard containers and algorithms.
3.11 Advice [tour2.advice]
[1] Don’t reinvent the wheel; use libraries.
[2] Don’t believe in magic; understand what your libraries do, how they do it, and at what cost
they do it.
[3] When you have a choice, prefer the standard library to other libraries.
[4] Do not think that the standard library is ideal for everything.
[5] Remember to #includethe headers for the facilities you use; §3.3.
[6] Remember that standard library facilities are defined in namespace std; §3.3.
[7] Use stringrather than char*; §3.5, §3.6.
[8] If in doubt use a range-checked vector (such as Vec); §3.7.2.
[9] Prefer vector<T>, list<T>, and map<key,value> to T[]; §3.7.1, §3.7.3, §3.7.4.
[10] When adding elements to a container, use push_back() or back_inserter(); §3.7.3, §3.8.
[11] Use push_back() on a vectorrather than realloc() on an array; §3.8.
[12] Catch common exceptions in main(); §3.7.2.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Part I
Basic Facilities
This part describes C++’s built-in types and the basic facilities for constructing programs out of them. The C subset of C++ is presented together with C++’s additional
support for traditional styles of programming. It also discusses the basic facilities for
composing a C++ program out of logical and physical parts.
Chapters
4 Types and Declarations
5 Pointers, Arrays, and Structures
6 Expressions and Statements
7 Functions
8 Namespaces and Exceptions
9 Source Files and Programs
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
68 Basic Facilities Part I
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
4 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
Types and Declarations
Accept nothing short of perfection!
– anon
Perfection is achieved
only on the point of collapse.
– C. N. Parkinson
Types — fundamental types — Booleans — characters — character literals — integers
— integer literals — floating-point types — floating-point literals — sizes — void—
enumerations — declarations — names — scope — initialization — objects — typedefs
— advice — exercises.
4.1 Types [dcl.type]
Consider
x= y+f(2) ;
For this to make sense in a C++ program, the names x, y, and fmust be suitably declared. That is,
the programmer must specify that entities named x, y, and fexist and that they are of types for
which = (assignment), + (addition), and () (function call), respectively, are meaningful.
Every name (identifier) in a C++ program has a type associated with it. This type determines
what operations can be applied to the name (that is, to the entity referred to by the name) and how
such operations are interpreted. For example, the declarations
float x; / / x is a floating-point variable
int y= 7; / / y is an integer variable with the initial value 7
float f(int) ; / / f is a function taking an argument of type int and returning a floating-point number
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
70 Types and Declarations Chapter 4
would make the example meaningful. Because yis declared to be an int, it can be assigned to, used
in arithmetic expressions, etc. On the other hand, fis declared to be a function that takes an intas
its argument, so it can be called given a suitable argument.
This chapter presents fundamental types (§4.1.1) and declarations (§4.9). Its examples just
demonstrate language features; they are not intended to do anything useful. More extensive and
realistic examples are saved for later chapters after more of C++ has been described. This chapter
simply provides the most basic elements from which C++ programs are constructed. You must
know these elements, plus the terminology and simple syntax that goes with them, in order to complete a real project in C++ and especially to read code written by others. However, a thorough
understanding of every detail mentioned in this chapter is not a requirement for understanding the
following chapters. Consequently, you may prefer to skim through this chapter, observing the
major concepts, and return later as the need for understanding of more details arises.
4.1.1 Fundamental Types [dcl.fundamental]
C++ has a set of fundamental types corresponding to the most common basic storage units of a
computer and the most common ways of using them to hold data:
§4.2 A Boolean type (bool)
§4.3 Character types (such as char)
§4.4 Integer types (such as int)
§4.5 Floating-point types (such as double)
In addition, a user can define
§4.8 Enumeration types for representing specific sets of values (enum)
There also is
§4.7 A type, void, used to signify the absence of information
From these types, we can construct other types:
§5.1 Pointer types (such as int*)
§5.2 Array types (such as char[])
§5.5 Reference types (such as double&)
§5.7 Data structures and classes (Chapter 10)
The Boolean, character, and integer types are collectively called integral types. The integral and
floating-point types are collectively called arithmetic types. Enumerations and classes (Chapter 10)
are called user-defined types because they must be defined by users rather than being available for
use without previous declaration, the way fundamental types are. In contrast, other types are called
built-in types.
The integral and floating-point types are provided in a variety of sizes to give the programmer a
choice of the amount of storage consumed, the precision, and the range available for computations
(§4.6). The assumption is that a computer provides bytes for holding characters, words for holding
and computing integer values, some entity most suitable for floating-point computation, and
addresses for referring to those entities. The C++ fundamental types together with pointers and
arrays present these machine-level notions to the programmer in a reasonably implementationindependent manner.
For most applications, one could simply use boolfor logical values, charfor characters, intfor
integer values, and doublefor floating-point values. The remaining fundamental types are
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 4.1.1 Fundamental Types 71
variations for optimizations and special needs that are best ignored until such needs arise. They
must be known, however, to read old C and C++ code.
4.2 Booleans [dcl.bool]
A Boolean, bool, can have one of the two values trueor false. A Boolean is used to express the
results of logical operations. For example:
void f(int a, int b)
{
bool b1= a==b; / / = is assignment, == is equality
/ / ...
}
If aand bhave the same value, b1becomes true; otherwise, b1becomes false.
A common use of boolis as the type of the result of a function that tests some condition (a
predicate). For example:
bool is_open(File*) ;
bool greater(int a, int b) { return a>b; }
By definition, truehas the value 1when converted to an integer and falsehas the value 0. Conversely, integers can be implicitly converted to boolvalues: nonzero integers convert to trueand 0
converts to false. For example:
bool b= 7; / / bool(7) is true, so b becomes true
int i= true; / / int(true) is 1, so i becomes 1
In arithmetic and logical expressions, bools are converted to ints; integer arithmetic and logical
operations are performed on the converted values. If the result is converted back to bool, a 0is
converted to falseand a nonzero value is converted to true.
void g()
{
bool a= true;
bool b= true;
bool x= a+b; / / a+b is 2, so x becomes true
bool y= a|b; / / ab is 1, so y becomes true
}
A pointer can be implicitly converted to a bool(§C.6.2.5). A nonzero pointer converts to true;
zero-valued pointers convert to false.
4.3 Character Types [dcl.char]
A variable of type charcan hold a character of the implementation’s character set. For example:
char ch= ´a´;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
72 Types and Declarations Chapter 4
Almost universally, a charhas 8 bits so that it can hold one of 256 different values. Typically, the
character set is a variant of ISO-646, for example ASCII, thus providing the characters appearing
on your keyboard. Many problems arise from the fact that this set of characters is only partially
standardized (§C.3).
Serious variations occur between character sets supporting different natural languages and also
between different character sets supporting the same natural language in different ways. However,
here we are interested only in how such differences affect the rules of C++. The larger and more
interesting issue of how to program in a multi-lingual, multi-character-set environment is beyond
the scope of this book, although it is alluded to in several places (§20.2, §21.7, §C.3.3).
It is safe to assume that the implementation character set includes the decimal digits, the 26
alphabetic characters of English, and some of the basic punctuation characters. It is not safe to
assume that there are no more than 127 characters in an 8-bit character set (e.g., some sets provide
255 characters), that there are no more alphabetic characters than English provides (most European
languages provide more), that the alphabetic characters are contiguous (EBCDIC leaves a gap
between ´i´ and ´j´), or that every character used to write C++ is available (e.g., some national
character sets do not provide { } [ ] | \; §C.3.1). Whenever possible, we should avoid making
assumptions about the representation of objects. This general rule applies even to characters.
Each character constant has an integer value. For example, the value of ´b´ is 98in the ASCII
character set. Here is a small program that will tell you the integer value of any character you care
to input:
#include<iostream>
int main()
{
char c;
std: :cin>> c;
std: :cout<< "the value of´" << c<< "´ is" << int(c) << ´\n´;
}
The notation int(c) gives the integer value for a character c. The possibility of converting a char
to an integer raises the question: is a charsigned or unsigned? The 256 values represented by an
8-bit byte can be interpreted as the values 0to 255or as the values -127to 127. Unfortunately,
which choice is made for a plain charis implementation-defined (§C.1, §C.3.4). C++ provides two
types for which the answer is definite; signed char, which can hold at least the values -127to 127,
and unsigned char, which can hold at least the values 0to 255. Fortunately, the difference matters
only for values outside the 0to 127range, and the most common characters are within that range.
Values outside that range stored in a plain charcan lead to subtle portability problems. See
§C.3.4 if you need to use more than one type of charor if you store integers in charvariables.
A type wchar_tis provided to hold characters of a larger character set such as Unicode. It is a
distinct type. The size of wchar_tis implementation-defined and large enough to hold the largest
character set supported by the implementation’s locale (see §21.7, §C.3.3). The strange name is a
leftover from C. In C, wchar_tis a typedef(§4.9.7) rather than a built-in type. The suffix _twas
added to distinguish standard typedefs.
Note that the character types are integral types (§4.1.1) so that arithmetic and logical operations
(§6.2) apply.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 4.3.1 Character Literals 73
4.3.1 Character Literals [dcl.char.lit]
A character literal, often called a character constant, is a character enclosed in single quotes, for
example, ´a´ and ´0´. The type of a character literal is char. Such character literals are really
symbolic constants for the integer value of the characters in the character set of the machine on
which the C++ program is to run. For example, if you are running on a machine using the ASCII
character set, the value of ´0´ is 48. The use of character literals rather than decimal notation
makes programs more portable. A few characters also have standard names that use the backslash \
as an escape character. For example, \nis a newline and \tis a horizontal tab. See §C.3.2 for
details about escape characters.
Wide character literals are of the form L´ab´, where the number of characters between the
quotes and their meanings is implementation-defined to match the wchar_ttype. A wide character
literal has type wchar_t.
4.4 Integer Types [dcl.int]
Like char, each integer type comes in three forms: ‘‘plain’’ int, signed int, and unsigned int. In
addition, integers come in three sizes: short int, ‘‘plain’’ int, and long int. A long intcan be
referred to as plain long. Similarly, shortis a synonym for short int, unsignedfor unsigned int,
and signedfor signed int.
The unsignedinteger types are ideal for uses that treat storage as a bit array. Using an
unsignedinstead of an intto gain one more bit to represent positive integers is almost never a good
idea. Attempts to ensure that some values are positive by declaring variables unsignedwill typically be defeated by the implicit conversion rules (§C.6.1, §C.6.2.1).
Unlike plain chars, plain ints are always signed. The signed inttypes are simply more explicit
synonyms for their plain intcounterparts.
4.4.1 Integer Literals [dcl.int.lit]
Integer literals come in four guises: decimal, octal, hexadecimal, and character literals. Decimal literals are the most commonly used and look as you would expect them to:
0 1234 976 12345678901234567890
The compiler ought to warn about literals that are too long to represent.
A literal starting with zero followed by x(0x) is a hexadecimal (base 16) number. A literal
starting with zero followed by a digit is an octal (base 8) number. For example:
decimal: 0 2 63 83
octal: 00 02 077 0123
hexadecimal: 0x0 0x2 0x3f 0x53
The letters a, b, c, d, e, and f, or their uppercase equivalents, are used to represent 10, 11, 12, 13,
14, and 15, respectively. Octal and hexadecimal notations are most useful for expressing bit patterns. Using these notations to express genuine numbers can lead to surprises. For example, on a
machine on which an intis represented as a two’s complement 16-bit integer, 0xffffis the negative
decimal number -1. Had more bits been used to represent an integer, it would have been 65535.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
74 Types and Declarations Chapter 4
The suffix Ucan be used to write explicitly unsignedliterals. Similarly, the suffix Lcan be
used to write explicitly longliterals. For example, 3is an int, 3U is an unsigned int, and 3Lis a
long int. If no suffix is provided, the compiler gives an integer literal a suitable type based on its
value and the implementation’s integer sizes (§C.4).
It is a good idea to limit the use of nonobvious constants to a few well-commented const(§5.4)
or enumerator (§4.8) initializers.
4.5 Floating-Point Types [dcl.float]
The floating-point types represent floating-point numbers. Like integers, floating-point types come
in three sizes: float(single-precision), double(double-precision), and long double(extendedprecision).
The exact meaning of single-, double-, and extended-precision is implementation-defined.
Choosing the right precision for a problem where the choice matters requires significant understanding of floating-point computation. If you don’t have that understanding, get advice, take the
time to learn, or use doubleand hope for the best.
4.5.1 Floating-Point Literals [dcl.fp.lit]
By default, a floating-point literal is of type double. Again, a compiler ought to warn about
floating-point literals that are too large to be represented. Here are some floating-point literals:
1.23.23 0.23 1. 1.0 1.2e10 1.23e-15
Note that a space cannot occur in the middle of a floating-point literal. For example, 65.43 e-21
is not a floating-point literal but rather four separate lexical tokens (causing a syntax error):
65.43 e- 21
If you want a floating-point literal of type float, you can define one using the suffix for F:
3.14159265f 2.0f 2.997925F
4.6 Sizes [dcl.size]
Some of the aspects of C++’s fundamental types, such as the size of an int, are implementationdefined (§C.2). I point out these dependencies and often recommend avoiding them or taking steps
to minimize their impact. Why should you bother? People who program on a variety of systems or
use a variety of compilers care a lot because if they don’t, they are forced to waste time finding and
fixing obscure bugs. People who claim they don’t care about portability usually do so because they
use only a single system and feel they can afford the attitude that ‘‘the language is what my compiler implements.’’ This is a narrow and shortsighted view. If your program is a success, it is
likely to be ported, so someone will have to find and fix problems related to implementationdependent features. In addition, programs often need to be compiled with other compilers for the
same system, and even a future release of your favorite compiler may do some things differently
from the current one. It is far easier to know and limit the impact of implementation dependencies
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 4.6 Sizes 75
when a program is written than to try to untangle the mess afterwards.
It is relatively easy to limit the impact of implementation-dependent language features. Limiting the impact of system-dependent library facilities is far harder. Using standard library facilities
wherever feasible is one approach.
The reason for providing more than one integer type, more than one unsigned type, and more
than one floating-point type is to allow the programmer to take advantage of hardware characteristics. On many machines, there are significant differences in memory requirements, memory access
times, and computation speed between the different varieties of fundamental types. If you know a
machine, it is usually easy to choose, for example, the appropriate integer type for a particular variable. Writing truly portable low-level code is harder.
Sizes of C++ objects are expressed in terms of multiples of the size of a char, so by definition
the size of a charis 1. The size of an object or type can be obtained using the sizeofoperator
(§6.2). This is what is guaranteed about sizes of fundamental types:
1 ≡ sizeof(char) ≤ sizeof(short) ≤ sizeof(int) ≤ sizeof(long)
1 ≤ sizeof(bool) ≤ sizeof(long)
sizeof(char) ≤ sizeof(wchar_t) ≤ sizeof(long)
sizeof(float) ≤ sizeof(double) ≤ sizeof(long double)
sizeof(N) ≡ sizeof(signed N) ≡ sizeof(unsigned N)
where Ncan be char, short int, int, or long int. In addition, it is guaranteed that a charhas at least
8 bits, a shortat least 16 bits, and a longat least 32 bits. A charcan hold a character of the
machine’s character set.
Here is a graphical representation of a plausible set of fundamental types and a sample string:
’a’
1
756
100000000
&c1
1234567e34
Hello, world!\0
char:
bool:
short:
int:
int*:
double:
char[14]:
On the same scale (.2 inch to a byte), a megabyte of memory would stretch about three miles (five
km) to the right.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
76 Types and Declarations Chapter 4
The chartype is supposed to be chosen by the implementation to be the most suitable type for
holding and manipulating characters on a given computer; it is typically an 8-bit byte. Similarly,
the inttype is supposed to be chosen to be the most suitable for holding and manipulating integers
on a given computer; it is typically a 4-byte (32-bit) word. It is unwise to assume more. For example, there are machines with 32 bit chars.
When needed, implementation-dependent aspects about an implementation can be found in
<limits> (§22.2). For example:
#include<limits>
int main()
{
cout<< "largest float== " << numeric_limits<float>: :max()
<< ", char is signed== " << numeric_limits<char>: :is_signed<< ´\n´;
}
The fundamental types can be mixed freely in assignments and expressions. Wherever possible,
values are converted so as not to lose information (§C.6).
If a value vcan be represented exactly in a variable of type T, a conversion of vto Tis valuepreserving and no problem. The cases where conversions are not value-preserving are best avoided
(§C.6.2.6).
You need to understand implicit conversion in some detail in order to complete a major project
and especially to understand real code written by others. However, such understanding is not
required to read the following chapters.
4.7 Void [dcl.void]
The type voidis syntactically a fundamental type. It can, however, be used only as part of a more
complicated type; there are no objects of type void. It is used either to specify that a function does
not return a value or as the base type for pointers to objects of unknown type. For example:
void x; / / error: there are no void objects
void f() ; / / function f does not return a value (§7.3)
void* pv; / / pointer to object of unknown type (§5.6)
When declaring a function, you must specify the type of the value returned. Logically, you would
expect to be able to indicate that a function didn’t return a value by omitting the return type. However, that would make the grammar (Appendix A) less regular and clash with C usage. Consequently, voidis used as a ‘‘pseudo return type’’ to indicate that a function doesn’t return a value.
4.8 Enumerations [dcl.enum]
An enumeration is a type that can hold a set of values specified by the user. Once defined, an enumeration is used very much like an integer type.
Named integer constants can be defined as members of an enumeration. For example,
enum{ ASM, AUTO, BREAK};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 4.8 Enumerations 77
defines three integer constants, called enumerators, and assigns values to them. By default, enumerator values are assigned increasing from 0, so ASM==0, AUTO==1, and BREAK==2. An enumeration can be named. For example:
enum keyword{ ASM, AUTO, BREAK};
Each enumeration is a distinct type. The type of an enumerator is its enumeration. For example,
AUTOis of type keyword.
Declaring a variable keywordinstead of plain intcan give both the user and the compiler a hint
as to the intended use. For example:
void f(keyword key)
{
switch(key) {
case ASM:
/ / do something
break;
case BREAK:
/ / do something
break;
}
}
A compiler can issue a warning because only two out of three keywordvalues are handled.
An enumerator can be initialized by a constant-expression (§C.5) of integral type (§4.1.1). The
range of an enumeration holds all the enumeration’s enumerator values rounded up to the nearest
larger binary power minus 1. The range goes down to 0if the smallest enumerator is non-negative
and to the nearest lesser negative binary power if the smallest enumerator is negative. This defines
the smallest bit-field capable of holding the enumerator values. For example:
enum e1{ dark, light}; / / range 0:1
enum e2{ a= 3, b= 9}; / / range 0:15
enum e3{ min= -10, max= 1000000}; / / range -1048576:1048575
A value of integral type may be explicitly converted to an enumeration type. The result of such a
conversion is undefined unless the value is within the range of the enumeration. For example:
enum flag{ x=1, y=2, z=4, e=8}; / / range 0:15
flag f1= 5; / / type error: 5 is not of type flag
flag f2= flag(5) ; / / ok: flag(5) is of type flag and within the range of flag
flag f3= flag(z|e) ; / / ok: flag(12) is of type flag and within the range of flag
flag f4= flag(99) ; / / undefined: 99 is not within the range of flag
The last assignment shows why there is no implicit conversion from an integer to an enumeration;
most integer values do not have a representation in a particular enumeration.
The notion of a range of values for an enumeration differs from the enumeration notion in the
Pascal family of languages. However, bit-manipulation examples that require values outside the set
of enumerators to be well-defined have a long history in C and C++.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
78 Types and Declarations Chapter 4
The sizeofan enumeration is the sizeofsome integral type that can hold its range and not larger
than sizeof(int), unless an enumerator cannot be represented as an intor as an unsigned int. For
example, sizeof(e1) could be 1or maybe 4but not 8on a machine where sizeof(int)==4.
By default, enumerations are converted to integers for arithmetic operations (§6.2). An enumeration is a user-defined type, so users can define their own operations, such as ++ and << for an enumeration (§11.2.3).
4.9 Declarations [dcl.dcl]
Before a name (identifier) can be used in a C++ program, it must be declared. That is, its type must
be specified to inform the compiler to what kind of entity the name refers. Here are some examples
illustrating the diversity of declarations:
char ch;
string s;
int count= 1;
const double pi= 3.1415926535897932385;
extern int error_number;
char* name= "Njal";
char* season[] = { "spring", "summer", "fall", "winter" };
struct Date{ int d, m, y; };
int day(Date* p) { return p->d; }
double sqrt(double) ;
template<class T> T abs(T a) { return a<0? -a: a; }
typedef complex<short> Point;
struct User;
enum Beer{ Carlsberg, Tuborg, Thor};
namespace NS{ int a; }
As can be seen from these examples, a declaration can do more than simply associate a type with a
name. Most of these declarations are also definitions; that is, they also define an entity for the
name to which they refer. For ch, that entity is the appropriate amount of memory to be used as a
variable – that memory will be allocated. For day, it is the specified function. For the constant pi,
it is the value 3.1415926535897932385. For Date, that entity is a new type. For Point, it is the
type complex<short> so that Pointbecomes a synonym for complex<short>. Of the declarations
above, only
double sqrt(double) ;
extern int error_number;
struct User;
are not also definitions; that is, the entity they refer to must be defined elsewhere. The code (body)
for the function sqrtmust be specified by some other declaration, the memory for the intvariable
error_numbermust be allocated by some other declaration of error_number, and some other
declaration of the type Usermust define what that type looks like. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 4.9 Declarations 79
double sqrt(double d) { /* ... */ }
int error_number= 1;
struct User{ /* ... */ };
There must always be exactly one definition for each name in a C++ program (for the effects of
#include, see §9.2.3). However, there can be many declarations. All declarations of an entity must
agree on the type of the entity referred to. So, this fragment has two errors:
int count;
int count; / / error: redefinition
extern int error_number;
extern short error_number; / / error: type mismatch
and this has none (for the use of externsee §9.2):
extern int error_number;
extern int error_number;
Some definitions specify a ‘‘value’’ for the entities they define. For example:
struct Date{ int d, m, y; };
typedef complex<short> Point;
int day(Date* p) { return p->d; }
const double pi= 3.1415926535897932385;
For types, templates, functions, and constants, the ‘‘value’’ is permanent. For nonconstant data
types, the initial value may be changed later. For example:
void f()
{
int count= 1;
char* name= "Bjarne";
/ / ...
count= 2;
name= "Marian";
}
Of the definitions, only
char ch;
string s;
do not specify values. See §4.9.5 and §10.4.2 for explanations of how and when a variable is
assigned a default value. Any declaration that specifies a value is a definition.
4.9.1 The Structure of a Declaration [dcl.parts]
A declaration consists of four parts: an optional ‘‘specifier,’’ a base type, a declarator, and an
optional initializer. Except for function and namespace definitions, a declaration is terminated by a
semicolon. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
80 Types and Declarations Chapter 4
char* kings[] = { "Antigonus", "Seleucus", "Ptolemy" };
Here, the base type is char, the declarator is *kings[], and the initializer is ={...}.
A specifier is an initial keyword, such as virtual(§2.5.5, §12.2.6) and extern(§9.2), that specifies some non-type attribute of what is being declared.
A declarator is composed of a name and optionally some declarator operators. The most common declarator operators are (§A.7.1):
* pointer prefix
*const constant pointer prefix
& reference prefix
[] array postfix
() function postfix
Their use would be simple if they were all either prefix or postfix. However, *, [], and () were
designed to mirror their use in expressions (§6.2). Thus, * is prefix and [] and () are postfix.
The postfix declarator operators bind tighter than the prefix ones. Consequently, *kings[] is a
vector of pointers to something, and we have to use parentheses to express types such as ‘‘pointer
to function;’’ see examples in §5.1. For full details, see the grammar in Appendix A.
Note that the type cannot be left out of a declaration. For example:
const c= 7; / / error: no type
gt(int a, int b) { return(a>b) ? a: b; } / / error: no return type
unsigned ui; / / ok: ‘unsigned’ is the type ‘unsigned int’
long li; / / ok: ‘long’ is the type ‘long int’
In this, standard C++ differs from earlier versions of C and C++ that allowed the first two examples
by considering intto be the type when none were specified (§B.2). This ‘‘implicit int’’ rule was a
source of subtle errors and confusion.
4.9.2 Declaring Multiple Names [dcl.multi]
It is possible to declare several names in a single declaration. The declaration simply contains a list
of comma-separated declarators. For example, we can declare two integers like this:
int x, y; / / int x; int y;
Note that operators apply to individual names only – and not to any subsequent names in the same
declaration. For example:
int* p, y; / / int* p; int y; NOT int* y;
int x, *q; / / int x; int* q;
int v[10] , *pv; / / int v[10]; int* pv;
Such constructs make a program less readable and should be avoided.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 4.9.3 Names 81
4.9.3 Names [dcl.name]
A name (identifier) consists of a sequence of letters and digits. The first character must be a letter.
The underscore character _is considered a letter. C++ imposes no limit on the number of characters in a name. However, some parts of an implementation are not under the control of the compiler writer (in particular, the linker), and those parts, unfortunately, sometimes do impose limits.
Some run-time environments also make it necessary to extend or restrict the set of characters
accepted in an identifier. Extensions (e.g., allowing the character $ in a name) yield nonportable
programs. A C++ keyword (Appendix A), such as newand int, cannot be used as a name of a
user-defined entity. Examples of names are:
hello this_is_a_most_unusually_long_name
DEFINED foO bAr u_name HorseSense
var0 var1 CLASS_class___
Examples of character sequences that cannot be used as identifiers are:
012 a fool$sys class 3var
pay.due foo~bar.name if
Names starting with an underscore are reserved for special facilities in the implementation and the
run-time environment, so such names should not be used in application programs.
When reading a program, the compiler always looks for the longest string of characters that
could make up a name. Hence, var10is a single name, not the name varfollowed by the number
10. Also, elseifis a single name, not the keyword elsefollowed by the keyword if.
Uppercase and lowercase letters are distinct, so Countand countare different names, but it is
unwise to choose names that differ only by capitalization. In general, it is best to avoid names that
differ only in subtle ways. For example, the uppercase o (O) and zero (0) can be hard to tell apart,
as can the lowercase L (l) and one (1). Consequently, l0, lO, l1, and llare poor choices for identifier names.
Names from a large scope ought to have relatively long and reasonably obvious names, such as
vector, Window_with_border, and Department_number. However, code is clearer if names used
only in a small scope have short, conventional names such as x, i, and p. Classes (Chapter 10) and
namespaces (§8.2) can be used to keep scopes small. It is often useful to keep frequently used
names relatively short and reserve really long names for infrequently used entities. Choose names
to reflect the meaning of an entity rather than its implementation. For example, phone_bookis better than number_listeven if the phone numbers happen to be stored in a list(§3.7). Choosing good
names is an art.
Try to maintain a consistent naming style. For example, capitalize nonstandard library userdefined types and start nontypes with a lowercase letter (for example, Shapeand current_token).
Also, use all capitals for macros (if you must use macros; for example, HACK) and use underscores
to separate words in an identifier. However, consistency is hard to achieve because programs are
typically composed of fragments from different sources and several different reasonable styles are
in use. Be consistent in your use of abbreviations and acronyms.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
82 Types and Declarations Chapter 4
4.9.4 Scope [dcl.scope]
A declaration introduces a name into a scope; that is, a name can be used only in a specific part of
the program text. For a name declared in a function (often called a local name), that scope extends
from its point of declaration to the end of the block in which its declaration occurs. A block is a
section of code delimited by a { } pair.
A name is called global if it is defined outside any function, class (Chapter 10), or namespace
(§8.2). The scope of a global name extends from the point of declaration to the end of the file in
which its declaration occurs. A declaration of a name in a block can hide a declaration in an
enclosing block or a global name. That is, a name can be redefined to refer to a different entity
within a block. After exit from the block, the name resumes its previous meaning. For example:
int x; / / global x
void f()
{
int x; / / local x hides global x
x= 1; / / assign to local x
{
int x; / / hides first local x
x= 2; / / assign to second local x
}
x= 3; / / assign to first local x
}
int* p= &x; / / take address of global x
Hiding names is unavoidable when writing large programs. However, a human reader can easily
fail to notice that a name has been hidden. Because such errors are relatively rare, they can be very
difficult to find. Consequently, name hiding should be minimized. Using names such as iand xfor
global variables or for local variables in a large function is asking for trouble.
A hidden global name can be referred to using the scope resolution operator : :. For example:
int x;
void f2()
{
int x= 1; / / hide global x
: :x= 2; / / assign to global x
x= 2; / / assign to local x
/ / ...
}
There is no way to use a hidden local name.
The scope of a name starts at its point of declaration; that is, after the complete declarator and
before the initializer. This implies that a name can be used even to specify its own initial value.
For example:
int x;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 4.9.4 Scope 83
void f3()
{
int x= x; / / perverse: initialize x with its own (uninitialized) value
}
This is not illegal, just silly. A good compiler will warn if a variable is used before it has been set
(see also §5.9[9]).
It is possible to use a single name to refer to two different objects in a block without using the
: : operator. For example:
int x= 11;
void f4() / / perverse:
{
int y= x; / / use global x: y = 11
int x= 22;
y= x; / / use local x: y = 22
}
Function argument names are considered declared in the outermost block of a function, so
void f5(int x)
{
int x; / / error
}
is an error because xis defined twice in the same scope. Having this be an error allows a not
uncommon, subtle mistake to be caught.
4.9.5 Initialization [dcl.init]
If an initializer is specified for an object, that initializer determines the initial value of an object. If
no initializer is specified, a global (§4.9.4), namespace (§8.2), or local static object (§7.1.2, §10.2.4)
(collectively called static objects) is initialized to 0of the appropriate type. For example:
int a; / / means ‘‘int a = 0;’’
double d; / / means ‘‘double d = 0.0;’’
Local variables (sometimes called automatic objects) and objects created on the free store (sometimes called dynamic objects or heap objects) are not initialized by default. For example:
void f()
{
int x; / / x does not have a well-defined value
/ / ...
}
Members of arrays and structures are default initialized or not depending on whether the array or
structure is static. User-defined types may have default initialization defined (§10.4.2).
More complicated objects require more than one value as an initializer. This is handled by initializer lists delimited by { and } for C-style initialization of arrays (§5.2.1) and structures (§5.7).
For user-defined types with constructors, function-style argument lists are used (§2.5.2, §10.2.3).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
84 Types and Declarations Chapter 4
Note that an empty pair of parentheses () in a declaration always means ‘‘function’’ (§7.1).
For example:
int a[] = { 1, 2}; / / array initializer
Point z(1,2) ; / / function-style initializer (initialization by constructor)
int f() ; / / function declaration
4.9.6 Objects and Lvalues [dcl.objects]
We can allocate and use ‘‘variables’’ that do not have names, and it is possible to assign to
strange-looking expressions (e.g., *p[a+10]=7). Consequently, there is a need for a name for
‘‘something in memory.’’ This is the simplest and most fundamental notion of an object. That is,
an object is a contiguous region of storage; an lvalue is an expression that refers to an object. The
word lvalue was originally coined to mean ‘‘something that can be on the left-hand side of an
assignment.’’ However, not every lvalue may be used on the left-hand side of an assignment; an
lvalue can refer to a constant (§5.5). An lvalue that has not been declared constis often called a
modifiable lvalue. This simple and low-level notion of an object should not be confused with the
notions of class object and object of polymorphic type (§15.4.3).
Unless the programmer specifies otherwise (§7.1.2, §10.4.8), an object declared in a function is
created when its definition is encountered and destroyed when its name goes out of scope (§10.4.4).
Such objects are called automatic objects. Objects declared in global or namespace scope and statics declared in functions or classes are created and initialized once (only) and ‘‘live’’ until the program terminates (§10.4.9). Such objects are called static objects. Array elements and nonstatic
structure or class members have their lifetimes determined by the object of which they are part.
Using the newand deleteoperators, you can create objects whose lifetimes are controlled
directly (§6.2.6).
4.9.7 Typedef [dcl.typedef]
A declaration prefixed by the keyword typedefdeclares a new name for the type rather than a new
variable of the given type. For example:
typedef char* Pchar;
Pchar p1, p2; / / p1 and p2 are char*s
char* p3= p1;
A name defined like this, usually called a ‘‘ typedef,’’ can be a convenient shorthand for a type
with an unwieldy name. For example, unsigned charis too long for really frequent use, so we
could define a synonym, uchar:
typedef unsigned char uchar;
Another use of a typedefis to limit the direct reference to a type to one place. For example:
typedef int int32;
typedef short int16;
If we now use int32wherever we need a potentially large integer, we can port our program to a
machine on which sizeof(int) is 2by redefining the single occurrence of intin our code:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 4.9.7 Typedef 85
typedef long int32;
For good and bad, typedefs are synonyms for other types rather than distinct types. Consequently,
typedefs mix freely with the types for which they are synonyms. People who would like to have
distinct types with identical semantics or identical representation should look at enumerations
(§4.8) or classes (Chapter 10).
4.10 Advice [dcl.advice]
[1] Keep scopes small; §4.9.4.
[2] Don’t use the same name in both a scope and an enclosing scope; §4.9.4.
[3] Declare one name (only) per declaration; §4.9.2.
[4] Keep common and local names short, and keep uncommon and nonlocal names longer; §4.9.3.
[5] Avoid similar-looking names; §4.9.3.
[6] Maintain a consistent naming style; §4.9.3.
[7] Choose names carefully to reflect meaning rather than implementation; §4.9.3.
[8] Use a typedefto define a meaningful name for a built-in type in cases in which the built-in
type used to represent a value might change; §4.9.7.
[9] Use typedefs to define synonyms for types; use enumerations and classes to define new types;
§4.9.7.
[10] Remember that every declaration must specify a type (there is no ‘‘implicit int’’); §4.9.1.
[11] Avoid unnecessary assumptions about the numeric value of characters; §4.3.1, §C.6.2.1.
[12] Avoid unnecessary assumptions about the size of integers; §4.6.
[13] Avoid unnecessary assumptions about the range of floating-point types; §4.6.
[14] Prefer a plain intover a short intor a long int; §4.6.
[15] Prefer a doubleover a floator a long double; §4.5.
[16] Prefer plain charover signed charand unsigned char; §C.3.4.
[17] Avoid making unnecessary assumptions about the sizes of objects; §4.6.
[18] Avoid unsigned arithmetic; §4.4.
[19] View signedto unsignedand unsignedto signedconversions with suspicion; §C.6.2.6.
[20] View floating-point to integer conversions with suspicion; §C.6.2.6.
[21] View conversions to a smaller type, such as intto char, with suspicion; §C.6.2.6.
4.11 Exercises [dcl.exercises]
1. (∗2) Get the ‘‘Hello, world!’’ program (§3.2) to run. If that program doesn’t compile as written, look at §B.3.1.
2. (∗1) For each declaration in §4.9, do the following: If the declaration is not a definition, write a
definition for it. If the declaration is a definition, write a declaration for it that is not also a definition.
3. (∗1.5) Write a program that prints the sizes of the fundamental types, a few pointer types, and a
few enumerations of your choice. Use the sizeofoperator.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
86 Types and Declarations Chapter 4
4. (∗1.5) Write a program that prints out the letters ´a´..´z´ and the digits ´0´..´9´ and their
integer values. Do the same for other printable characters. Do the same again but use hexadecimal notation.
5. (∗2) What, on your system, are the largest and the smallest values of the following types: char,
short, int, long, float, double, long double, and unsigned.
6. (∗1) What is the longest local name you can use in a C++ program on your system? What is the
longest external name you can use in a C++ program on your system? Are there any restrictions
on the characters you can use in a name?
7. (∗2) Draw a graph of the integer and fundamental types where a type points to another type if
all values of the first can be represented as values of the second on every standards-conforming
implementation. Draw the same graph for the types on your favorite implementation.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
5 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
Pointers, Arrays, and Structures
The sublime and the ridiculous
are often so nearly related that
it is difficult to class them separately.
– Tom Paine
Pointers — zero — arrays — string literals — pointers into arrays — constants — pointers and constants — references — void* — data structures — advice — exercises.
5.1 Pointers [ptr.ptr]
For a type T, T* is the type ‘‘pointer to T.’’ That is, a variable of type T* can hold the address of
an object of type T. For example:
char c= ´a´;
char* p= &c; / / p holds the address of c
or graphically:
&c. . ’a’
p:
c:
Unfortunately, pointers to arrays and pointers to functions need a more complicated notation:
int* pi; / / pointer to int
char** ppc; / / pointer to pointer to char
int* ap[15] ; / / array of 15 pointers to ints
int(*fp)(char*) ; / / pointer to function taking a char* argument; returns an int
int* f(char*) ; / / function taking a char* argument; returns a pointer to int
See §4.9.1 for an explanation of the declaration syntax and Appendix A for the complete grammar.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
88 Pointers, Arrays, and Structures Chapter 5
The fundamental operation on a pointer is dereferencing, that is, referring to the object pointed
to by the pointer. This operation is also called indirection. The dereferencing operator is (prefix)
unary *. For example:
char c= ´a´;
char* p= &c; / / p holds the address of c
char c2= *p; / / c2 == ’a’
The variable pointed to by pis c, and the value stored in cis ´a´, so the value of *passigned to c2
is ´a´.
It is possible to perform some arithmetic operations on pointers to array elements (§5.3). Pointers to functions can be extremely useful; they are discussed in §7.7.
The implementation of pointers is intended to map directly to the addressing mechanisms of the
machine on which the program runs. Most machines can address a byte. Those that can’t tend to
have hardware to extract bytes from words. On the other hand, few machines can directly address
an individual bit. Consequently, the smallest object that can be independently allocated and
pointed to using a built-in pointer type is a char. Note that a booloccupies at least as much space
as a char(§4.6). To store smaller values more compactly, you can use logical operations (§6.2.4)
or bit fields in structures (§C.8.1).
5.1.1 Zero [ptr.zero]
Zero (0) is an int. Because of standard conversions (§C.6.2.3), 0can be used as a constant of any
integral (§4.1.1), floating-point, pointer, or pointer-to-member type. The type of zero will be determined by context. Zero will typically (but not necessarily) be represented by the bit pattern allzeros of the appropriate size.
No object is allocated with the address 0. Consequently, 0acts as a pointer literal, indicating
that a pointer doesn’t refer to an object.
In C, it has been popular to define a macro NULLto represent the zero pointer. Because of
C++’s tighter type checking, the use of plain 0, rather than any suggested NULLmacro, leads to
fewer problems. If you feel you must define NULL, use
const int NULL= 0;
The constqualifier (§5.4) prevents accidental redefinition of NULLand ensures that NULLcan be
used where a constant is required.
5.2 Arrays [ptr.array]
For a type T, T[size] is the type ‘‘array of sizeelements of type T.’’ The elements are indexed
from 0to size-1. For example:
float v[3] ; / / an array of three floats: v[0], v[1], v[2]
char* a[32] ; / / an array of 32 pointers to char: a[0] .. a[31]
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 5.2 Arrays 89
The number of elements of the array, the array bound, must be a constant expression (§C.5). If you
need variable bounds, use a vector(§3.7.1, §16.3). For example:
void f(int i)
{
int v1[i] ; / / error: array size not a constant expression
vector<int> v2(i) ; / / ok
}
Multidimensional arrays are represented as arrays of arrays. For example:
int d2[10][20] ; / / d2 is an array of 10 arrays of 20 integers
Using comma notation as used for array bounds in some other languages gives compile-time errors
because comma (,) is a sequencing operator (§6.2.2) and is not allowed in constant expressions
(§C.5). For example, try this:
int bad[5,2] ; / / error: comma not allowed in a constant expression
Multidimensional arrays are described in §C.7. They are best avoided outside low-level code.
5.2.1 Array Initializers [ptr.array.init]
An array can be initialized by a list of values. For example:
int v1[] = { 1, 2, 3, 4};
char v2[] = { ´a´, ´b´, ´c´, 0};
When an array is declared without a specific size, but with an initializer list, the size is calculated
by counting the elements of the initializer list. Consequently, v1and v2are of type int[4] and
char[4], respectively. If a size is explicitly specified, it is an error to give surplus elements in an
initializer list. For example:
char v3[2] = { ´a´, ´b´, 0}; / / error: too many initializers
char v4[3] = { ´a´, ´b´, 0}; / / ok
If the initializer supplies too few elements, 0is assumed for the remaining array elements. For
example:
int v5[8] = { 1, 2, 3, 4};
is equivalent to
int v5[] = { 1, 2, 3, 4, 0, 0, 0, 0};
Note that there is no array assignment to match the initialization:
void f()
{
v4= { ´c´, ´d´, 0}; / / error: no array assignment
}
When you need such assignments, use a vector(§16.3) or a valarray(§22.4) instead.
An array of characters can be conveniently initialized by a string literal (§5.2.2).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
90 Pointers, Arrays, and Structures Chapter 5
5.2.2 String Literals [ptr.string.literal]
A string literal is a character sequence enclosed within double quotes:
"this is a string"
A string literal contains one more character than it appears to have; it is terminated by the null character ´\0´, with the value 0. For example:
sizeof("Bohr")==5
The type of a string literal is ‘‘array of the appropriate number of constcharacters,’’ so "Bohr"is
of type const char[5].
A string literal can be assigned to a char*. This is allowed because in previous definitions of C
and C++ , the type of a string literal was char*. Allowing the assignment of a string literal to a
char* ensures that millions of lines of C and C++ remain valid. It is, however, an error to try to
modify a string literal through such a pointer:
void f()
{
char* p= "Plato";
p[4] = ´e´; / / error: assignment to const; result is undefined
}
This kind of error cannot in general be caught until run-time, and implementations differ in their
enforcement of this rule. Having string literals constant not only is obvious, but also allows implementations to do significant optimizations in the way string literals are stored and accessed.
If we want a string that we are guaranteed to be able to modify, we must copy the characters
into an array:
void f()
{
char p[] = "Zeno"; / / p is an array of 5 char
p[0] = ´R´; / / ok
}
A string literal is statically allocated so that it is safe to return one from a function. For example:
const char* error_message(int i)
{
/ / ...
return"range error";
}
The memory holding range errorwill not go away after a call of error_message().
Whether two identical character literals are allocated as one is implementation-defined (§C.1).
For example:
const char* p= "Heraclitus";
const char* q= "Heraclitus";
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 5.2.2 String Literals 91
void g()
{
if(p== q) cout<< "one!\n"; / / result is implementation-defined
/ / ...
}
Note that == compares addresses (pointer values) when applied to pointers, and not the values
pointed to.
The empty string is written as a pair of adjacent double quotes, "", (and has the type const
char[1]).
The backslash convention for representing nongraphic characters (§C.3.2) can also be used
within a string. This makes it possible to represent the double quote (") and the escape character
backslash ( \) within a string. The most common such character by far is the newline character,
´\n´. For example:
cout<<"beep at end of message\a\n";
The escape character ´\a´ is the ASCII character BEL(also known as alert), which causes some
kind of sound to be emitted.
It is not possible to have a ‘‘real’’ newline in a string:
"this is not a string
but a syntax error"
Long strings can be broken by whitespace to make the program text neater. For example:
char alpha[] = "abcdefghijklmnopqrstuvwxyz"
"ABCDEFGHIJKLMNOPQRSTUVWXYZ";
The compiler will concatenate adjacent strings, so alphacould equivalently have been initialized
by the single string:
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
It is possible to have the null character in a string, but most programs will not suspect that there
are characters after it. For example, the string "Jens\000Munk"will be treated as "Jens"by standard library functions such as strcpy() and strlen(); see §20.4.1.
A string with the prefix L, such as L"angst", is a string of wide characters (§4.3, §C.3.3). Its
type is const wchar_t[].
5.3 Pointers into Arrays [ptr.into]
In C++, pointers and arrays are closely related. The name of an array can be used as a pointer to its
initial element. For example:
int v[] = { 1, 2, 3, 4};
int* p1= v; / / pointer to initial element (implicit conversion)
int* p2= &v[0] ; / / pointer to initial element
int* p3= &v[4] ; / / pointer to one beyond last element
or graphically:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
92 Pointers, Arrays, and Structures Chapter 5
p1 p2 p3
. . 1. 2. 3. 4. . v:
Taking a pointer to the element one beyond the end of an array is guaranteed to work. This is
important for many algorithms (§2.7.2, §18.3). However, since such a pointer does not in fact point
to an element of the array, it may not be used for reading or writing. The result of taking the
address of the element before the initial element is undefined and should be avoided. On some
machine architectures, arrays are often allocated on machine addressing boundaries, so ‘‘one before
the initial element’’ simply doesn’t make sense.
The implicit conversion of an array name to a pointer to the initial element of the array is extensively used in function calls in C-style code. For example:
extern"C" int strlen(const char*) ; / / from <string.h>
void f()
{
char v[] = "Annemarie";
char* p= v; / / implicit conversion of char[] to char*
strlen(p) ;
strlen(v) ; / / implicit conversion of char[] to char*
v= p; / / error: cannot assign to array
}
The same value is passed to the standard library function strlen() in both calls. The snag is that it
is impossible to avoid the implicit conversion. In other words, there is no way of declaring a function so that the array vis copied when the function is called. Fortunately, there is no implicit or
explicit conversion from a pointer to an array.
The implicit conversion of the array argument to a pointer means that the size of the array is lost
to the called function. However, the called function must somehow determine the size to perform a
meaningful operation. Like other C standard library functions taking pointers to characters,
strlen() relies on zero to indicate end-of-string; strlen(p) returns the number of characters up to
and not including the terminating 0. This is all pretty low-level. The standard library vector
(§16.3) and string(Chapter 20) don’t suffer from this problem.
5.3.1 Navigating Arrays [ptr.navigate]
Efficient and elegant access to arrays (and similar data structures) is the key to many algorithms
(see §3.8, Chapter 18). Access can be achieved either through a pointer to an array plus an index or
through a pointer to an element. For example, traversing a character string using an index,
void fi(char v[])
{
for(int i= 0; v[i]!=0; i++) use(v[i]) ;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 5.3.1 Navigating Arrays 93
is equivalent to a traversal using a pointer:
void fp(char v[])
{
for(char* p= v; *p!=0; p++) use(*p) ;
}
The prefix * operator dereferences a pointer so that *pis the character pointed to by p,and ++
increments the pointer so that it refers to the next element of the array.
There is no inherent reason why one version should be faster than the other. With modern compilers, identical code should be generated for both examples (see §5.9[8]). Programmers can
choose between the versions on logical and aesthetic grounds.
The result of applying the arithmetic operators +, -, ++, or -- to pointers depends on the type
of the object pointed to. When an arithmetic operator is applied to a pointer pof type T*, pis
assumed to point to an element of an array of objects of type T; p+1points to the next element of
that array, and p-1points to the previous element. This implies that the integer value of p+1will
be sizeof(T) larger than the integer value of p. For example, executing
#include<iostream>
int main()
{
int vi[10] ;
short vs[10] ;
std: :cout<< &vi[0] << ´ ´ << &vi[1] << ´\n´;
std: :cout<< &vs[0] << ´ ´ << &vs[1] << ´\n´;
}
produced
0x7fffaef0 0x7fffaef4
0x7fffaedc 0x7fffaede
using a default hexadecimal notation for pointer values. This shows that on my implementation,
sizeof(short) is 2and sizeof(int) is 4.
Subtraction of pointers is defined only when both pointers point to elements of the same array
(although the language has no fast way of ensuring that is the case). When subtracting one pointer
from another, the result is the number of array elements between the two pointers (an integer). One
can add an integer to a pointer or subtract an integer from a pointer; in both cases, the result is a
pointer value. If that value does not point to an element of the same array as the original pointer or
one beyond, the result of using that value is undefined. For example:
void f()
{
int v1[10] ;
int v2[10] ;
int i1= &v1[5]-&v1[3] ; / / i1 = 2
int i2= &v1[5]-&v2[3] ; / / result undefined
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
94 Pointers, Arrays, and Structures Chapter 5
int* p1= v2+2; / / p1 = &v2[2]
int* p2= v2-2; / / *p2 undefined
}
Complicated pointer arithmetic is usually unnecessary and often best avoided. Addition of pointers
makes no sense and is not allowed.
Arrays are not self-describing because the number of elements of an array is not guaranteed to
be stored with the array. This implies that to traverse an array that does not contain a terminator the
way character strings do, we must somehow supply the number of elements. For example:
void fp(char v[] , unsigned int size)
{
for(int i=0; i<size; i++) use(v[i]) ;
const int N= 7;
char v2[N] ;
for(int i=0; i<N; i++) use(v2[i]) ;
}
Note that most C++ implementations offer no range checking for arrays. This array concept is
inherently low-level. A more advanced notion of arrays can be provided through the use of classes;
see §3.7.1.
5.4 Constants [ptr.const]
C++ offers the concept of a user-defined constant, a const, to express the notion that a value doesn’t
change directly. This is useful in several contexts. For example, many objects don’t actually have
their values changed after initialization, symbolic constants lead to more maintainable code than do
literals embedded directly in code, pointers are often read through but never written through, and
most function parameters are read but not written to.
The keyword constcan be added to the declaration of an object to make the object declared a
constant. Because it cannot be assigned to, a constant must be initialized. For example:
const int model= 90; / / model is a const
const int v[] = { 1, 2, 3, 4}; / / v[i] is a const
const int x; / / error: no initializer
Declaring something constensures that its value will not change within its scope:
void f()
{
model= 200; / / error
v[2]++; / / error
}
Note that constmodifies a type; that is, it restricts the ways in which an object can be used, rather
than specifying how the constant is to be allocated. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 5.4 Constants 95
void g(const X* p)
{
/ / can’t modify *p here
}
void h()
{
X val; / / val can be modified
g(&val) ;
/ / ...
}
Depending on how smart it is, a compiler can take advantage of an object being a constant in several ways. For example, the initializer for a constant is often (but not always) a constant expression
(§C.5); if it is, it can be evaluated at compile time. Further, if the compiler knows every use of the
const, it need not allocate space to hold it. For example:
const int c1= 1;
const int c2= 2;
const int c3= my_f(3) ; / / don’t know the value of c3 at compile time
extern const int c4; / / don’t know the value of c4 at compile time
const int* p= &c2; / / need to allocate space for c2
Given this, the compiler knows the values of c1and c2so that they can be used in constant expressions. Because the values of c3and c4are not known at compile time (using only the information
available in this compilation unit; see §9.1), storage must be allocated for c3and c4. Because the
address of c2is taken (and presumably used somewhere), storage must be allocated for c2. The
simple and common case is the one in which the value of the constant is known at compile time and
no storage needs to be allocated; c1is an example of that. The keyword externindicates that c4is
defined elsewhere (§9.2).
It is typically necessary to allocate store for an array of constants because the compiler cannot,
in general, figure out which elements of the array are referred to in expressions. On many
machines, however, efficiency improvements can be achieved even in this case by placing arrays of
constants in read-only storage.
Common uses for consts are as array bounds and case labels. For example:
const int a= 42;
const int b= 99;
const int max= 128;
int v[max] ;
void f(int i)
{
switch(i) {
case a:
/ / ...
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
96 Pointers, Arrays, and Structures Chapter 5
case b:
/ / ...
}
}
Enumerators (§4.8) are often an alternative to consts in such cases.
The way constcan be used with class member functions is discussed in §10.2.6 and §10.2.7.
Symbolic constants should be used systematically to avoid ‘‘magic numbers’’ in code. If a
numeric constant, such as an array bound, is repeated in code, it becomes hard to revise that code
because every occurrence of that constant must be changed to make a correct update. Using a symbolic constant instead localizes information. Usually, a numeric constant represents an assumption
about the program. For example, 4may represent the number of bytes in an integer, 128the number of characters needed to buffer input, and 6.24the exchange factor between Danish kroner and
U.S. dollars. Left as numeric constants in the code, these values are hard for a maintainer to spot
and understand. Often, such numeric values go unnoticed and become errors when a program is
ported or when some other change violates the assumptions they represent. Representing assumptions as well-commented symbolic constants minimizes such maintenance problems.
5.4.1 Pointers and Constants [ptr.pc]
When using a pointer, two objects are involved: the pointer itself and the object pointed to. ‘‘Prefixing’’ a declaration of a pointer with constmakes the object, but not the pointer, a constant. To
declare a pointer itself, rather than the object pointed to, to be a constant, we use the declarator
operator *constinstead of plain *. For example:
void f1(char* p)
{
char s[] = "Gorm";
const char* pc= s; / / pointer to constant
pc[3] = ´g´; / / error: pc points to constant
pc= p; / / ok
char*const cp= s; / / constant pointer
cp[3] = ´a´; / / ok
cp= p; / / error: cp is constant
const char*const cpc= s; / / const pointer to const
cpc[3] = ´a´; / / error: cpc points to constant
cpc= p; / / error: cpc is constant
}
The declarator operator that makes a pointer constant is *const. There is no const* declarator
operator, so a constappearing before the * is taken to be part of the base type. For example:
char*const cp; / / const pointer to char
char const* pc; / / pointer to const char
const char* pc2; / / pointer to const char
Some people find it helpful to read such declarations right-to-left. For example, ‘‘cpis a const
pointer to a char’’ and ‘‘pc2is a pointer to a char const.’’
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 5.4.1 Pointers and Constants 97
An object that is a constant when accessed through one pointer may be variable when accessed
in other ways. This is particularly useful for function arguments. By declaring a pointer argument
const, the function is prohibited from modifying the object pointed to. For example:
char* strcpy(char* p, const char* q) ; / / cannot modify *q
You can assign the address of a variable to a pointer to constant because no harm can come from
that. However, the address of a constant cannot be assigned to an unrestricted pointer because this
would allow the object’s value to be changed. For example:
void f4()
{
int a= 1;
const int c= 2;
const int* p1= &c; / / ok
const int* p2= &a; / / ok
int* p3= &c; / / error: initialization of int* with const int*
*p3= 7; / / try to change the value of c
}
It is possible to explicitly remove the restrictions on a pointer to constby explicit type conversion
(§10.2.7.1 and §15.4.2.1).
5.5 References [ptr.ref]
A reference is an alternative name for an object. The main use of references is for specifying arguments and return values for functions in general and for overloaded operators (Chapter 11) in particular. The notation X& means reference to X. For example:
void f()
{
int i= 1;
int& r= i; / / r and i now refer to the same int
int x= r; / / x = 1
r= 2; / / i = 2
}
To ensure that a reference is a name for something (that is, bound to an object), we must initialize
the reference. For example:
int i= 1;
int& r1= i; / / ok: r1 initialized
int& r2; / / error: initializer missing
extern int& r3; / / ok: r3 initialized elsewhere
Initialization of a reference is something quite different from assignment to it. Despite appearances, no operator operates on a reference. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
98 Pointers, Arrays, and Structures Chapter 5
void g()
{
int ii= 0;
int& rr= ii;
rr++; / / ii is incremented to 1
int* pp= &rr; / / pp points to ii
}
This is legal, but rr++ does not increment the reference rr; rather, ++ is applied to an intthat happens to be ii. Consequently, the value of a reference cannot be changed after initialization; it
always refers to the object it was initialized to denote. To get a pointer to the object denoted by a
reference rr, we can write &rr.
The obvious implementation of a reference is as a (constant) pointer that is dereferenced each
time it is used. It doesn’t do much harm thinking about references that way, as long as one remembers that a reference isn’t an object that can be manipulated the way a pointer is:
ii: 1
pp: &ii
rr:
In some cases, the compiler can optimize away a reference so that there is no object representing
that reference at run-time.
Initialization of a reference is trivial when the initializer is an lvalue (an object whose address
you can take; see §4.9.6). The initializer for a ‘‘plain’’ T& must be an lvalue of type T.
The initializer for a const T& need not be an lvalue or even of type T. In such cases,
[1] first, implicit type conversion to Tis applied if necessary (see §C.6);
[2] then, the resulting value is placed in a temporary variable of type T; and
[3] finally, this temporary variable is used as the value of the initializer.
Consider:
double& dr= 1; / / error: lvalue needed
const double& cdr= 1; / / ok
The interpretation of this last initialization might be:
double temp= double(1) ; / / first create a temporary with the right value
const double& cdr= temp; / / then use the temporary as the initializer for cdr
A temporary created to hold a reference initializer persists until the end of its reference’s scope.
References to variables and references to constants are distinguished because the introduction of
a temporary in the case of the variable is highly error-prone; an assignment to the variable would
become an assignment to the – soon to disappear – temporary. No such problem exists for references to constants, and references to constants are often important as function arguments (§11.6).
A reference can be used to specify a function argument so that the function can change the
value of an object passed to it. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 5.5 References 99
void increment(int& aa) { aa++; }
void f()
{
int x= 1;
increment(x) ; / / x = 2
}
The semantics of argument passing are defined to be those of initialization, so when called,
increment’s argument aabecame another name for x. To keep a program readable, it is often best
to avoid functions that modify their arguments. Instead, you can return a value from the function
explicitly or require a pointer argument:
int next(int p) { return p+1; }
void incr(int* p) { (*p)++; }
void g()
{
int x= 1;
increment(x) ; / / x = 2
x= next(x) ; / / x = 3
incr(&x) ; / / x = 4
}
The increment(x) notation doesn’t give a clue to the reader that x’s value is being modified, the
way x=next(x) and incr(&x) does. Consequently ‘‘plain’’ reference arguments should be used
only where the name of the function gives a strong hint that the reference argument is modified.
References can also be used to define functions that can be used on both the left-hand and
right-hand sides of an assignment. Again, many of the most interesting uses of this are found in the
design of nontrivial user-defined types. As an example, let us define a simple associative array.
First, we define struct Pairlike this:
struct Pair{
string name;
double val;
};
The basic idea is that a stringhas a floating-point value associated with it. It is easy to define a
function, value(), that maintains a data structure consisting of one Pairfor each different string
that has been presented to it. To shorten the presentation, a very simple (and inefficient) implementation is used:
vector<Pair> pairs;
double& value(const string& s)
/*
maintain a set of Pairs:
search for s, return its value if found; otherwise make a new Pair and return the default value 0
*/
{
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
100 Pointers, Arrays, and Structures Chapter 5
for(int i= 0; i< pairs.size() ; i++)
if(s== pairs[i].name) return pairs[i].val;
Pair p= { s, 0};
pairs.push_back(p) ; / / add Pair at end (§3.7.3)
return pairs[pairs.size()-1].val;
}
This function can be understood as an array of floating-point values indexed by character strings.
For a given argument string, value() finds the corresponding floating-point object (not the value
of the corresponding floating-point object); it then returns a reference to it. For example:
int main() / / count the number of occurrences of each word on input
{
string buf;
while(cin>>buf) value(buf)++;
for(vector<Pair>: :const_iterator p= pairs.begin() ; p!=pairs.end() ; ++p)
cout<< p->name<< ": " << p->val<< ´\n´;
}
Each time around, the while-loop reads one word from the standard input stream cininto the string
buf(§3.6) and then updates the counter associated with it. Finally, the resulting table of different
words in the input, each with its number of occurrences, is printed. For example, given the input
aa bb bb aa aa bb aa aa
this program will produce:
aa: 5
bb: 3
It is easy to refine this into a proper associative array type by using a template class with the selection operator [] overloaded (§11.8). It is even easier just to use the standard library map(§17.4.1).
5.6 Pointer to Void [ptr.ptrtovoid]
A pointer of any type of object can be assigned to a variable of type void*, a void* can be assigned
to another void*, void*s can be compared for equality and inequality, and a void* can be explicitly
converted to another type. Other operations would be unsafe because the compiler cannot know
what kind of object is really pointed to. Consequently, other operations result in compile-time
errors. To use a void*, we must explicitly convert it to a pointer to a specific type. For example:
void f(int* pi)
{
void* pv= pi; / / ok: implicit conversion of int* to void*
*pv; / / error: can’t dereference void*
pv++; / / error: can’t increment void* (the size of the object pointed to is unknown)
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 5.6 Pointer to Void 101
int* pi2= static_cast<int*>(pv) ; / / explicit conversion back to int*
double* pd1= pv; / / error
double* pd2= pi; / / error
double* pd3= static_cast<double*>(pv) ; / / unsafe
}
In general, it is not safe to use a pointer that has been converted (‘‘cast’’) to a type that differs from
the type the object pointed to. For example, a machine may assume that every doubleis allocated
on an 8-byte boundary. If so, strange behavior could arise if pipointed to an intthat wasn’t allocated that way. This form of explicit type conversion is inherently unsafe and ugly. Consequently,
the notation used, static_cast, was designed to be ugly.
The primary use for void* is for passing pointers to functions that are not allowed to make
assumptions about the type of the object and for returning untyped objects from functions. To use
such an object, we must use explicit type conversion.
Functions using void* pointers typically exist at the very lowest level of the system, where real
hardware resources are manipulated. For example:
void* my_alloc(size_t n) ; / / allocate n bytes from my special heap
Occurrences of void*s at higher levels of the system should be viewed with suspicion because they
are likely indicators of design errors. Where used for optimization, void* can be hidden behind a
type-safe interface (§13.5, §24.4.2).
Pointers to functions (§7.7) and pointers to members (§15.5) cannot be assigned to void*s.
5.7 Structures [ptr.struct]
An array is an aggregate of elements of the same type. A structis an aggregate of elements of
(nearly) arbitrary types. For example:
struct address{
char* name; / / "Jim Dandy"
long int number; / / 61
char* street; / / "South St"
char* town; / / "New Providence"
char state[2] ; / / ’N’ ’J’
long zip; / / 7974
};
This defines a new type called addressconsisting of the items you need in order to send mail to
someone. Note the semicolon at the end. This is one of very few places in C++ where it is necessary to have a semicolon after a curly brace, so people are prone to forget it.
Variables of type addresscan be declared exactly as other variables, and the individual
members can be accessed using the . (dot) operator. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
102 Pointers, Arrays, and Structures Chapter 5
void f()
{
address jd;
jd.name= "Jim Dandy";
jd.number= 61;
}
The notation used for initializing arrays can also be used for initializing variables of structure types.
For example:
address jd= {
"Jim Dandy",
61, "South St",
"New Providence", {´N´,´J´}, 7974
};
Using a constructor (§10.2.3) is usually better, however. Note that jd.statecould not be initialized
by the string "NJ". Strings are terminated by the character ´\0´. Hence, "NJ"has three characters
– one more than will fit into jd.state.
Structure objects are often accessed through pointers using the -> (structure pointer dereference) operator. For example:
void print_addr(address* p)
{
cout<< p->name<< ´\n´
<< p->number<< ´ ´ << p->street<< ´\n´
<< p->town<< ´\n´
<< p->state[0] << p->state[1] << ´ ´ << p->zip<< ´\n´;
}
When pis a pointer, p->mis equivalent to (*p).m.
Objects of structure types can be assigned, passed as function arguments, and returned as the
result from a function. For example:
address current;
address set_current(address next)
{
address prev= current;
current= next;
return prev;
}
Other plausible operations, such as comparison (== and !=), are not defined. However, the user
can define such operators (Chapter 11).
The size of an object of a structure type is not necessarily the sum of the sizes of its members.
This is because many machines require objects of certain types to be allocated on architecturedependent boundaries or handle such objects much more efficiently if they are. For example, integers are often allocated on word boundaries. On such machines, objects are said to have to be
aligned properly. This leads to ‘‘holes’’ in the structures. For example, on many machines,
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 5.7 Structures 103
sizeof(address) is 24, and not 22as might be expected. You can minimize wasted space by simply ordering members by size (largest member first). However, it is usually best to order members
for readability and sort them by size only if there is a demonstrated need to optimize.
The name of a type becomes available for use immediately after it has been encountered and not
just after the complete declaration has been seen. For example:
struct Link{
Link* previous;
Link* successor;
};
It is not possible to declare new objects of a structure type until the complete declaration has been
seen. For example:
struct No_good{
No_good member; / / error: recursive definition
};
This is an error because the compiler is not able to determine the size of No_good. To allow two
(or more) structure types to refer to each other, we can declare a name to be the name of a structure
type. For example:
struct List; / / to be defined later
struct Link{
Link* pre;
Link* suc;
List* member_of;
};
struct List{
Link* head;
};
Without the first declaration of List, use of Listin the declaration of Linkwould have caused a syntax error.
The name of a structure type can be used before the type is defined as long as that use does not
require the name of a member or the size of the structure to be known. For example:
class S; / / ‘S’ is the name of some type
extern S a;
S f() ;
void g(S) ;
S* h(S*) ;
However, many such declarations cannot be used unless the type Sis defined:
void k(S* p)
{
S a; / / error: S not defined; size needed to allocate
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
104 Pointers, Arrays, and Structures Chapter 5
f() ; / / error: S not defined; size needed to return value
g(a) ; / / error: S not defined; size needed to pass argument
p->m= 7; / / error: S not defined; member name not known
S* q= h(p) ; / / ok: pointers can be allocated and passed
q->m= 7; / / error: S not defined; member name not known
}
A structis a simple form of a class(Chapter 10).
For reasons that reach into the pre-history of C, it is possible to declare a structand a nonstructure with the same name in the same scope. For example:
struct stat{ /* ... */ };
int stat(char* name, struct stat* buf) ;
In that case, the plain name (stat) is the name of the non-structure, and the structure must be
referred to with the prefix struct. Similarly, the keywords class, union(§C.8.2), and enum(§4.8)
can be used as prefixes for disambiguation. However, it is best not to overload names to make that
necessary.
5.7.1 Type Equivalence [ptr.equiv]
Two structures are different types even when they have the same members. For example,
struct S1{ int a; };
struct S2{ int a; };
are two different types, so
S1 x;
S2 y= x; / / error: type mismatch
Structure types are also different from fundamental types, so
S1 x;
int i= x; / / error: type mismatch
Every structmust have a unique definition in a program (§9.2.3).
5.8 Advice [ptr.advice]
[1] Avoid nontrivial pointer arithmetic; §5.3.
[2] Take care not to write beyond the bounds of an array; §5.3.1.
[3] Use 0rather than NULL; §5.1.1.
[4] Use vectorand valarrayrather than built-in (C-style) arrays; §5.3.1.
[5] Use stringrather than zero-terminated arrays of char; §5.3.
[6] Minimize use of plain reference arguments; §5.5.
[7] Avoid void* except in low-level code; §5.6.
[8] Avoid nontrivial literals (‘‘magic numbers’’) in code. Instead, define and use symbolic constants; §4.8, §5.4.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 5.9 Exercises 105
5.9 Exercises [ptr.exercises]
1. (∗1) Write declarations for the following: a pointer to a character, an array of 10 integers, a reference to an array of 10 integers, a pointer to an array of character strings, a pointer to a pointer
to a character, a constant integer, a pointer to a constant integer, and a constant pointer to an
integer. Initialize each one.
2. (∗1.5) What, on your system, are the restrictions on the pointer types char*, int*, and void*?
For example, may an int* have an odd value? Hint: alignment.
3. (∗1) Use typedefto define the types unsigned char, const unsigned char, pointer to integer,
pointer to pointer to char, pointer to arrays of char, array of 7 pointers to int, pointer to an array
of 7 pointers to int, and array of 8 arrays of 7 pointers to int.
4. (∗1) Write a function that swaps (exchanges the values of) two integers. Use int* as the argument type. Write another swap function using int& as the argument type.
5. (∗1.5) What is the size of the array strin the following example:
char str[] = "a short string";
What is the length of the string "a short string"?
6. (∗1) Define functions f(char), g(char&), and h(const char&). Call them with the arguments
´a´, 49, 3300, c, uc, and sc, where cis a char, ucis an unsigned char, and scis a signed
char. Which calls are legal? Which calls cause the compiler to introduce a temporary variable?
7. (∗1.5) Define a table of the names of months of the year and the number of days in each month.
Write out that table. Do this twice; once using an array of charfor the names and an array for
the number of days and once using an array of structures, with each structure holding the name
of a month and the number of days in it.
8. (∗2) Run some tests to see if your compiler really generates equivalent code for iteration using
pointers and iteration using indexing (§5.3.1). If different degrees of optimization can be
requested, see if and how that affects the quality of the generated code.
9. (∗1.5) Find an example where it would make sense to use a name in its own initializer.
10. (∗1) Define an array of strings in which the strings contain the names of the months. Print those
strings. Pass the array to a function that prints those strings.
11. (∗2) Read a sequence of words from input. Use Quitas a word that terminates the input. Print
the words in the order they were entered. Don’t print a word twice. Modify the program to sort
the words before printing them.
12. (∗2) Write a function that counts the number of occurrences of a pair of letters in a stringand
another that does the same in a zero-terminated array of char(a C-style string). For example,
the pair "ab" appears twice in "xabaacbaxabb".
13. (∗1.5) Define a struct Dateto keep track of dates. Provide functions that read Dates from
input, write Dates to output, and initialize a Datewith a date.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
106 Pointers, Arrays, and Structures Chapter 5
.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
6 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
Expressions and Statements
Premature optimization
is the root of all evil.
– D. Knuth
On the other hand,
we cannot ignore efficiency.
– Jon Bentley
Desk calculator example — input — command line arguments — expression summary
— logical and relational operators — increment and decrement — free store — explicit
type conversion — statement summary — declarations — selection statements — declarations in conditions — iteration statements — the infamous goto— comments and
indentation — advice — exercises.
6.1 A Desk Calculator [expr.calculator]
Statements and expressions are introduced by presenting a desk calculator program that provides
the four standard arithmetic operations as infix operators on floating-point numbers. The user can
also define variables. For example, given the input
r= 2.5
area= pi* r* r
(pi is predefined) the calculator program will write
2.5
19.635
where 2.5is the result of the first line of input and 19.635is the result of the second.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
108 Expressions and Statements Chapter 6
The calculator consists of four main parts: a parser, an input function, a symbol table, and a
driver. Actually, it is a miniature compiler in which the parser does the syntactic analysis, the input
function handles input and lexical analysis, the symbol table holds permanent information, and the
driver handles initialization, output, and errors. We could add many features to this calculator to
make it more useful (§6.6[20]), but the code is long enough as it is, and most features would just
add code without providing additional insight into the use of C++.
6.1.1 The Parser [expr.parser]
Here is a grammar for the language accepted by the calculator:
program:
END/ / END is end-of-input
expr_list END
expr_list:
expression PRINT/ / PRINT is semicolon
expression PRINT expr_list
expression:
expression+ term
expression- term
term
term:
term/ primary
term* primary
primary
primary:
NUMBER
NAME
NAME= expression
- primary
( expression)
In other words, a program is a sequence of expressions separated by semicolons. The basic units of
an expression are numbers, names, and the operators *, /, +, - (both unary and binary), and =.
Names need not be declared before use.
The style of syntax analysis used is usually called recursive descent; it is a popular and straightforward top-down technique. In a language such as C++, in which function calls are relatively
cheap, it is also efficient. For each production in the grammar, there is a function that calls other
functions. Terminal symbols (for example, END, NUMBER, +, and -) are recognized by the lexical analyzer, get_token(); and nonterminal symbols are recognized by the syntax analyzer functions, expr(), term(), and prim(). As soon as both operands of a (sub)expression are known, the
expression is evaluated; in a real compiler, code could be generated at this point.
The parser uses a function get_token() to get input. The value of the most recent call of
get_token() can be found in the global variable curr_tok. The type of curr_tokis the enumeration Token_value:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.1.1 The Parser 109
enum Token_value{
NAME, NUMBER, END,
PLUS=´+´, MINUS=´-´, MUL=´*´, DIV=´/´,
PRINT=´;´, ASSIGN=´=´, LP=´(´, RP=´)´
};
Token_value curr_tok= PRINT;
Representing each token by the integer value of its character is convenient and efficient and can be
a help to people using debuggers. This works as long as no character used as input has a value used
as an enumerator – and no character set I know of has a printing character with a single-digit integer value. I chose PRINTas the initial value for curr_tokbecause that is the value it will have
after the calculator has evaluated an expression and displayed its value. Thus, I ‘‘start the system’’
in a normal state to minimize the chance of errors and the need for special startup code.
Each parser function takes a bool(§4.2) argument indicating whether the function needs to call
get_token() to get the next token. Each parser function evaluates ‘‘its’’ expression and returns the
value. The function expr() handles addition and subtraction. It consists of a single loop that looks
for terms to add or subtract:
double expr(bool get) / / add and subtract
{
double left= term(get) ;
for(;;) / / ‘‘forever’’
switch(curr_tok) {
case PLUS:
left+= term(true) ;
break;
case MINUS:
left-= term(true) ;
break;
default:
return left;
}
}
This function really does not do much itself. In a manner typical of higher-level functions in a
large program, it calls other functions to do the work.
The switch-statement tests the value of its condition, which is supplied in parentheses after the
switchkeyword, against a set of constants. The break-statements are used to exit the switchstatement. The constants following the caselabels must be distinct. If the value tested does not
match any caselabel, the defaultis chosen. The programmer need not provide a default.
Note that an expression such as 2-3+4is evaluated as (2-3)+4, as specified in the grammar.
The curious notation for(;;) is the standard way to specify an infinite loop; you could pronounce it ‘‘forever.’’ It is a degenerate form of a for-statement (§6.3.3); while(true) is an alternative. The switch-statement is executed repeatedly until something different from + and - is found,
and then the return-statement in the default case is executed.
The operators += and -= are used to handle the addition and subtraction; left=left+term() and
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
110 Expressions and Statements Chapter 6
left=left-term() could have been used without changing the meaning of the program. However,
left+=term() and left-=term() not only are shorter but also express the intended operation
directly. Each assignment operator is a separate lexical token, so a+ = 1; is a syntax error because
of the space between the + and the =.
Assignment operators are provided for the binary operators
+ - * / % & | ^ << >>
so that the following assignment operators are possible
= += -= *= /= %= &= |= ^= <<= >>=
The % is the modulo, or remainder, operator; &, |, and ^ are the bitwise logical operators AND,
OR, and exclusive OR; << and >> are the left shift and right shift operators; §6.2 summarizes the
operators and their meanings. For a binary operator @applied to operands of built-in types, an
expression x@=ymeans x=x@y, except that xis evaluated once only.
Chapter 8 and Chapter 9 discuss how to organize a program as a set of modules. With one
exception, the declarations for this calculator example can be ordered so that everything is declared
exactly once and before it is used. The exception is expr(), which calls term(), which calls
prim(), which in turn calls expr(). This loop must be broken somehow. A declaration
double expr(bool) ;
before the definition of prim() will do nicely.
Function term() handles multiplication and division in the same way expr() handles addition
and subtraction:
double term(bool get) / / multiply and divide
{
double left= prim(get) ;
for(;;)
switch(curr_tok) {
case MUL:
left*= prim(true) ;
break;
case DIV:
if(double d= prim(true)) {
left/= d;
break;
}
return error("divide by 0") ;
default:
return left;
}
}
The result of dividing by zero is undefined and usually disastrous. We therefore test for 0before
dividing and call error() if we detect a zero divisor. The function error() is described in §6.1.4.
The variable dis introduced into the program exactly where it is needed and initialized immediately. The scope of a name introduced in a condition is the statement controlled by that condition,
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.1.1 The Parser 111
and the resulting value is the value of the condition (§6.3.2.1). Consequently, the division and
assignment left/=dis done if and only if dis nonzero.
The function prim() handling a primary is much like expr() and term(), except that because
we are getting lower in the call hierarchy a bit of real work is being done and no loop is necessary:
double number_value;
string string_value;
double prim(bool get) / / handle primaries
{
if(get) get_token() ;
switch(curr_tok) {
case NUMBER: / / floating-point constant
{ double v= number_value;
get_token() ;
return v;
}
case NAME:
{ double& v= table[string_value] ;
if(get_token() == ASSIGN) v= expr(true) ;
return v;
}
case MINUS: / / unary minus
return-prim(true) ;
case LP:
{ double e= expr(true) ;
if(curr_tok!= RP) return error(") expected") ;
get_token() ; / / eat ’)’
return e;
}
default:
return error("primary expected") ;
}
}
When a NUMBER(that is, an integer or floating-point literal) is seen, its value is returned. The
input routine get_token() places the value in the global variable number_value. Use of a global
variable in a program often indicates that the structure is not quite clean – that some sort of optimization has been applied. So it is here. Ideally, a lexical token consists of two parts: a value specifying the kind of token (a Token_valuein this program) and (when needed) the value of the token.
Here, there is only a single, simple variable, curr_tok, so the global variable number_valueis
needed to hold the value of the last NUMBERread. Eliminating this spurious global variable is left
as an exercise (§6.6[21]). Saving the value of number_valuein the local variable vbefore calling
get_token() is not really necessary. For every legal input, the calculator always uses one number
in the computation before reading another from input. However, saving the value and displaying it
correctly after an error helps the user.
In the same way that the value of the last NUMBERis kept in number_value, the character
string representation of the last NAMEseen is kept in string_value. Before doing anything to a
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
112 Expressions and Statements Chapter 6
name, the calculator must first look ahead to see if it is being assigned to or simply read. In both
cases, the symbol table is consulted. The symbol table is a map(§3.7.4, §17.4.1):
map<string,double> table;
That is, when tableis indexed by a string, the resulting value is the doublecorresponding to the
string. For example, if the user enters
radius= 6378.388;
the calculator will execute
double& v= table["radius"] ;
/ / ... expr() calculates the value to be assigned ...
v= 6378.388;
The reference vis used to hold on to the doubleassociated with radiuswhile expr() calculates the
value 6378.388from the input characters.
6.1.2 The Input Function [expr.input]
Reading input is often the messiest part of a program. This is because a program must communicate with a person, it must cope with that person’s whims, conventions, and seemingly random
errors. Trying to force the person to behave in a manner more suitable for the machine is often
(rightly) considered offensive. The task of a low-level input routine is to read characters and compose higher-level tokens from them. These tokens are then the units of input for higher-level routines. Here, low-level input is done by get_token(). Writing a low-level input routine need not be
an everyday task. Many systems provide standard functions for this.
I build get_token() in two stages. First, I provide a deceptively simple version that imposes a
burden on the user. Next, I modify it into a slightly less elegant, but much easier to use, version.
The idea is to read a character, use that character to decide what kind of token needs to be composed, and then return the Token_valuerepresenting the token read.
The initial statements read the first non-whitespace character into chand check that the read
operation succeeded:
Token_value get_token()
{
char ch= 0;
cin>>ch;
switch(ch) {
case 0:
return curr_tok=END; / / assign and return
By default, operator >> skips whitespace (that is, spaces, tabs, newlines, etc.) and leaves the value
of chunchanged if the input operation failed. Consequently, ch==0indicates end of input.
Assignment is an operator, and the result of the assignment is the value of the variable assigned
to. This allows me to assign the value ENDto curr_tokand return it in the same statement. Having a single statement rather than two is useful in maintenance. If the assignment and the return
became separated in the code, a programmer might update the one and forget to update to the other.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.1.2 The Input Function 113
Let us look at some of the cases separately before considering the complete function. The
expression terminator ´;´, the parentheses, and the operators are handled simply by returning their
values:
case´;´:
case´*´:
case´/´:
case´+´:
case´-´:
case´(´:
case´)´:
case´=´:
return curr_tok=Token_value(ch) ;
Numbers are handled like this:
case´0´: case´1´: case´2´: case´3´: case´4´:
case´5´: case´6´: case´7´: case´8´: case´9´:
case´.´:
cin.putback(ch) ;
cin>> number_value;
return curr_tok=NUMBER;
Stacking caselabels horizontally rather than vertically is generally not a good idea because this
arrangement is harder to read. However, having one line for each digit is tedious. Because operator >> is already defined for reading floating-point constants into a double, the code is trivial. First
the initial character (a digit or a dot) is put back into cin. Then the constant can be read into
number_value.
A name is handled similarly:
default: / / NAME, NAME =, or error
if(isalpha(ch)) {
cin.putback(ch) ;
cin>>string_value;
return curr_tok=NAME;
}
error("bad token") ;
return curr_tok=PRINT;
The standard library function isalpha() (§20.4.2) is used to avoid listing every character as a separate caselabel. Operator >> applied to a string (in this case, string_value) reads until it hits whitespace. Consequently, a user must terminate a name by a space before an operator using the name as
an operand. This is less than ideal, so we will return to this problem in §6.1.3.
Here, finally, is the complete input function:
Token_value get_token()
{
char ch= 0;
cin>>ch;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
114 Expressions and Statements Chapter 6
switch(ch) {
case 0:
return curr_tok=END;
case´;´:
case´*´:
case´/´:
case´+´:
case´-´:
case´(´:
case´)´:
case´=´:
return curr_tok=Token_value(ch) ;
case´0´: case´1´: case´2´: case´3´: case´4´:
case´5´: case´6´: case´7´: case´8´: case´9´:
case´.´:
cin.putback(ch) ;
cin>> number_value;
return curr_tok=NUMBER;
default: / / NAME, NAME =, or error
if(isalpha(ch)) {
cin.putback(ch) ;
cin>>string_value;
return curr_tok=NAME;
}
error("bad token") ;
return curr_tok=PRINT;
}
}
The conversion of an operator to its token value is trivial because the Token_valueof an operator
was defined as the integer value of the operator (§4.8).
6.1.3 Low-level Input [expr.low]
Using the calculator as defined so far reveals a few inconveniences. It is tedious to remember to
add a semicolon after an expression in order to get its value printed, and having a name terminated
by whitespace only is a real nuisance. For example, x=7is an identifier – rather than the identifier
xfollowed by the operator = and the number 7. Both problems are solved by replacing the typeoriented default input operations in get_token() with code that reads individual characters.
First, we’ll make a newline equivalent to the semicolon used to mark the end of expression:
Token_value get_token()
{
char ch;
do{ / / skip whitespace except ’\n’
if(!cin.get(ch)) return curr_tok= END;
} while(ch!=´\n´ && isspace(ch)) ;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.1.3 Low-level Input 115
switch(ch) {
case´;´:
case´\n´:
return curr_tok=PRINT;
A do-statement is used; it is equivalent to a while-statement except that the controlled statement is
always executed at least once. The call cin.get(ch) reads a single character from the standard
input stream into ch. By default, get() does not skip whitespace the way operator>> does. The
test if(!cin.get(ch)) fails if no character can be read from cin; in this case, ENDis returned to
terminate the calculator session. The operator ! (NOT) is used because get() returns truein case
of success.
The standard library function isspace() provides the standard test for whitespace (§20.4.2);
isspace(c) returns a nonzero value if cis a whitespace character and zero otherwise. The test is
implemented as a table lookup, so using isspace() is much faster than testing for the individual
whitespace characters. Similar functions test if a character is a digit – isdigit() – a letter – isalpha() – or a digit or letter – isalnum().
After whitespace has been skipped, the next character is used to determine what kind of lexical
token is coming.
The problem caused by >> reading into a string until whitespace is encountered is solved by
reading one character at a time until a character that is not a letter or a digit is found:
default: / / NAME, NAME=, or error
if(isalpha(ch)) {
string_value= ch;
while(cin.get(ch) && isalnum(ch)) string_value.push_back(ch) ;
cin.putback(ch) ;
return curr_tok=NAME;
}
error("bad token") ;
return curr_tok=PRINT;
Fortunately, these two improvements could both be implemented by modifying a single local section of code. Constructing programs so that improvements can be implemented through local modifications only is an important design aim.
6.1.4 Error Handling [expr.error]
Because the program is so simple, error handling is not a major concern. The error function simply
counts the errors, writes out an error message, and returns:
int no_of_errors;
double error(const string& s)
{
no_of_errors++;
cerr<< "error: " << s<< ´\n´;
return 1;
}
The stream cerris an unbuffered output stream usually used to report errors (§21.2.1).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
116 Expressions and Statements Chapter 6
The reason for returning a value is that errors typically occur in the middle of the evaluation of
an expression, so we should either abort that evaluation entirely or return a value that is unlikely to
cause subsequent errors. The latter is adequate for this simple calculator. Had get_token() kept
track of the line numbers, error() could have informed the user approximately where the error
occurred. This would be useful when the calculator is used noninteractively (§6.6[19]).
Often, a program must be terminated after an error has occurred because no sensible way of
continuing has been devised. This can be done by calling exit(), which first cleans up things like
output streams and then terminates the program with its argument as the return value (§9.4.1.1).
More stylized error-handling mechanisms can be implemented using exceptions (see §8.3,
Chapter 14), but what we have here is quite suitable for a 150-line calculator.
6.1.5 The Driver [expr.driver]
With all the pieces of the program in place, we need only a driver to start things. In this simple
example, main() can do that:
int main()
{
table["pi"] = 3.1415926535897932385; / / insert predefined names
table["e"] = 2.7182818284590452354;
while(cin) {
get_token() ;
if(curr_tok== END) break;
if(curr_tok== PRINT) continue;
cout<< expr(false) << ´\n´;
}
return no_of_errors;
}
Conventionally, main() should return zero if the program terminates normally and nonzero otherwise (§3.2). Returning the number of errors accomplishes this nicely. As it happens, the only
initialization needed is to insert the predefined names into the symbol table.
The primary task of the main loop is to read expressions and write out the answer. This is
achieved by the line:
cout<< expr(false) << ´\n´;
The argument falsetells expr() that it does not need to call get_token() to get a current token on
which to work.
Testing cineach time around the loop ensures that the program terminates if something goes
wrong with the input stream, and testing for ENDensures that the loop is correctly exited when
get_token() encounters end-of-file. A break-statement exits its nearest enclosing switch-statement
or loop (that is, a for-statement, while-statement, or do-statement). Testing for PRINT(that is, for
´\n´ and ´;´) relieves expr() of the responsibility for handling empty expressions. A continuestatement is equivalent to going to the very end of a loop, so in this case
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.1.5 The Driver 117
while(cin) {
/ / ...
if(curr_tok== PRINT) continue;
cout<< expr(false) << ´\n´;
}
is equivalent to
while(cin) {
/ / ...
if(curr_tok!= PRINT)
cout<< expr(false) << ´\n´;
}
6.1.6 Headers [expr.headers]
The calculator uses standard library facilities. Therefore, appropriate headers must be #included to
complete the program:
#include<iostream> / / I/O
#include<string> / / strings
#include<map> / / map
#include<cctype> / / isalpha(), etc.
All of these headers provide facilities in the stdnamespace, so to use the names they provide we
must either use explicit qualification with std: : or bring the names into the global namespace by
using namespace std;
To avoid confusing the discussion of expressions with modularity issues, I did the latter. Chapter 8
and Chapter 9 discuss ways of organizing this calculator into modules using namespaces and how
to organize it into source files. On many systems, standard headers have equivalents with a .hsuffix that declare the classes, functions, etc., and place them in the global namespace (§9.2.1, §9.2.4,
§B.3.1).
6.1.7 Command-Line Arguments [expr.command]
After the program was written and tested, I found it a bother to first start the program, then type the
expressions, and finally quit. My most common use was to evaluate a single expression. If that
expression could be presented as a command-line argument, a few keystrokes could be avoided.
A program starts by calling main() (§3.2, §9.4). When this is done, main() is given two
arguments specifying the number of arguments, usually called argc, and an array of arguments,
usually called argv. The arguments are character strings, so the type of argvis char*[argc+1].
The name of the program (as it occurs on the command line) is passed as argv[0], so argcis
always at least 1. The list of arguments is zero-terminated; that is, argv[argc]==0. For example,
for the command
dc 150/1.1934
the arguments have these values:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
118 Expressions and Statements Chapter 6
argc: 2
argv: 0
. . "dc"
"150/1.1934"
Because the conventions for calling main() are shared with C, C-style arrays and strings are used.
It is not difficult to get hold of a command-line argument. The problem is how to use it with
minimal reprogramming. The idea is to read from the command string in the same way that we
read from the input stream. A stream that reads from a string is unsurprisingly called an
istringstream. Unfortunately, there is no elegant way of making cinrefer to an istringstream.
Therefore, we must find a way of getting the calculator input functions to refer to an istringstream.
Furthermore, we must find a way of getting the calculator input functions to refer to an
istringstreamor to cindepending on what kind of command-line argument we supply.
A simple solution is to introduce a global pointer inputthat points to the input stream to be used
and have every input routine use that:
istream* input; / / pointer to input stream
int main(int argc, char* argv[])
{
switch(argc) {
case 1: / / read from standard input
input= &cin;
break;
case 2: / / read argument string
input= new istringstream(argv[1]) ;
break;
default:
error("too many arguments") ;
return 1;
}
table["pi"] = 3.1415926535897932385; / / insert predefined names
table["e"] = 2.7182818284590452354;
while(*input) {
get_token() ;
if(curr_tok== END) break;
if(curr_tok== PRINT) continue;
cout<< expr(false) << ´\n´;
}
if(input!= &cin) delete input;
return no_of_errors;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.1.7 Command-Line Arguments 119
An istringstreamis a kind of istreamthat reads from its character string argument (§21.5.3).
Upon reaching the end of its string, an istringstreamfails exactly like other streams do when they
hit the end of input (§3.6, §21.3.3). To use an istringstream, you must include <sstream>.
It would be easy to modify main() to accept several command-line arguments, but this does
not appear to be necessary, especially as several expressions can be passed as a single argument:
dc"rate=1.1934;150/rate;19.75/rate;217/rate"
I use quotes because ; is the command separator on my UNIX systems. Other systems have different conventions for supplying arguments to a program on startup.
It was inelegant to modify all of the input routines to use *inputrather than cinto gain the flexibility to use alternative sources of input. The change could have been avoided had I shown foresight by introducing something like inputfrom the start. A more general and useful view is to note
that the source of input really should be the parameter of a calculator module. That is, the fundamental problem with this calculator example is that what I refer to as ‘‘the calculator’’ is only a collection of functions and data. There is no module (§2.4) or object (§2.5.2) that explicitly represents
the calculator. Had I set out to design a calculator module or a calculator type, I would naturally
have considered what its parameters should be (§8.5[3], §10.6[16]).
6.1.8 A Note on Style [expr.style]
To programmers unacquainted with associative arrays, the use of the standard library mapas the
symbol table seems almost like cheating. It is not. The standard library and other libraries are
meant to be used. Often, a library has received more care in its design and implementation than a
programmer could afford for a handcrafted piece of code to be used in just one program.
Looking at the code for the calculator, especially at the first version, we can see that there isn’t
much traditional C-style, low-level code presented. Many of the traditional tricky details have been
replaced by uses of standard library classes such as ostream, string, and map(§3.4, §3.5, §3.7.4,
Chapter 17).
Note the relative scarcity of arithmetic, loops, and even assignments. This is the way things
ought to be in code that doesn’t manipulate hardware directly or implement low-level abstractions.
6.2 Operator Summary [expr.operators]
This section presents a summary of expressions and some examples. Each operator is followed by
one or more names commonly used for it and an example of its use. In these tables, a class_name
is the name of a class, a member is a member name, an object is an expression yielding a class
object, a pointer is an expression yielding a pointer, an expr is an expression, and an lvalue is an
expression denoting a nonconstant object. A type can be a fully general type name (with *, (),
etc.) only when it appears in parentheses; elsewhere, there are restrictions (§A.5).
The syntax of expressions is independent of operand types. The meanings presented here apply
when the operands are of built-in types (§4.1.1). In addition, you can define meanings for operators
applied to operands of user-defined types (§2.5.2, Chapter 11).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
120 Expressions and Statements Chapter 6
_ ____________________________________________________________
_ ____________________________________________________________ Operator Summary _ ____________________________________________________________
scope resolution class_name :: member
scope resolution namespace_name :: member
global :: name
_ ____________________________________________________________ global :: qualified-name
member selection object . member
member selection pointer -> member
subscripting pointer [ expr ]
function call expr ( expr_list )
value construction type ( expr_list )
post increment lvalue ++
post decrement lvalue --
type identification typeid( type )
run-time type identification typeid( expr )
run-time checked conversion dynamic_cast< type > ( expr )
compile-time checked conversion static_cast< type > ( expr )
unchecked conversion reinterpret_cast< type > ( expr )
_ ____________________________________________________________ constconversion const_cast< type > ( expr )
size of object sizeof expr
size of type sizeof( type )
pre increment ++ lvalue
pre decrement -- lvalue
complement ~ expr
not ! expr
unary minus - expr
unary plus + expr
address of & lvalue
dereference ∗ expr
create (allocate) new type
create (allocate and initialize) new type ( expr-list )
create (place) new( expr-list ) type
create (place and initialize) new( expr-list ) type ( expr-list )
destroy (de-allocate) delete pointer
destroy array delete[] pointer
_ ____________________________________________________________ cast (type conversion) ( type ) expr
member selection object .* pointer-to-member
_ ____________________________________________________________ member selection pointer ->* pointer-to-member
multiply expr ∗ expr
divide expr / expr
_ ____________________________________________________________ modulo (remainder) expr % expr 



































































































The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.2 Operator Summary 121
_ _______________________________________
_ _______________________________________ Operator Summary (continued) _ _______________________________________
add (plus) expr + expr
_ _______________________________________ subtract (minus) expr - expr
shift left expr << expr
_ _______________________________________ shift right expr >> expr
less than expr < expr
less than or equal expr <= expr
greater than expr > expr
_ _______________________________________ greater than or equal expr >= expr
equal expr == expr
_ _______________________________________ not equal expr != expr
_ _______________________________________ bitwise AND expr & expr
_ _______________________________________ bitwise exclusive OR expr ^ expr
_ _______________________________________ bitwise inclusive OR expr | expr
_ _______________________________________ logical AND expr && expr
_ _______________________________________ logical inclusive OR expr || expr
simple assignment lvalue = expr
multiply and assign lvalue ∗= expr
divide and assign lvalue /= expr
modulo and assign lvalue %= expr
add and assign lvalue += expr
subtract and assign lvalue -= expr
shift left and assign lvalue <<= expr
shift right and assign lvalue >>= expr
AND and assign lvalue &= expr
inclusive OR and assign lvalue |= expr
_ _______________________________________ exclusive OR and assign lvalue ^= expr
_ _______________________________________ conditional expression expr ? expr : expr
_ _______________________________________ throw exception throw expr
_ _______________________________________ comma (sequencing) expr , expr 













































































Each box holds operators with the same precedence. Operators in higher boxes have higher precedence than operators in lower boxes. For example: a+b*cmeans a+(b*c) rather than (a+b)*c
because * has higher precedence than +.
Unary operators and assignment operators are right-associative; all others are left-associative.
For example, a=b=cmeans a=(b=c), a+b+cmeans (a+b)+c, and *p++ means *(p++), not
(*p)++.
A few grammar rules cannot be expressed in terms of precedence (also known as binding
strength) and associativity. For example, a=b<c?d=e:f=gmeans a=((b<c)?(d=e):(f=g)),
but you need to look at the grammar (§A.5) to determine that.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
122 Expressions and Statements Chapter 6
6.2.1 Results [expr.res]
The result types of arithmetic operators are determined by a set of rules known as ‘‘the usual arithmetic conversions’’ (§C.6.3). The overall aim is to produce a result of the ‘‘largest’’ operand type.
For example, if a binary operator has a floating-point operand, the computation is done using
floating-point arithmetic and the result is a floating-point value. If it has a longoperand, the computation is done using long integer arithmetic, and the result is a long. Operands that are smaller
than an int(such as booland char) are converted to intbefore the operator is applied.
The relational operators, ==, <=, etc., produce Boolean results. The meaning and result type of
user-defined operators are determined by their declarations (§11.2).
Where logically feasible, the result of an operator that takes an lvalue operand is an lvalue
denoting that lvalue operand. For example:
void f(int x, int y)
{
int j= x= y; / / the value of x=y is the value of x after the assignment
int* p= &++x; / / p points to x
int* q= &(x++) ; / / error: x++ is not an lvalue (it is not the value stored in x)
int* pp= &(x>y?x:y) ; / / address of the int with the larger value
}
If both the second and third operands of ?: are lvalues and have the same type, the result is of that
type and is an lvalue. Preserving lvalues in this way allows greater flexibility in using operators.
This is particularly useful when writing code that needs to work uniformly and efficiently with both
built-in and user-defined types (e.g., when writing templates or programs that generate C++ code).
The result of sizeofis of an unsigned integral type called size_tdefined in <cstddef>. The
result of pointer subtraction is of a signed integral type called ptrdiff_tdefined in <cstddef>.
Implementations do not have to check for arithmetic overflow and hardly any do. For example:
void f()
{
int i= 1;
while(0< i) i++;
cout<< "i has become negative!" << i<< ´\n´;
}
This will (eventually) try to increase ipast the largest integer. What happens then is undefined, but
typically the value ‘‘wraps around’’ to a negative number (on my machine -2147483648). Similarly, the effect of dividing by zero is undefined, but doing so usually causes abrupt termination of
the program. In particular, underflow, overflow, and division by zero do not throw standard exceptions (§14.10).
6.2.2 Evaluation Order [expr.evaluation]
The order of evaluation of subexpressions within an expression is undefined. In particular, you
cannot assume that the expression is evaluated left to right. For example:
int x= f(2)+g(3) ; / / undefined whether f() or g() is called first
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.2.2 Evaluation Order 123
Better code can be generated in the absence of restrictions on expression evaluation order. However, the absence of restrictions on evaluation order can lead to undefined results. For example,
int i= 1;
v[i] = i++; / / undefined result
may be evaluated as either v[1]=1or v[2]=1or may cause some even stranger behavior. Compilers can warn about such ambiguities. Unfortunately, most do not.
The operators , (comma), && (logical and), and || (logical or) guarantee that their left-hand
operand is evaluated before their right-hand operand. For example, b=(a=2,a+1) assigns 3to b.
Examples of the use of || and && can be found in §6.2.3. For built-in types, the second operand of
&& is evaluated only if its first operand is true, and the second operand of || is evaluated only if its
first operand is false; this is sometimes called short-circuit evaluation. Note that the sequencing
operator , (comma) is logically different from the comma used to separate arguments in a function
call. Consider:
f1(v[i] ,i++) ; / / two arguments
f2( (v[i] ,i++) ) ; / / one argument
The call of f1has two arguments, v[i] and i++, and the order of evaluation of the argument
expressions is undefined. Order dependence of argument expressions is very poor style and has
undefined behavior. The call of f2has one argument, the comma expression (v[i] ,i++), which is
equivalent to i++.
Parentheses can be used to force grouping. For example, a*b/cmeans (a*b)/cso parentheses must be used to get a*(b/c); a*(b/c) may be evaluated as (a*b)/conly if the user cannot
tell the difference. In particular, for many floating-point computations a*(b/c) and (a*b)/care
significantly different, so a compiler will evaluate such expressions exactly as written.
6.2.3 Operator Precedence [expr.precedence]
Precedence levels and associativity rules reflect the most common usage. For example,
if(i<=0|| max<i) / / ...
means ‘‘if iis less than or equal to 0or if maxis less than i.’’ That is, it is equivalent to
if( (i<=0) || (max<i) ) / / ...
and not the legal but nonsensical
if(i<= (0||max) < i) / / ...
However, parentheses should be used whenever a programmer is in doubt about those rules. Use of
parentheses becomes more common as the subexpressions become more complicated, but complicated subexpressions are a source of errors. Therefore, if you start feeling the need for parentheses,
you might consider breaking up the expression by using an extra variable.
There are cases when the operator precedence does not result in the ‘‘obvious’’ interpretation.
For example:
if(i&mask== 0) / / oops! == expression as operand for &
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
124 Expressions and Statements Chapter 6
This does not apply a mask to iand then test if the result is zero. Because == has higher precedence than &, the expression is interpreted as i&(mask==0). Fortunately, it is easy enough for a
compiler to warn about most such mistakes. In this case, parentheses are important:
if((i&mask) == 0) / / ...
It is worth noting that the following does not work the way a mathematician might expect:
if(0<= x<= 99) / / ...
This is legal, but it is interpreted as (0<=x)<=99, where the result of the first comparison is either
trueor false. This Boolean value is then implicitly converted to 1or 0, which is then compared to
99, yielding true. To test whether xis in the range 0..99, we might use:
if(0<=x&& x<=99) / / ...
A common mistake for novices is to use = (assignment) instead of == (equals) in a condition:
if(a= 7) / / oops! constant assignment in condition
This is natural because = means ‘‘equals’’ in many languages. Again, it is easy for a compiler to
warn about most such mistakes – and many do.
6.2.4 Bitwise Logical Operators [expr.logical]
The bitwise logical operators &, |, ^, ~, >>, and << are applied to objects of integer types – that is,
bool, char, short, int, long, and their unsignedcounterparts. The results are also integers.
A typical use of bitwise logical operators is to implement the notion of a small set (a bit vector).
In this case, each bit of an unsigned integer represents one member of the set, and the number of
bits limits the number of members. The binary operator & is interpreted as intersection, | as union,
^ as symmetric difference, and ~ as complement. An enumeration can be used to name the members of such a set. Here is a small example borrowed from an implementation of ostream:
enum ios_base: :iostate{
goodbit=0, eofbit=1, failbit=2, badbit=4
};
The implementation of a stream can set and test its state like this:
state= goodbit;
/ / ...
if(state&(badbit|failbit)) / / stream no good
The extra parentheses are necessary because & has higher precedence than |.
A function that reaches the end of input might report it like this:
state|= eofbit;
The |= operator is used to add to the state. A simple assignment, state=eofbit, would have cleared
all other bits.
These stream state flags are observable from outside the stream implementation. For example,
we could see how the states of two streams differ like this:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.2.4 Bitwise Logical Operators 125
int diff= cin.rdstate()^cout.rdstate() ; / / rdstate() returns the state
Computing differences of stream states is not very common. For other similar types, computing
differences is essential. For example, consider comparing a bit vector that represents the set of
interrupts being handled with another that represents the set of interrupts waiting to be handled.
Please note that this bit fiddling is taken from the implementation of iostreams rather than from
the user interface. Convenient bit manipulation can be very important, but for reliability, maintainability, portability, etc., it should be kept at low levels of a system. For more general notions of a
set, see the standard library set(§17.4.3), bitset(§17.5.3), and vector<bool> (§16.3.11).
Using fields (§C.8.1) is really a convenient shorthand for shifting and masking to extract bit
fields from a word. This can, of course, also be done using the bitwise logical operators. For
example, one could extract the middle 16 bits of a 32-bit longlike this:
unsigned short middle(long a) { return(a>>8)&0xffff; }
Do not confuse the bitwise logical operators with the logical operators: &&, ||, and ! . The latter
return either trueor false, and they are primarily useful for writing the test in an if, while, or for
statement (§6.3.2, §6.3.3). For example, !0(not zero) is the value true, whereas ~0(complement
of zero) is the bit pattern all-ones, which in two’s complement representation is the value -1.
6.2.5 Increment and Decrement [expr.incr]
The ++ operator is used to express incrementing directly, rather than expressing it indirectly using
a combination of an addition and an assignment. By definition, ++lvaluemeans lvalue+=1, which
again means lvalue=lvalue+1provided lvaluehas no side effects. The expression denoting the
object to be incremented is evaluated once (only). Decrementing is similarly expressed by the --
operator. The operators ++ and -- can be used as both prefix and postfix operators. The value of
++xis the new (that is, incremented) value of x. For example, y=++xis equivalent to y=(x+=1).
The value of x++, however, is the old value of x. For example, y=x++ is equivalent to
y=(t=x,x+=1,t), where tis a variable of the same type as x.
Like addition and subtraction of pointers, ++ and -- on pointers operate in terms of elements of
the array into which the pointer points; p++ makes ppoint to the next element (§5.3.1).
The increment operators are particularly useful for incrementing and decrementing variables in
loops. For example, one can copy a zero-terminated string like this:
void cpy(char* p, const char* q)
{
while(*p++ = *q++) ;
}
Like C, C++ is both loved and hated for enabling such terse, expression-oriented coding. Because
while(*p++ = *q++) ;
is more than a little obscure to non-C programmers and because the style of coding is not uncommon in C and C++, it is worth examining more closely.
Consider first a more traditional way of copying an array of characters:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
126 Expressions and Statements Chapter 6
int length= strlen(q) ;
for(int i= 0; i<=length; i++) p[i] = q[i] ;
This is wasteful. The length of a zero-terminated string is found by reading the string looking for
the terminating zero. Thus, we read the string twice: once to find its length and once to copy it. So
we try this instead:
int i;
for(i= 0; q[i]!=0; i++) p[i] = q[i] ;
p[i] = 0; / / terminating zero
The variable iused for indexing can be eliminated because pand qare pointers:
while(*q!= 0) {
*p= *q;
p++; / / point to next character
q++; / / point to next character
}
*p= 0; / / terminating zero
Because the post-increment operation allows us first to use the value and then to increment it, we
can rewrite the loop like this:
while(*q!= 0) {
*p++ = *q++;
}
*p= 0; / / terminating zero
The value of *p++ = *q++ is *q. We can therefore rewrite the example like this:
while((*p++ = *q++) != 0) { }
In this case, we don’t notice that *qis zero until we already have copied it into *pand incremented
p. Consequently, we can eliminate the final assignment of the terminating zero. Finally, we can
reduce the example further by observing that we don’t need the empty block and that the ‘‘!= 0’’ is
redundant because the result of a pointer or integral condition is always compared to zero anyway.
Thus, we get the version we set out to discover:
while(*p++ = *q++) ;
Is this version less readable than the previous versions? Not to an experienced C or C++ programmer. Is this version more efficient in time or space than the previous versions? Except for the first
version that called strlen(), not really. Which version is the most efficient will vary among
machine architectures and among compilers.
The most efficient way of copying a zero-terminated character string for your particular
machine ought to be the standard string copy function:
char* strcpy(char*, const char*) ; / / from <string.h>
For more general copying, the standard copyalgorithm (§2.7.2, §18.6.1) can be used. Whenever
possible, use standard library facilities in preference to fiddling with pointers and bytes. Standard
library functions may be inlined (§7.1.1) or even implemented using specialized machine
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.2.5 Increment and Decrement 127
instructions. Therefore, you should measure carefully before believing that some piece of handcrafted code outperforms library functions.
6.2.6 Free Store [expr.free]
A named object has its lifetime determined by its scope (§4.9.4). However, it is often useful to create an object that exists independently of the scope in which it was created. In particular, it is common to create objects that can be used after returning from the function in which they were created.
The operator newcreates such objects, and the operator deletecan be used to destroy them.
Objects allocated by neware said to be ‘‘on the free store’’ (also, to be ‘‘heap objects,’’ or ‘‘allocated in dynamic memory’’).
Consider how we might write a compiler in the style used for the desk calculator (§6.1). The
syntax analysis functions might build a tree of the expressions for use by the code generator:
struct Enode{
Token_value oper;
Enode* left;
Enode* right;
/ / ...
};
Enode* expr(bool get)
{
Enode* left= term(get) ;
for(;;)
switch(curr_tok) {
case PLUS:
case MINUS:
{ Enode* n= new Enode; / / create an Enode on free store
n->oper= curr_tok;
n->left= left;
n->right= term(true) ;
left= n;
break;
}
default:
return left; / / return node
}
}
A code generator would then use the resulting nodes and delete them:
void generate(Enode* n)
{
switch(n->oper) {
case PLUS:
/ / ...
delete n; / / delete an Enode from the free store
}
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
128 Expressions and Statements Chapter 6
An object created by newexists until it is explicitly destroyed by delete. Then, the space it occupied can be reused by new. A C++ implementation does not guarantee the presence of a ‘‘garbage
collector’’ that looks out for unreferenced objects and makes them available to newfor reuse. Consequently, I will assume that objects created by neware manually freed using delete. If a garbage
collector is present, the deletes can be omitted in most cases (§C.9.1).
The deleteoperator may be applied only to a pointer returned by newor to zero. Applying
deleteto zero has no effect.
More specialized versions of operator newcan also be defined (§15.6).
6.2.6.1 Arrays [expr.array]
Arrays of objects can also be created using new. For example:
char* save_string(const char* p)
{
char* s= new char[strlen(p)+1] ;
strcpy(s,p) ; / / copy from p to s
return s;
}
int main(int argc, char* argv[])
{
if(argc< 2) exit(1) ;
char* p= save_string(argv[1]) ;
/ / ...
delete[] p;
}
The ‘‘plain’’ operator deleteis used to delete individual objects; delete[] is used to delete arrays.
To deallocate space allocated by new, deleteand delete[] must be able to determine the size of
the object allocated. This implies that an object allocated using the standard implementation of
newwill occupy slightly more space than a static object. Typically, one word is used to hold the
object’s size.
Note that a vector(§3.7.1, §16.3) is a proper object and can therefore be allocated and deallocated using plain newand delete. For example:
void f(int n)
{
vector<int>* p= new vector<int>(n) ; / / individual object
int* q= new int[n] ; / / array
/ / ...
delete p;
delete[] q;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.2.6.2 Memory Exhaustion 129
6.2.6.2 Memory Exhaustion [expr.exhaust]
The free store operators new, delete, new[], and delete[] are implemented using functions:
void* operator new(size_t) ; / / space for individual object
void operator delete(void*) ;
void* operator new[](size_t) ; / / space for array
void operator delete[](void*) ;
When operator newneeds to allocate space for an object, it calls operator new() to allocate a suitable number of bytes. Similarly, when operator newneeds to allocate space for an array, it calls
operator new[]().
The standard implementations of operator new() and operator new[]() do not initialize the
memory returned.
What happens when newcan find no store to allocate? By default, the allocator throws a
bad_allocexception. For example:
void f()
{
try{
for(;;) new char[10000] ;
}
catch(bad_alloc) {
cerr<< "Memory exhausted!\n";
}
}
However much memory we have available, this will eventually invoke the bad_allochandler.
We can specify what newshould do upon memory exhaustion. When newfails, it first calls a
function specified by a call to set_new_handler() declared in <new>, if any. For example:
void out_of_store()
{
cerr<< "operator new failed: out of store\n";
throw bad_alloc() ;
}
int main()
{
set_new_handler(out_of_store) ; / / make out_of_store the new_handler
for(;;) new char[10000] ;
cout<< "done\n";
}
This will never get to write done. Instead, it will write
operator new failed: out of store
See §14.4.5 for a plausible implementation of an operator new() that checks to see if there is a
new handler to call and that throws bad_allocif not. A new_handlermight do something more
clever than simply terminating the program. If you know how newand deletework – for example,
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
130 Expressions and Statements Chapter 6
because you provided your own operator new() and operator delete() – the handler might
attempt to find some memory for newto return. In other words, a user might provide a garbage
collector, thus rendering the use of deleteoptional. Doing this is most definitely not a task for a
beginner, though. For almost everybody who needs an automatic garbage collector, the right thing
to do is to acquire one that has already been written and tested (§C.9.1).
By providing a new_handler, we take care of the check for memory exhaustion for every ordinary use of newin the program. Two alternative ways of controlling memory allocation exist. We
can either provide nonstandard allocation and deallocation functions (§15.6) for the standard uses
of newor rely on additional allocation information provided by the user (§10.4.11, §19.4.5).
6.2.7 Explicit Type Conversion [expr.cast]
Sometimes, we have to deal with‘‘raw memory;’’ that is, memory that holds or will hold objects of
a type not known to the compiler. For example, a memory allocator may return a void* pointing to
newly allocated memory or we might want to state that a given integer value is to be treated as the
address of an I/O device:
void* malloc(size_t) ;
void f()
{
int* p= static_cast<int*>(malloc(100)) ; / / new allocation used as ints
IO_device* d1= reinterpret_cast<IO_device*>(0Xff00) ; / / device at 0Xff00
/ / ...
}
A compiler does not know the type of the object pointed to by the void*. Nor can it know whether
the integer 0Xff00is a valid address. Consequently, the correctness of the conversions are completely in the hands of the programmer. Explicit type conversion, often called casting, is occasionally essential. However, traditionally it is seriously overused and a major source of errors.
The static_castoperator converts between related types such as one pointer type to another, an
enumeration to an integral type, or a floating-point type to an integral type. The reinterpret_cast
handles conversions between unrelated types such as an integer to a pointer. This distinction
allows the compiler to apply some minimal type checking for static_castand makes it easier for a
programmer to find the more dangerous conversions represented as reinterpret_casts. Some
static_casts are portable, but few reinterpret_casts are. Hardly any guarantees are made for
reinterpret_cast, but generally it produces a value of a new type that has the same bit pattern as its
argument. If the target has at least as many bits as the original value, we can reinterpret_castthe
result back to its original type and use it. The result of a reinterpret_castis guaranteed to be
usable only if its result type is the exact type used to define the value involved. Note that
reinterpret_castis the kind of conversion that must be used for pointers to functions (§7.7).
If you feel tempted to use an explicit type conversion, take the time to consider if it is really
necessary. In C++, explicit type conversion is unnecessary in most cases when C needs it (§1.6)
and also in many cases in which earlier versions of C++ needed it (§1.6.2, §B.2.3). In many programs, explicit type conversion can be completely avoided; in others, its use can be localized to a
few routines. In this book, explicit type conversion is used in realistic situations in §6.2.7, §7.7,
§13.5, §15.4, and §25.4.1, only.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.2.7 Explicit Type Conversion 131
A form of run-time checked conversion, dynamic_cast(§15.4.1), and a cast for removing const
qualifiers, const_cast(§15.4.2.1), are also provided.
From C, C++ inherited the notation (T)e, which performs any conversion that can be expressed
as a combination of static_casts, reinterpret_casts, and const_casts to make a value of type T
from the expression e(§B.2.3). This C-style cast is far more dangerous than the named conversion
operators because the notation is harder to spot in a large program and the kind of conversion
intended by the programmer is not explicit. That is, (T)emight be doing a portable conversion
between related types, a nonportable conversion between unrelated types, or removing the const
modifier from a pointer type. Without knowing the exact types of Tand e, you cannot tell.
6.2.8 Constructors [expr.ctor]
The construction of a value of type Tfrom a value ecan be expressed by the functional notation
T(e). For example:
void f(double d)
{
int i= int(d) ; / / truncate d
complex z= complex(d) ; / / make a complex from d
/ / ...
}
The T(e) construct is sometimes referred to as a function-style cast. For a built-in type T, T(e) is
equivalent to static_cast<T>(e). Unfortunately, this implies that the use of T(e) is not always
safe. For arithmetic types, values can be truncated and even explicit conversion of a longer integer
type to a shorter (such as longto char) can result in undefined behavior. I try to use the notation
exclusively where the construction of a value is well-defined; that is, for narrowing arithmetic conversions (§C.6), for conversion from integers to enumerations (§4.8), and the construction of
objects of user-defined types (§2.5.2, §10.2.3).
Pointer conversions cannot be expressed directly using the T(e) notation. For example,
char*(2) is a syntax error. Unfortunately, the protection that the constructor notation provides
against such dangerous conversions can be circumvented by using typedefnames (§4.9.7) for
pointer types.
The constructor notation T() is used to express the default value of type T. For example:
void f(double d)
{
int j= int() ; / / default int value
complex z= complex() ; / / default complex value
/ / ...
}
The value of an explicit use of the constructor for a built-in type is 0converted to that type (§4.9.5).
Thus, int() is another way of writing 0. For a user-defined type T, T() is defined by the default
constructor (§10.4.2), if any.
The use of the constructor notation for built-in types is particularly important when writing templates. Then, the programmer does not know whether a template parameter will refer to a built-in
type or a user-defined type (§16.3.4, §17.4.1.2).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
132 Expressions and Statements Chapter 6
6.3 Statement Summary [expr.stmts]
Here are a summary and some examples of C++ statements: ______________________________________________________________
______________________________________________________________ Statement Syntax ______________________________________________________________
statement:
declaration
{ statement-listopt }
try{ statement-listopt } handler-list
expressionopt ;
if( condition ) statement
if( condition ) statement else statement
switch( condition ) statement
while( condition ) statement
do statement while( expression ) ;
for( for-init-statement conditionopt ; expressionopt ) statement
case constant-expression : statement
default: statement
break;
continue;
return expressionopt ;
goto identifier ;
identifier : statement
statement-list:
statement statement-listopt
condition:
expression
type-specifier declarator = expression
handler-list:
catch( exception-declaration ) { statement-listopt }
handler-list handler-list _ _____________________________________________________________ opt 




















































































Note that a declaration is a statement and that there is no assignment statement or procedure call
statement; assignments and function calls are expressions. The statements for handling exceptions,
try-blocks, are described in §8.3.1.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.3.1 Declarations as Statements 133
6.3.1 Declarations as Statements [expr.dcl]
A declaration is a statement. Unless a variable is declared static, its initializer is executed whenever the thread of control passes through the declaration (see also §10.4.8). The reason for allowing declarations wherever a statement can be used (and a few other places; §6.3.2.1, §6.3.3.1) is to
enable the programmer to minimize the errors caused by uninitialized variables and to allow better
locality in code. There is rarely a reason to introduce a variable before there is a value for it to
hold. For example:
void f(vector<string>& v, int i, const char* p)
{
if(p==0) return;
if(i<0|| v.size()<=i) error("bad index") ;
string s= v[i] ;
if(s== p) {
/ / ...
}
/ / ...
}
The ability to place declarations after executable code is essential for many constants and for
single-assignment styles of programming where a value of an object is not changed after initialization. For user-defined types, postponing the definition of a variable until a suitable initializer is
available can also lead to better performance. For example,
string s; /* ... */ s= "The best is the enemy of the good.";
can easily be much slower than
string s= "Voltaire";
The most common reason to declare a variable without an initializer is that it requires a statement
to initialize it. Examples are input variables and arrays.
6.3.2 Selection Statements [expr.select]
A value can be tested by either an ifstatement or a switchstatement:
if( condition ) statement
if ( condition ) statement else statement
switch ( condition ) statement
The comparison operators
== != < <= > >=
return the bool trueif the comparison is true and falseotherwise.
In an ifstatement, the first (or only) statement is executed if the expression is nonzero and the
second statement (if it is specified) is executed otherwise. This implies that any arithmetic or
pointer expression can be used as a condition. For example, if xis an integer, then
if(x) / / ...
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
134 Expressions and Statements Chapter 6
means
if(x!= 0) / / ...
For a pointer p,
if(p) / / ...
is a direct statement of the test ‘‘does ppoint to a valid object,’’ whereas
if(p!= 0) / / ...
states the same question indirectly by comparing to a value known not to point to an object. Note
that the representation of the pointer 0is not all-zeros on all machines (§5.1.1). Every compiler I
have checked generated the same code for both forms of the test.
The logical operators
&& || !
are most commonly used in conditions. The operators && and || will not evaluate their second
argument unless doing so is necessary. For example,
if(p&& 1<p->count) / / ...
first tests that pis nonzero. It tests 1<p->countonly if pis nonzero.
Some if-statements can conveniently be replaced by conditional-expressions. For example,
if(a<= b)
max= b;
else
max= a;
is better expressed like this:
max= (a<=b) ? b: a;
The parentheses around the condition are not necessary, but I find the code easier to read when they
are used.
A switch-statement can alternatively be written as a set of if-statements. For example,
switch(val) {
case 1:
f() ;
break;
case 2:
g() ;
break;
default:
h() ;
break;
}
could alternatively be expressed as
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.3.2 Selection Statements 135
if(val== 1)
f() ;
else if(val== 2)
g() ;
else
h() ;
The meaning is the same, but the first (switch) version is preferred because the nature of the operation (testing a value against a set of constants) is explicit. This makes the switchstatement easier
to read for nontrivial examples. It can also lead to the generation of better code.
Beware that a case of a switch must be terminated somehow unless you want to carry on executing the next case. Consider:
switch(val) { / / beware
case 1:
cout<< "case 1\n";
case 2:
cout<< "case 2\n";
default:
cout<< "default: case not found\n";
}
Invoked with val==1, this prints
case 1
case 2
default: case not found
to the great surprise of the uninitiated. It is a good idea to comment the (rare) cases in which a
fall-through is intentional so that an uncommented fall-through can be assumed to be an error. A
breakis the most common way of terminating a case, but a returnis often useful (§6.1.1).
6.3.2.1 Declarations in Conditions [expr.cond]
To avoid accidental misuse of a variable, it is usually a good idea to introduce the variable into the
smallest scope possible. In particular, it is usually best to delay the definition of a local variable
until one can give it an initial value. That way, one cannot get into trouble by using the variable
before its initial value is assigned.
One of the most elegant applications of these two principles is to declare a variable in a condition. Consider:
if(double d= prim(true)) {
left/= d;
break;
}
Here, dis declared and initialized and the value of dafter initialization is tested as the value of the
condition. The scope of dextends from its point of declaration to the end of the statement that the
condition controls. For example, had there been an else-branch to the if-statement, dwould be in
scope on both branches.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
136 Expressions and Statements Chapter 6
The obvious and traditional alternative is to declare dbefore the condition. However, this
opens the scope (literally) for the use of dbefore its initialization or after its intended useful life:
double d;
/ / ...
d2= d; / / oops!
/ / ...
if(d= prim(true)) {
left/= d;
break;
}
/ / ...
d= 2.0; / / two unrelated uses of d
In addition to the logical benefits of declaring variables in conditions, doing so also yields the most
compact source code.
A declaration in a condition must declare and initialize a single variable or const.
6.3.3 Iteration Statements [expr.loop]
A loop can be expressed as a for, while, or dostatement:
while( condition) statement
do statement while( expression) ;
for( for-init-statement conditionopt; expressionopt) statement
Each of these statements executes a statement (called the controlled statement or the body of the
loop) repeatedly until the condition becomes false or the programmer breaks out of the loop some
other way.
The for-statement is intended for expressing fairly regular loops. The loop variable, the termination condition, and the expression that updates the loop variable can be presented ‘‘up front’’ on
a single line. This can greatly increase readability and thereby decrease the frequency of errors. If
no initialization is needed, the initializing statement can be empty. If the condition is omitted, the
for-statement will loop forever unless the user explicitly exits it by a break, return, goto, throw, or
some less obvious way such as a call of exit() (§9.4.1.1). If the expression is omitted, we must
update some form of loop variable in the body of the loop. If the loop isn’t of the simple ‘‘introduce a loop variable, test the condition, update the loop variable’’ variety, it is often better
expressed as a while-statement. A for-statement is also useful for expressing a loop without an
explicit termination condition:
for(;;) { / / ‘‘forever’’
/ / ...
}
A while-statement simply executes its controlled statement until its condition becomes false. I tend
to prefer while-statements over for-statements when there isn’t an obvious loop variable or where
the update of a loop variable naturally comes in the middle of the loop body. An input loop is an
example of a loop where there is no obvious loop variable:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.3.3 Iteration Statements 137
while(cin>>ch) / / ...
In my experience, the do-statement is a source of errors and confusion. The reason is that its body
is always executed once before the condition is evaluated. However, for the body to work correctly, something very much like the condition must hold even the first time through. More often
than I would have guessed, I have found that condition not to hold as expected either when the program was first written and tested or later after the code preceding it has been modified. I also prefer
the condition ‘‘up front where I can see it.’’ Consequently, I tend to avoid do-statements.
6.3.3.1 Declarations in For-Statements [expr.for]
A variable can be declared in the initializer part of a for-statement. If that initializer is a declaration, the variable (or variables) it introduces is in scope until the end of the for-statement. For
example:
void f(int v[] , int max)
{
for(int i= 0; i<max; i++) v[i] = i*i;
}
If the final value of an index needs to be known after exit from a for-loop, the index variable must
be declared outside the for-loop (e.g., §6.3.4).
6.3.4 Goto [expr.goto]
C++ possesses the infamous goto:
goto identifier ;
identifier : statement
The gotohas few uses in general high-level programming, but it can be very useful when C++ code
is generated by a program rather than written directly by a person; for example, gotos can be used
in a parser generated from a grammar by a parser generator. The gotocan also be important in the
rare cases in which optimal efficiency is essential, for example, in the inner loop of some real-time
application.
One of the few sensible uses of gotoin ordinary code is to break out from a nested loop or
switch-statement (a breakbreaks out of only the innermost enclosing loop or switch-statement).
For example:
void f()
{
int i;
int j;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
138 Expressions and Statements Chapter 6
for(i= 0; i<n; i++)
for(j= 0; j<m; j++) if(nm[i][j] == a) goto found;
/ / not found
/ / ...
found:
/ / nm[i][j] == a
}
There is also a continuestatement that, in effect, goes to the end of a loop statement, as explained
in §6.1.5.
6.4 Comments and Indentation [expr.comment]
Judicious use of comments and consistent use of indentation can make the task of reading and
understanding a program much more pleasant. Several different consistent styles of indentation are
in use. I see no fundamental reason to prefer one over another (although, like most programmers, I
have my preferences, and this book reflects them). The same applies to styles of comments.
Comments can be misused in ways that seriously affect the readability of a program. The compiler does not understand the contents of a comment, so it has no way of ensuring that a comment
[1] is meaningful,
[2] describes the program, and
[3] is up to date.
Most programs contain comments that are incomprehensible, ambiguous, and just plain wrong.
Bad comments can be worse than no comments.
If something can be stated in the language itself, it should be, and not just mentioned in a comment. This remark is aimed at comments such as these:
/ / variable "v" must be initialized
/ / variable "v" must be used only by function "f()"
/ / call function "init()" before calling any other function in this file
/ / call function "cleanup()" at the end of your program
/ / don’t use function "weird()"
/ / function "f()" takes two arguments
Such comments can often be rendered unnecessary by proper use of C++. For example, one might
utilize the linkage rules (§9.2) and the visibility, initialization, and cleanup rules for classes (see
§10.4.1) to make the preceding examples redundant.
Once something has been stated clearly in the language, it should not be mentioned a second
time in a comment. For example:
a= b+c; / / a becomes b+c
count++; / / increment the counter
Such comments are worse than simply redundant. They increase the amount of text the reader has
to look at, they often obscure the structure of the program, and they may be wrong. Note, however,
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.4 Comments and Indentation 139
that such comments are used extensively for teaching purposes in programming language textbooks
such as this. This is one of the many ways a program in a textbook differs from a real program.
My preference is for:
[1] A comment for each source file stating what the declarations in it have in common, references to manuals, general hints for maintenance, etc.
[2] A comment for each class, template, and namespace
[3] A comment for each nontrivial function stating its purpose, the algorithm used (unless it is
obvious), and maybe something about the assumptions it makes about its environment
[4] A comment for each global and namespace variable and constant
[5] A few comments where the code is nonobvious and/or nonportable
[6] Very little else
For example:
/ / tbl.c: Implementation of the symbol table.
/*
Gaussian elimination with partial pivoting.
See Ralston: "A first course ..." pg 411.
*/
/ / swap() assumes the stack layout of an SGI R6000.
/***********************************
Copyright (c) 1997 AT&T, Inc.
All rights reserved
************************************/
A well-chosen and well-written set of comments is an essential part of a good program. Writing
good comments can be as difficult as writing the program itself. It is an art well worth cultivating.
Note also that if / / comments are used exclusively in a function, then any part of that function
can be commented out using /* */ style comments, and vice versa.
6.5 Advice [expr.advice]
[1] Prefer the standard library to other libraries and to ‘‘handcrafted code;’’ §6.1.8.
[2] Avoid complicated expressions; §6.2.3.
[3] If in doubt about operator precedence, parenthesize; §6.2.3.
[4] Avoid explicit type conversion (casts); §6.2.7.
[5] When explicit type conversion is necessary, prefer the more specific cast operators to the Cstyle cast; §6.2.7.
[6] Use the T(e) notation exclusively for well-defined construction; §6.2.8.
[7] Avoid expressions with undefined order of evaluation; §6.2.2.
[8] Avoid goto; §6.3.4.
[9] Avoid do-statements; §6.3.3.
[10] Don’t declare a variable until you have a value to initialize it with; §6.3.1, §6.3.2.1, §6.3.3.1.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
140 Expressions and Statements Chapter 6
[11] Keep comments crisp; §6.4.
[12] Maintain a consistent indentation style; §6.4.
[13] Prefer defining a member operator new() (§15.6) to replacing the global operator new();
§6.2.6.2.
[14] When reading input, always consider ill-formed input; §6.1.3.
6.6 Exercises [expr.exercises]
1. (∗1) Rewrite the following forstatement as an equivalent whilestatement:
for(i=0; i<max_length; i++) if(input_line[i] == ´?´) quest_count++;
Rewrite it to use a pointer as the controlled variable, that is, so that the test is of the form
*p==´?´.
2. (∗1) Fully parenthesize the following expressions:
a= b+ c* d<< 2& 8
a& 077!= 3
a== b|| a== c&& c< 5
c= x!= 0
0<= i< 7
f(1,2)+3
a= - 1+ + b-- - 5
a= b== c++
a= b= c= 0
a[4][2] *= * b? c: * d* 2
a-b,c=d
3. (∗2) Read a sequence of possibly whitespace-separated (name,value) pairs, where the name is a
single whitespace-separated word and the value is an integer or a floating-point value. Compute
and print the sum and mean for each name and the sum and mean for all names. Hint: §6.1.8.
4. (∗1) Write a table of values for the bitwise logical operations (§6.2.4) for all possible combinations of 0and 1operands.
5. (∗1.5) Find 5 different C++ constructs for which the meaning is undefined (§C.2). (∗1.5) Find 5
different C++ constructs for which the meaning is implementation-defined (§C.2).
6. (∗1) Find 10 different examples of nonportable C++ code.
7. (∗2) Write 5 expressions for which the order of evaluation is undefined. Execute them to see
what one or – preferably – more implementations do with them.
8. (∗1.5) What happens if you divide by zero on your system? What happens in case of overflow
and underflow?
9. (∗1) Fully parenthesize the following expressions:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 6.6 Exercises 141
*p++
*--p
++a--
(int*)p->m
*p.m
*a[i]
10. (*2) Write these functions: strlen(), which returns the length of a C-style string; strcpy(),
which copies a string into another; and strcmp(), which compares two strings. Consider what
the argument types and return types ought to be. Then compare your functions with the standard library versions as declared in <cstring> (<string.h>) and as specified in §20.4.1.
11. (∗1) See how your compiler reacts to these errors:
void f(int a, int b)
{
if(a= 3) / / ...
if(a&077== 0) / / ...
a:= b+1;
}
Devise more simple errors and see how the compiler reacts.
12. (∗2) Modify the program from §6.6[3] to also compute the median.
13. (∗2) Write a function cat() that takes two C-style string arguments and returns a string that is
the concatenation of the arguments. Use newto find store for the result.
14. (∗2) Write a function rev() that takes a string argument and reverses the characters in it. That
is, after rev(p) the last character of pwill be the first, etc.
15. (∗1.5) What does the following example do?
void send(int* to, int* from, int count)
/ / Duff’s device. Helpful comment deliberately deleted.
{
int n= (count+7)/8;
switch(count%8) {
case 0: do{ *to++ = *from++;
case 7: *to++ = *from++;
case 6: *to++ = *from++;
case 5: *to++ = *from++;
case 4: *to++ = *from++;
case 3: *to++ = *from++;
case 2: *to++ = *from++;
case 1: *to++ = *from++;
} while(--n>0) ;
}
}
Why would anyone write something like that?
16. (∗2) Write a function atoi(const char*) that takes a string containing digits and returns the
corresponding int. For example, atoi("123") is 123. Modify atoi() to handle C++ octal and
hexadecimal notation in addition to plain decimal numbers. Modify atoi() to handle the C++
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
142 Expressions and Statements Chapter 6
character constant notation.
17. (∗2) Write a function itoa(int i, char b[]) that creates a string representation of iin band
returns b.
18. (*2) Type in the calculator example and get it to work. Do not ‘‘save time’’ by using an already
entered text. You’ll learn most from finding and correcting ‘‘little silly errors.’’
19. (∗2) Modify the calculator to report line numbers for errors.
20. (∗3) Allow a user to define functions in the calculator. Hint: Define a function as a sequence of
operations just as a user would have typed them. Such a sequence can be stored either as a
character string or as a list of tokens. Then read and execute those operations when the function
is called. If you want a user-defined function to take arguments, you will have to invent a notation for that.
21. (∗1.5) Convert the desk calculator to use a symbolstructure instead of using the static variables
number_valueand string_value.
22. (∗2.5) Write a program that strips comments out of a C++ program. That is, read from cin,
remove both / / comments and /* */ comments, and write the result to cout. Do not worry
about making the layout of the output look nice (that would be another, and much harder, exercise). Do not worry about incorrect programs. Beware of / /, /*, and */ in comments, strings,
and character constants.
23. (∗2) Look at some programs to get an idea of the variety of indentation, naming, and commenting styles actually used.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
7 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
Functions
To iterate is human,
to recurse divine.
– L. Peter Deutsch
Function declarations and definitions — argument passing — return values — function
overloading — ambiguity resolution — default arguments — stdargs— pointers to
functions — macros — advice — exercises.
7.1 Function Declarations [fct.dcl]
The typical way of getting something done in a C++ program is to call a function to do it. Defining
a function is the way you specify how an operation is to be done. A function cannot be called
unless it has been previously declared.
A function declaration gives the name of the function, the type of the value returned (if any) by
the function, and the number and types of the arguments that must be supplied in a call of the function. For example:
Elem* next_elem() ;
char* strcpy(char* to, const char* from) ;
void exit(int) ;
The semantics of argument passing are identical to the semantics of initialization. Argument types
are checked and implicit argument type conversion takes place when necessary. For example:
double sqrt(double) ;
double sr2= sqrt(2) ; / / call sqrt() with the argument double(2)
double sq3= sqrt("three") ; / / error: sqrt() requires an argument of type double
The value of such checking and type conversion should not be underestimated.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
144 Functions Chapter 7
A function declaration may contain argument names. This can be a help to the reader of a program, but the compiler simply ignores such names. As mentioned in §4.7, voidas a return type
means that the function does not return a value.
7.1.1 Function Definitions [fct.def]
Every function that is called in a program must be defined somewhere (once only). A function definition is a function declaration in which the body of the function is presented. For example:
extern void swap(int*, int*) ; / / a declaration
void swap(int* p, int* q) / / a definition
{
int t= *p;
*p= *q;
*q= t;
}
The type of the definition and all declarations for a function must specify the same type. The argument names, however, are not part of the type and need not be identical.
It is not uncommon to have function definitions with unused arguments:
void search(table* t, const char* key, const char*)
{
/ / no use of the third argument
}
As shown, the fact that an argument is unused can be indicated by not naming it. Typically,
unnamed arguments arise from the simplification of code or from planning ahead for extensions. In
both cases, leaving the argument in place, although unused, ensures that callers are not affected by
the change.
A function can be defined to be inline. For example:
inline int fac(int n)
{
return(n<2) ? 1: n*fac(n-1) ;
}
The inlinespecifier is a hint to the compiler that it should attempt to generate code for a call of
fac() inline rather than laying down the code for the function once and then calling through the
usual function call mechanism. A clever compiler can generate the constant 720for a call fac(6).
The possibility of mutually recursive inline functions, inline functions that recurse or not depending
on input, etc., makes it impossible to guarantee that every call of an inlinefunction is actually
inlined. The degree of cleverness of a compiler cannot be legislated, so one compiler might generate 720, another 6*fac(5), and yet another an un-inlined call fac(6).
To make inlining possible in the absence of unusually clever compilation and linking facilities,
the definition – and not just the declaration – of an inline function must be in scope (§9.2). An
inlinespecifier does not affect the semantics of a function. In particular, an inline function still has
a unique address and so has staticvariables (§7.1.2) of an inline function.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 7.1.2 Static Variables 145
7.1.2 Static Variables [fct.static]
A local variable is initialized when the thread of execution reaches its definition. By default, this
happens in every call of the function and each invocation of the function has its own copy of the
variable. If a local variable is declared static, a single, statically allocated object will be used to
represent that variable in all calls of the function. It will be initialized only the first time the thread
of execution reaches its definition. For example:
void f(int a)
{
while(a--) {
static int n= 0; / / initialized once
int x= 0; / / initialized n times
cout<< "n== " << n++ << ", x== " << x++ << ´\n´;
}
}
int main()
{
f(3) ;
}
This prints:
n== 0, x== 0
n== 1, x== 0
n== 2, x== 0
A static variable provides a function with ‘‘a memory’’ without introducing a global variable that
might be accessed and corrupted by other functions (see also §10.2.4).
7.2 Argument Passing [fct.arg]
When a function is called, store is set aside for its formal arguments and each formal argument is
initialized by its corresponding actual argument. The semantics of argument passing are identical
to the semantics of initialization. In particular, the type of an actual argument is checked against
the type of the corresponding formal argument, and all standard and user-defined type conversions
are performed. There are special rules for passing arrays (§7.2.1), a facility for passing unchecked
arguments (§7.6), and a facility for specifying default arguments (§7.5). Consider:
void f(int val, int& ref)
{
val++;
ref++;
}
When f() is called, val++ increments a local copy of the first actual argument, whereas ref++
increments the second actual argument. For example,
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
146 Functions Chapter 7
void g()
{
int i= 1;
int j= 1;
f(i,j) ;
}
will increment jbut not i. The first argument, i, is passed by value, the second argument, j, is
passed by reference. As mentioned in §5.5, functions that modify call-by-reference arguments can
make programs hard to read and should most often be avoided (but see §21.2.1). It can, however,
be noticeably more efficient to pass a large object by reference than to pass it by value. In that
case, the argument might be declared constto indicate that the reference is used for efficiency reasons only and not to enable the called function to change the value of the object:
void f(const Large& arg)
{
/ / the value of "arg" cannot be changed without explicit use of type conversion
}
The absence of constin the declaration of a reference argument is taken as a statement of intent to
modify the variable:
void g(Large& arg) ; / / assume that g() modifies arg
Similarly, declaring a pointer argument consttells readers that the value of an object pointed to by
that argument is not changed by the function. For example:
int strlen(const char*) ; / / number of characters in a C-style string
char* strcpy(char* to, const char* from) ; / / copy a C-style string
int strcmp(const char*, const char*) ; / / compare C-style strings
The importance of using constarguments increases with the size of a program.
Note that the semantics of argument passing are different from the semantics of assignment.
This is important for constarguments, reference arguments, and arguments of some user-defined
types (§10.4.4.1).
A literal, a constant, and an argument that requires conversion can be passed as a const& argument, but not as a non-constargument. Allowing conversions for a const T& argument ensures that
such an argument can be given exactly the same set of values as a Targument by passing the value
in a temporary, if necessary. For example:
float fsqrt(const float&) ; / / Fortran-style sqrt taking a reference argument
void g(double d)
{
float r= fsqrt(2.0f) ; / / pass ref to temp holding 2.0f
r= fsqrt(r) ; / / pass ref to r
r= fsqrt(d) ; / / pass ref to temp holding float(d)
}
Disallowing conversions for non-constreference arguments (§5.5) avoids the possibility of silly
mistakes arising from the introduction of temporaries. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 7.2 Argument Passing 147
void update(float& i) ;
void g(double d, float r)
{
update(2.0f) ; / / error: const argument
update(r) ; / / pass ref to r
update(d) ; / / error: type conversion required
}
Had these calls been allowed, update() would quietly have updated temporaries that immediately
were deleted. Usually, that would come as an unpleasant surprise to the programmer.
7.2.1 Array Arguments [fct.array]
If an array is used as a function argument, a pointer to its initial element is passed. For example:
int strlen(const char*) ;
void f()
{
char v[] = "an array";
int i= strlen(v) ;
int j= strlen("Nicholas") ;
}
That is, an argument of type T[] will be converted to a T* when passed as an argument. This
implies that an assignment to an element of an array argument changes the value of an element of
the argument array. In other words, arrays differ from other types in that an array is not (and cannot be) passed by value.
The size of an array is not available to the called function. This can be a nuisance, but there are
several ways of circumventing this problem. C-style strings are zero-terminated, so their size can
be computed easily. For other arrays, a second argument specifying the size can be passed. For
example:
void compute1(int* vec_ptr, int vec_size) ; / / one way
struct Vec{
int* ptr;
int size;
};
void compute2(const Vec& v) ; / / another way
Alternatively, a type such as vector(§3.7.1, §16.3) can be used instead of an array.
Multidimensional arrays are trickier (see §C.7), but often arrays of pointers can be used instead,
and they need no special treatment. For example:
char* day[] = {
"mon", "tue", "wed", "thu", "fri", "sat", "sun"
};
Again, vectorand similar types are alternatives to the built-in, low-level arrays and pointers.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
148 Functions Chapter 7
7.3 Value Return [fct.return]
A value must be returned from a function that is not declared void(however, main() is special; see
§3.2). Conversely, a value cannot be returned from a voidfunction. For example:
int f1() { } / / error: no value returned
void f2() { } / / ok
int f3() { return 1; } / / ok
void f4() { return 1; } / / error: return value in void function
int f5() { return; } / / error: return value missing
void f6() { return; } / / ok
A return value is specified by a return statement. For example:
int fac(int n) { return(n>1) ? n*fac(n-1) : 1; }
A function that calls itself is said to be recursive.
There can be more than one return statement in a function:
int fac2(int n)
{
if(n> 1) return n*fac2(n-1) ;
return 1;
}
Like the semantics of argument passing, the semantics of function value return are identical to the
semantics of initialization. A return statement is considered to initialize an unnamed variable of the
returned type. The type of a return expression is checked against the type of the returned type, and
all standard and user-defined type conversions are performed. For example:
double f() { return 1; } / / 1 is implicitly converted to double(1)
Each time a function is called, a new copy of its arguments and local (automatic) variables is created. The store is reused after the function returns, so a pointer to a local variable should never be
returned. The contents of the location pointed to will change unpredictably:
int* fp() { int local= 1; /* ... */ return&local; } / / bad
This error is less common than the equivalent error using references:
int& fr() { int local= 1; /* ... */ return local; } / / bad
Fortunately, a compiler can easily warn about returning references to local variables.
A voidfunction cannot return a value. However, a call of a voidfunction doesn’t yield a value,
so a voidfunction can use a call of a voidfunction as the expression in a returnstatement. For
example:
void g(int* p) ;
void h(int* p) { /* ... */ return g(p) ; } / / ok: return of ‘‘no value’’
This form of return is important when writing template functions where the return type is a template parameter (see §18.4.4.2).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 7.4 Overloaded Function Names 149
7.4 Overloaded Function Names [fct.over]
Most often, it is a good idea to give different functions different names, but when some functions
conceptually perform the same task on objects of different types, it can be more convenient to give
them the same name. Using the same name for operations on different types is called overloading.
The technique is already used for the basic operations in C++. That is, there is only one name for
addition, +, yet it can be used to add values of integer, floating-point, and pointer types. This idea
is easily extended to functions defined by the programmer. For example:
void print(int) ; / / print an int
void print(const char*) ; / / print a C-style character string
As far as the compiler is concerned, the only thing functions of the same name have in common is
that name. Presumably, the functions are in some sense similar, but the language does not constrain or aid the programmer. Thus overloaded function names are primarily a notational convenience. This convenience is significant for functions with conventional names such as sqrt, print,
and open. When a name is semantically significant, this convenience becomes essential. This happens, for example, with operators such as +, *, and <<, in the case of constructors (§11.7), and in
generic programming (§2.7.2, Chapter 18). When a function fis called, the compiler must figure
out which of the functions with the name fis to be invoked. This is done by comparing the types of
the actual arguments with the types of the formal arguments of all functions called f. The idea is to
invoke the function that is the best match on the arguments and give a compile-time error if no
function is the best match. For example:
void print(double) ;
void print(long) ;
void f()
{
print(1L) ; / / print(long)
print(1.0) ; / / print(double)
print(1) ; / / error, ambiguous: print(long(1)) or print(double(1))?
}
Finding the right version to call from a set of overloaded functions is done by looking for a best
match between the type of the argument expression and the parameters (formal arguments) of the
functions. To approximate our notions of what is reasonable, a series of criteria are tried in order:
[1] Exact match; that is, match using no or only trivial conversions (for example, array name to
pointer, function name to pointer to function, and Tto const T)
[2] Match using promotions; that is, integral promotions (boolto int, charto int, shortto int,
and their unsignedcounterparts; §C.6.1), floatto double, and doubleto long double
[3] Match using standard conversions (for example, intto double, doubleto int, Derived* to
Base* (§12.2), T* to void* (§5.6), intto unsigned int; §C.6)
[4] Match using user-defined conversions (§11.4)
[5] Match using the ellipsis ... in a function declaration (§7.6)
If two matches are found at the highest level where a match is found, the call is rejected as ambiguous. The resolution rules are this elaborate primarily to take into account the elaborate C and C++
rules for built-in numeric types (§C.6). For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
150 Functions Chapter 7
void print(int) ;
void print(const char*) ;
void print(double) ;
void print(long) ;
void print(char) ;
void h(char c, int i, short s, float f)
{
print(c) ; / / exact match: invoke print(char)
print(i) ; / / exact match: invoke print(int)
print(s) ; / / integral promotion: invoke print(int)
print(f) ; / / float to double promotion: print(double)
print(´a´) ; / / exact match: invoke print(char)
print(49) ; / / exact match: invoke print(int)
print(0) ; / / exact match: invoke print(int)
print("a") ; / / exact match: invoke print(const char*)
}
The call print(0) invokes print(int) because 0is an int. The call print(´a´) invokes
print(char) because ´a´ is a char(§4.3.1). The reason to distinguish between conversions and
promotions is that we want to prefer safe promotions, such as charto int, over unsafe conversions,
such as intto char.
The overloading resolution is independent of the order of declaration of the functions considered.
Overloading relies on a relatively complicated set of rules, and occasionally a programmer will
be surprised which function is called. So, why bother? Consider the alternative to overloading.
Often, we need similar operations performed on objects of several types. Without overloading, we
must define several functions with different names:
void print_int(int) ;
void print_char(char) ;
void print_string(const char*) ; / / C-style string
void g(int i, char c, const char* p, double d)
{
print_int(i) ; / / ok
print_char(c) ; / / ok
print_string(p) ; / / ok
print_int(c) ; / / ok? calls print_int(int(c))
print_char(i) ; / / ok? calls print_char(char(i))
print_string(i) ; / / error
print_int(d) ; / / ok? calls print_int(int(d))
}
Compared to the overloaded print(), we have to remember several names and remember to use
those correctly. This can be tedious, defeats attempts to do generic programming (§2.7.2), and generally encourages the programmer to focus on relatively low-level type issues. Because there is no
overloading, all standard conversions apply to arguments to these functions. It can also lead to
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 7.4 Overloaded Function Names 151
errors. In the previous example, this implies that only one of the four calls with a ‘‘wrong’’ argument is caught by the compiler. Thus, overloading can increase the chances that an unsuitable
argument will be rejected by the compiler.
7.4.1 Overloading and Return Type [fct.return]
Return types are not considered in overload resolution. The reason is to keep resolution for an individual operator (§11.2.1, §11.2.4) or function call context-independent. Consider:
float sqrt(float) ;
double sqrt(double) ;
void f(double da, float fla)
{
float fl= sqrt(da) ; / / call sqrt(double)
double d= sqrt(da) ; / / call sqrt(double)
fl= sqrt(fla) ; / / call sqrt(float)
d= sqrt(fla) ; / / call sqrt(float)
}
If the return type were taken into account, it would no longer be possible to look at a call of sqrt()
in isolation and determine which function was called.
7.4.2 Overloading and Scopes [fct.scope]
Functions declared in different non-namespace scopes do not overload. For example:
void f(int) ;
void g()
{
void f(double) ;
f(1) ; / / call f(double)
}
Clearly, f(int) would have been the best match for f(1), but only f(double) is in scope. In such
cases, local declarations can be added or subtracted to get the desired behavior. As always, intentional hiding can be a useful technique, but unintentional hiding is a source of surprises. When
overloading across class scopes (§15.2.2) or namespace scopes (§8.2.9.2) is wanted, usingdeclarations or using-directivescan be used (§8.2.2). See also §8.2.6 and §8.2.9.2.
7.4.3 Manual Ambiguity Resolution [fct.man.ambig]
Declaring too few (or too many) overloaded versions of a function can lead to ambiguities. For
example:
void f1(char) ;
void f1(long) ;
void f2(char*) ;
void f2(int*) ;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
152 Functions Chapter 7
void k(int i)
{
f1(i) ; / / ambiguous: f1(char) or f1(long)
f2(0) ; / / ambiguous: f2(char*) or f2(int*)
}
Where possible, the thing to do in such cases is to consider the set of overloaded versions of a function as a whole and see if it makes sense according to the semantics of the function. Often the
problem can be solved by adding a version that resolves ambiguities. For example, adding
inline void f1(int n) { f1(long(n)) ; }
would resolve all ambiguities similar to f1(i) in favor of the larger type long int.
One can also add an explicit type conversion to resolve a specific call. For example:
f2(static_cast<int*>(0)) ;
However, this is most often simply an ugly stopgap. Soon another similar call will be made and
have to be dealt with.
Some C++ novices get irritated by the ambiguity errors reported by the compiler. More experienced programmers appreciate these error messages as useful indicators of design errors.
7.4.4 Resolution for Multiple Arguments [fct.fct.res]
Given the overload resolution rules, one can ensure that the simplest algorithm (function) will be
used when the efficiency or precision of computations differs significantly for the types involved.
For example:
int pow(int, int) ;
double pow(double, double) ;
complex pow(double, complex) ;
complex pow(complex, int) ;
complex pow(complex, double) ;
complex pow(complex, complex) ;
void k(complex z)
{
int i= pow(2,2) ; / / invoke pow(int,int)
double d= pow(2.0,2.0) ; / / invoke pow(double,double)
complex z2= pow(2,z) ; / / invoke pow(double,complex)
complex z3= pow(z,2) ; / / invoke pow(complex,int)
complex z4= pow(z,z) ; / / invoke pow(complex,complex)
}
In the process of choosing among overloaded functions with two or more arguments, a best match
is found for each argument using the rules from §7.4. A function that is the best match for one
argument and a better than or equal match for all other arguments is called. If no such function
exists, the call is rejected as ambiguous. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 7.4.4 Resolution for Multiple Arguments 153
void g()
{
double d= pow(2.0,2) ; / / error: pow(int(2.0),2) or pow(2.0,double(2))?
}
The call is ambiguous because 2.0is the best match for the first argument of
pow(double,double) and 2is the best match for the second argument of pow(int,int).
7.5 Default Arguments [fct.defarg]
A general function often needs more arguments than are necessary to handle simple cases. In particular, functions that construct objects (§10.2.3) often provide several options for flexibility. Consider a function for printing an integer. Giving the user an option of what base to print it in seems
reasonable, but in most programs integers will be printed as decimal integer values. For example:
void print(int value, int base=10) ; / / default base is 10
void f()
{
print(31) ;
print(31,10) ;
print(31,16) ;
print(31,2) ;
}
might produce this output:
31 31 1f 11111
The effect of a default argument can alternatively be achieved by overloading:
void print(int value, int base) ;
inline void print(int value) { print(value,10) ; }
However, overloading makes it less obvious to the reader that the intent is to have a single print
function plus a shorthand.
A default argument is type checked at the time of the function declaration and evaluated at the
time of the call. Default arguments may be provided for trailing arguments only. For example:
int f(int, int=0, char* =0) ; / / ok
int g(int=0, int=0, char*) ; / / error
int h(int=0, int, char* =0) ; / / error
Note that the space between the * and the = is significant (*= is an assignment operator; §6.2):
int nasty(char*=0) ; / / syntax error
A default argument can be repeated in a subsequent declaration in the same scope but not changed.
For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
154 Functions Chapter 7
void f(int x= 7) ;
void f(int= 7) ; / / ok
void f(int= 8) ; / / error: different default arguments
void g()
{
void f(int x= 9) ; / / ok: this declaration hides the outer one
/ / ...
}
Declaring a name in a nested scope so that the name hides a declaration of the same name in an
outer scope is error prone.
7.6 Unspecified Number of Arguments [fct.stdarg]
For some functions, it is not possible to specify the number and type of all arguments expected in a
call. Such a function is declared by terminating the list of argument declarations with the ellipsis
(...), which means ‘‘and maybe some more arguments.’’ For example:
int printf(const char* ...) ;
This specifies that a call of the C standard library function printf() (§21.8) must have at least one
argument, a char*, but may or may not have others. For example:
printf("Hello, world!\n") ;
printf("My name is%s%s\n", first_name, second_name) ;
printf("%d+ %d= %d\n",2,3,5) ;
Such a function must rely on information not available to the compiler when interpreting its argument list. In the case of printf(), the first argument is a format string containing special character
sequences that allow printf() to handle other arguments correctly; %smeans ‘‘expect a char*
argument’’ and %dmeans ‘‘expect an intargument.’’ However, the compiler cannot in general
know that, so it cannot ensure that the expected arguments are really there or that an argument is of
the proper type. For example,
#include<stdio.h>
int main()
{
printf("My name is%s%s\n",2) ;
}
will compile and (at best) cause some strange-looking output (try it!).
Clearly, if an argument has not been declared, the compiler does not have the information
needed to perform the standard type checking and type conversion for it. In that case, a charor a
shortis passed as an intand a floatis passed as a double. This is not necessarily what the programmer expects.
A well-designed program needs at most a few functions for which the argument types are not
completely specified. Overloaded functions and functions using default arguments can be used to
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 7.6 Unspecified Number of Arguments 155
take care of type checking in most cases when one would otherwise consider leaving argument
types unspecified. Only when both the number of arguments and the type of arguments vary is the
ellipsis necessary. The most common use of the ellipsis is to specify an interface to C library functions that were defined before C++ provided alternatives:
int fprintf(FILE*, const char* ...) ; / / from <cstdio>
int execl(const char* ...) ; / / from UNIX header
A standard set of macros for accessing the unspecified arguments in such functions can be found in
<cstdarg>. Consider writing an error function that takes one integer argument indicating the
severity of the error followed by an arbitrary number of strings. The idea is to compose the error
message by passing each word as a separate string argument. The list of string arguments should
be terminated by a null pointer to char:
extern void error(int...) ;
extern char* itoa(int, char[]) ; / / see §6.6[17]
const char* Null_cp= 0;
int main(int argc, char* argv[])
{
switch(argc) {
case 1:
error(0,argv[0] ,Null_cp) ;
break;
case 2:
error(0,argv[0] ,argv[1] ,Null_cp) ;
break;
default:
char buffer[8] ;
error(1,argv[0] , "with",itoa(argc-1,buffer) ,"arguments", Null_cp) ;
}
/ / ...
}
The function itoa() returns the character string representing its integer argument.
Note that using the integer 0as the terminator would not have been portable: on some implementations, the integer zero and the null pointer do not have the same representation. This illustrates the subtleties and extra work that face the programmer once type checking has been suppressed using the ellipsis.
The error function could be defined like this:
void error(int severity...) / / "severity" followed by a zero-terminated list of char*s
{
va_list ap;
va_start(ap,severity) ; / / arg startup
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
156 Functions Chapter 7
for(;;) {
char* p= va_arg(ap,char*) ;
if(p== 0) break;
cerr<< p<< ´ ´;
}
va_end(ap) ; / / arg cleanup
cerr<< ´\n´;
if(severity) exit(severity) ;
}
First, a va_listis defined and initialized by a call of va_start(). The macro va_starttakes the
name of the va_listand the name of the last formal argument as arguments. The macro va_arg()
is used to pick the unnamed arguments in order. In each call, the programmer must supply a type;
va_arg() assumes that an actual argument of that type has been passed, but it typically has no way
of ensuring that. Before returning from a function in which va_start() has been used, va_end()
must be called. The reason is that va_start() may modify the stack in such a way that a return
cannot successfully be done; va_end() undoes any such modifications.
7.7 Pointer to Function [fct.pf]
There are only two things one can do to a function: call it and take its address. The pointer
obtained by taking the address of a function can then be used to call the function. For example:
void error(string s) { /* ... */ }
void(*efct)(string) ; / / pointer to function
void f()
{
efct= &error; / / efct points to error
efct("error") ; / / call error through efct
}
The compiler will discover that efctis a pointer and call the function pointed to. That is, dereferencing of a pointer to function using * is optional. Similarly, using & to get the address of a function is optional:
void(*f1)(string) = &error; / / ok
void(*f2)(string) = error; / / also ok; same meaning as &error
void g()
{
f1("Vasa") ; / / ok
(*f1)("Mary Rose") ; / / also ok
}
Pointers to functions have argument types declared just like the functions themselves. In pointer
assignments, the complete function type must match exactly. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 7.7 Pointer to Function 157
void(*pf)(string) ; / / pointer to void(string)
void f1(string) ; / / void(string)
int f2(string) ; / / int(string)
void f3(int*) ; / / void(int*)
void f()
{
pf= &f1; / / ok
pf= &f2; / / error: bad return type
pf= &f3; / / error: bad argument type
pf("Hera") ; / / ok
pf(1) ; / / error: bad argument type
int i= pf("Zeus") ; / / error: void assigned to int
}
The rules for argument passing are the same for calls directly to a function and for calls to a function through a pointer.
It is often convenient to define a name for a pointer-to-function type to avoid using the somewhat nonobvious declaration syntax all the time. Here is an example from a UNIX system header:
typedef void(*SIG_TYP)(int) ; / / from <signal.h>
typedef void(*SIG_ARG_TYP)(int) ;
SIG_TYP signal(int, SIG_ARG_TYP) ;
An array of pointers to functions is often useful. For example, the menu system for my mousebased editor is implemented using arrays of pointers to functions to represent operations. The system cannot be described in detail here, but this is the general idea:
typedef void(*PF)() ;
PF edit_ops[] = { / / edit operations
&cut, &paste, &copy, &search
};
PF file_ops[] = { / / file management
&open, &append, &close, &write
};
We can then define and initialize the pointers that control actions selected from a menu associated
with the mouse buttons:
PF* button2= edit_ops;
PF* button3= file_ops;
In a complete implementation, more information is needed to define each menu item. For example,
a string specifying the text to be displayed must be stored somewhere. As the system is used, the
meaning of mouse buttons changes frequently with the context. Such changes are performed
(partly) by changing the value of the button pointers. When a user selects a menu item, such as
item 3 for button 2, the associated operation is executed:
button2[2]() ; / / call button2’s 3rd function
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
158 Functions Chapter 7
One way to gain appreciation of the expressive power of pointers to functions is to try to write such
code without them – and without using their better-behaved cousins, the virtual functions
(§12.2.6). A menu can be modified at run-time by inserting new functions into the operator table.
It is also easy to construct new menus at run-time.
Pointers to functions can be used to provide a simple form of polymorphic routines, that is, routines that can be applied to objects of many different types:
typedef int(*CFT)(const void*, const void*) ;
void ssort(void* base, size_t n, size_t sz, CFT cmp)
/*
Sort the "n" elements of vector "base" into increasing order
using the comparison function pointed to by "cmp".
The elements are of size "sz".
Shell sort (Knuth, Vol3, pg84)
*/
{
for(int gap=n/2; 0<gap; gap/=2)
for(int i=gap; i<n; i++)
for(int j=i-gap; 0<=j; j-=gap) {
char* b= static_cast<char*>(base) ; / / necessary cast
char* pj= b+j*sz; / / &base[j]
char* pjg= b+(j+gap)*sz; / / &base[j+gap]
if(cmp(pj,pjg)<0) { / / swap base[j] and base[j+gap]:
for(int k=0; k<sz; k++) {
char temp= pj[k] ;
pj[k] = pjg[k] ;
pjg[k] = temp;
}
}
}
}
The ssort() routine does not know the type of the objects it sorts, only the number of elements (the
array size), the size of each element, and the function to call to perform a comparison. The type of
ssort() was chosen to be the same as the type of the standard C library sort routine, qsort(). Real
programs use qsort(), the C++ standard library algorithm sort(§18.7.1), or a specialized sort routine. This style of code is common in C, but it is not the most elegant way of expressing this algorithm in C++ (see §13.3, §13.5.2).
Such a sort function could be used to sort a table such as this:
struct User{
char* name;
char* id;
int dept;
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 7.7 Pointer to Function 159
User heads[] = {
"Ritchie D.M", "dmr", 11271,
"Sethi R.", "ravi", 11272,
"Szymanski T.G.", "tgs", 11273,
"Schryer N.L.", "nls", 11274,
"Schryer N.L.", "nls", 11275,
"Kernighan B.W.", "bwk", 11276
};
void print_id(User* v, int n)
{
for(int i=0; i<n; i++)
cout<< v[i].name<< ´\t´ << v[i].id<< ´\t´ << v[i].dept<< ´\n´;
}
To be able to sort, we must first define appropriate comparison functions. A comparison function
must return a negative value if its first argument is less than the second, zero if the arguments are
equal, and a positive number otherwise:
int cmp1(const void* p, const void* q) / / Compare name strings
{
return strcmp(static_cast<const User*>(p)->name,static_cast<const User*>(q)->name) ;
}
int cmp2(const void* p, const void* q) / / Compare dept numbers
{
return static_cast<const User*>(p)->dept- static_cast<const User*>(q)->dept;
}
This program sorts and prints:
int main()
{
cout<< "Heads in alphabetical order:\n";
ssort(heads,6,sizeof(User) ,cmp1) ;
print_id(heads,6) ;
cout<< "\n";
cout<< "Heads in order of department number:\n";
ssort(heads,6,sizeof(User) ,cmp2) ;
print_id(heads,6) ;
}
You can take the address of an overloaded function by assigning to or initializing a pointer to function. In that case, the type of the target is used to select from the set of overloaded functions. For
example:
void f(int) ;
int f(char) ;
void(*pf1)(int) = &f; / / void f(int)
int(*pf2)(char) = &f; / / int f(char)
void(*pf3)(char) = &f; / / error: no void f(char)
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
160 Functions Chapter 7
A function must be called through a pointer to function with exactly the right argument and return
types. There is no implicit conversion of argument or return types when pointers to functions are
assigned or initialized. This means that
int cmp3(const mytype*,const mytype*) ;
is not a suitable argument for ssort(). The reason is that accepting cmp3as an argument to
ssort() would violate the guarantee that cmp3will be called with arguments of type mytype* (see
also §9.2.5).
7.8 Macros [fct.macro]
Macros are very important in C but have far fewer uses in C++. The first rule about macros is:
Don’t use them unless you have to. Almost every macro demonstrates a flaw in the programming
language, in the program, or in the programmer. Because they rearrange the program text before
the compiler proper sees it, macros are also a major problem for many programming tools. So
when you use macros, you should expect inferior service from tools such as debuggers, crossreference tools, and profilers. If you must use macros, please read the reference manual for your
own implementation of the C++ preprocessor carefully and try not to be too clever. Also to warn
readers, follow the convention to name macros using lots of capital letters. The syntax of macros is
presented in §A.11.
A simple macro is defined like this:
#define NAME rest of line
Where NAMEis encountered as a token, it is replaced by rest of line. For example,
named= NAME
will expand into
named= rest of line
A macro can also be defined to take arguments. For example:
#define MAC(x,y) argument1: x argument2: y
When MACis used, two argument strings must be presented. They will replace xand ywhen
MAC() is expanded. For example,
expanded= MAC(foo bar, yuk yuk)
will be expanded into
expanded= argument1: foo bar argument2: yuk yuk
Macro names cannot be overloaded, and the macro preprocessor cannot handle recursive calls:
#define PRINT(a,b) cout<<(a)<<(b)
#define PRINT(a,b,c) cout<<(a)<<(b)<<(c) /* trouble?: redefines, does not overload */
#define FAC(n) (n>1)?n*FAC(n-1):1/* trouble: recursive macro */
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 7.8 Macros 161
Macros manipulate character strings and know little about C++ syntax and nothing about C++ types
or scope rules. Only the expanded form of a macro is seen by the compiler, so an error in a macro
will be reported when the macro is expanded, not when it is defined. This leads to very obscure
error messages.
Here are some plausible macros:
#define CASE break;case
#define FOREVER for(;;)
Here are some completely unnecessary macros:
#define PI 3.141593
#define BEGIN{
#define END}
Here are some dangerous macros:
#define SQUARE(a) a*a
#define INCR_xx(xx)++
To see why they are dangerous, try expanding this:
int xx= 0; / / global counter
void f()
{
int xx= 0; / / local variable
int y= SQUARE(xx+2) ; / / y=xx+2*xx+2; that is y=xx+(2*xx)+2
INCR_xx; / / increments local xx
}
If you must use a macro, use the scope resolution operator : : when referring to global names
(§4.9.4) and enclose occurrences of a macro argument name in parentheses whenever possible. For
example:
#define MIN(a,b) (((a)<(b))?(a):(b))
If you must write macros complicated enough to require comments, it is wise to use /* */ comments because C preprocessors that do not know about / / comments are sometimes used as part of
C++ tools. For example:
#define M2(a) something(a) /* thoughtful comment */
Using macros, you can design your own private language. Even if you prefer this ‘‘enhanced language’’ to plain C++, it will be incomprehensible to most C++ programmers. Furthermore, the C
preprocessor is a very simple macro processor. When you try to do something nontrivial, you are
likely to find it either impossible or unnecessarily hard to do. The const, inline, template, and
namespacemechanisms are intended as alternatives to many traditional uses of preprocessor constructs. For example:
const int answer= 42;
template<class T> inline T min(T a, T b) { return(a<b)?a:b; }
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
162 Functions Chapter 7
When writing a macro, it is not unusual to need a new name for something. A string can be created
by concatenating two strings using the ## macro operator. For example,
#define NAME2(a,b) a##b
int NAME2(hack,cah)() ;
will produce
int hackcah() ;
for the compiler to read.
The directive
#undef X
ensures that no macro called Xis defined – whether or not one was before the directive. This
affords some protection against undesired macros. However, it is not always easy to know what the
effects of Xon a piece of code were supposed to be.
7.8.1 Conditional Compilation [fct.cond]
One use of macros is almost impossible to avoid. The directive #ifdef identifierconditionally
causes all input to be ignored until a #endifdirective is seen. For example,
int f(int a
#ifdef arg_two
,int b
#endif
) ;
produces
int f(int a
) ;
for the compiler to see unless a macro called arg_twohas been #defined. This example confuses
tools that assume sane behavior from the programmer.
Most uses of #ifdefare less bizarre, and when used with restraint, #ifdefdoes little harm. See
also §9.3.3.
Names of the macros used to control #ifdefshould be chosen carefully so that they don’t clash
with ordinary identifiers. For example:
struct Call_info{
Node* arg_one;
Node* arg_two;
/ / ...
};
This innocent-looking source text will cause some confusion should someone write:
#define arg_two x
Unfortunately, common and unavoidable headers contain many dangerous and unnecessary macros.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 7.9 Advice 163
7.9 Advice [dcl.advice]
[1] Be suspicious of non-constreference arguments; if you want the function to modify its arguments, use pointers and value return instead; §5.5.
[2] Use constreference arguments when you need to minimize copying of arguments; §5.5.
[3] Use constextensively and consistently; §7.2.
[4] Avoid macros; §7.8.
[5] Avoid unspecified numbers of arguments; §7.6.
[6] Don’t return pointers or references to local variables; §7.3.
[7] Use overloading when functions perform conceptually the same task on different types; §7.4.
[8] When overloading on integers, provide functions to eliminate common ambiguities; §7.4.3.
[9] When considering the use of a pointer to function, consider whether a virtual function
(§2.5.5) or a template (§2.7.2) would be a better alternative; §7.7.
[10] If you must use macros, use ugly names with lots of capital letters; §7.8.
7.10 Exercises [fct.exercises]
1. (∗1) Write declarations for the following: a function taking arguments of type pointer to character and reference to integer and returning no value; a pointer to such a function; a function taking such a pointer as an argument; and a function returning such a pointer. Write the definition
of a function that takes such a pointer as an argument and returns its argument as the return
value. Hint: Use typedef.
2. (∗1) What does the following mean? What would it be good for?
typedef int(&rifii) (int, int) ;
3. (∗1.5) Write a program like ‘‘Hello, world!’’ that takes a name as a command-line argument
and writes ‘‘Hello, name !’’. Modify this program to take any number of names as arguments
and to say hello to each.
4. (∗1.5) Write a program that reads an arbitrary number of files whose names are given as
command-line arguments and writes them one after another on cout. Because this program
concatenates its arguments to produce its output, you might call it cat.
5. (∗2) Convert a small C program to C++. Modify the header files to declare all functions called
and to declare the type of every argument. Where possible, replace #defines with enum, const,
or inline. Remove externdeclarations from .cfiles and if necessary convert all function definitions to C++ function definition syntax. Replace calls of malloc() and free() with newand
delete. Remove unnecessary casts.
6. (∗2) Implement ssort() (§7.7) using a more efficient sorting algorithm. Hint: qsort().
7. (∗2.5) Consider:
struct Tnode{
string word;
int count;
Tnode* left;
Tnode* right;
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
164 Functions Chapter 7
Write a function for entering new words into a tree of Tnodes. Write a function to write out a
tree of Tnodes. Write a function to write out a tree of Tnodes with the words in alphabetical
order. Modify Tnodeso that it stores (only) a pointer to an arbitrarily long word stored as an
array of characters on free store using new. Modify the functions to use the new definition of
Tnode.
8. (∗2.5) Write a function to invert a two-dimensional array. Hint: §C.7.
9. (∗2) Write an encryption program that reads from cinand writes the encoded characters to cout.
You might use this simple encryption scheme: the encrypted form of a character cis c^key[i],
where keyis a string passed as a command-line argument. The program uses the characters in
keyin a cyclic manner until all the input has been read. Re-encrypting encoded text with the
same key produces the original text. If no key (or a null string) is passed, then no encryption is
done.
10. (∗3.5) Write a program to help decipher messages encrypted with the method described in
§7.10[9] without knowing the key. Hint: See David Kahn: The Codebreakers, Macmillan,
1967, New York, pp. 207-213.
11. (∗3) Write an errorfunction that takes a printf-style format string containing %s, %c, and %d
directives and an arbitrary number of arguments. Don’t use printf(). Look at §21.8 if you
don’t know the meaning of %s, %c, and %d. Use <cstdarg>.
12. (∗1) How would you choose names for pointer to function types defined using typedef?
13. (∗2) Look at some programs to get an idea of the diversity of styles of names actually used.
How are uppercase letters used? How is the underscore used? When are short names such as i
and xused?
14. (∗1) What is wrong with these macro definitions?
#define PI= 3.141593;
#define MAX(a,b) a>b?a:b
#define fac(a) (a)*fac((a)-1)
15. (∗3) Write a macro processor that defines and expands simple macros (like the C preprocessor
does). Read from cinand write to cout. At first, don’t try to handle macros with arguments.
Hint: The desk calculator (§6.1) contains a symbol table and a lexical analyzer that you could
modify.
16. (∗2) Implement print() from §7.5.
17. (∗2) Add functions such as sqrt(), log(), and sin() to the desk calculator from §6.1. Hint:
Predefine the names and call the functions through an array of pointers to functions. Don’t forget to check the arguments in a function call.
18. (∗1) Write a factorial function that does not use recursion. See also §11.14[6].
19. (∗2) Write functions to add one day, one month, and one year to a Dateas defined in §5.9[13].
Write a function that gives the day of the week for a given Date. Write a function that gives the
Dateof the first Monday following a given Date.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
8 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
Namespaces and Exceptions
The year is 787!
A.D.?
– Monty Python
No rule is so general,
which admits not some exception.
– Robert Burton
Modularity, interfaces, and exceptions — namespaces — using— using namespace—
avoiding name clashes — name lookup — namespace composition — namespace aliases
— namespaces and C code — exceptions — throwand catch— exceptions and program structure — advice — exercises.
8.1 Modularization and Interfaces [name.module]
Any realistic program consists of a number of separate parts. For example, even the simple ‘‘Hello,
world!’’ program involves at least two parts: the user code requests Hello, world! to be printed,
and the I/O system does the printing.
Consider the desk calculator example from §6.1. It can be viewed as being composed of five
parts:
[1] The parser, doing syntax analysis
[2] The lexer, composing tokens out of characters
[3] The symbol table, holding (string,value) pairs
[4] The driver, main()
[5] The error handler
This can be represented graphically:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
166 Namespaces and Exceptions Chapter 8
driver
parser
lexer
symbol table
error handler
where an arrow means ‘‘using.’’ To simplify the picture, I have not represented the fact that every
part relies on error handling. In fact, the calculator was conceived as three parts, with the driver
and error handler added for completeness.
When one module uses another, it doesn’t need to know everything about the module used.
Ideally, most of the details of a module are unknown to its users. Consequently, we make a distinction between a module and its interface. For example, the parser directly relies on the lexer’s interface (only), rather than on the complete lexer. The lexer simply implements the services advertised
in its interface. This can be presented graphically like this:
driver
parser interface
lexer interface
symbol table interface
parser implementation
lexer implementation
symbol table implementation
error handler
Dashed lines means ‘‘implements.’’ I consider this to be the real structure of the program, and our
job as programmers is to represent this faithfully in code. That done, the code will be simple, efficient, comprehensible, maintainable, etc., because it will directly reflect our fundamental design.
The following sections show how the logical structure of the desk calculator program can be
made clear, and §9.3 shows how the program source text can be physically organized to take advantage of it. The calculator is a tiny program, so in ‘‘real life’’ I wouldn’t bother using namespaces
and separate compilation (§2.4.1, §9.1) to the extent I do here. It is simply used to present techniques useful for larger programs without our drowning in code. In real programs, each ‘‘module’’
represented by a separate namespace will often have hundreds of functions, classes, templates, etc.
To demonstrate a variety of techniques and language features, I develop the modularization of
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 8.1 Modularization and Interfaces 167
the calculator in stages. In ‘‘real life,’’ a program is unlikely to grow through all of these stages.
An experienced programmer might pick a design that is ‘‘about right’’ from the start. However, as
a program evolves over the years, dramatic structural changes are not uncommon.
Error handling permeates the structure of a program. When breaking up a program into modules or (conversely) when composing a program out of modules, we must take care to minimize
dependencies between modules caused by error handling. C++ provides exceptions to decouple the
detection and reporting of errors from the handling of errors. Therefore, the discussion of how to
represent modules as namespaces (§8.2) is followed by a demonstration of how we can use exceptions to further improve modularity (§8.3).
There are many more notions of modularity than the ones discussed in this chapter and the next.
For example, we might use concurrently executing and communicating processes to represent
important aspects of modularity. Similarly, the use of separate address spaces and the communication of information between address spaces are important topics not discussed here. I consider
these notions of modularity largely independent and orthogonal. Interestingly, in each case, separating a system into modules is easy. The hard problem is to provide safe, convenient, and efficient
communication across module boundaries.
8.2 Namespaces [name.namespace]
A namespace is a mechanism for expressing logical grouping. That is, if some declarations logically belong together according to some criteria, they can be put in a common namespace to
express that fact. For example, the declarations of the parser from the desk calculator (§6.1.1) may
be placed in a namespace Parser:
namespace Parser{
double expr(bool) ;
double prim(bool get) { /* ... */ }
double term(bool get) { /* ... */ }
double expr(bool get) { /* ... */ }
}
The function expr() must be declared first and then later defined to break the dependency loop
described in §6.1.1.
The input part of the desk calculator could be also placed in its own namespace:
namespace Lexer{
enum Token_value{
NAME, NUMBER, END,
PLUS=´+´, MINUS=´-´, MUL=´*´, DIV=´/´,
PRINT=´;´, ASSIGN=´=´, LP=´(´, RP=´)´
};
Token_value curr_tok;
double number_value;
string string_value;
Token_value get_token() { /* ... */ }
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
168 Namespaces and Exceptions Chapter 8
This use of namespaces makes it reasonably obvious what the lexer and the parser provide to a
user. However, had I included the source code for the functions, this structure would have been
obscured. If function bodies are included in the declaration of a realistically-sized namespace, you
typically have to wade through pages or screenfuls of information to find what services are offered,
that is, to find the interface.
An alternative to relying on separately specified interfaces is to provide a tool that extracts an
interface from a module that includes implementation details. I don’t consider that a good solution.
Specifying interfaces is a fundamental design activity (see §23.4.3.4), a module can provide different interfaces to different users, and often an interface is designed long before the implementation
details are made concrete.
Here is a version of the Parserwith the interface separated from the implementation:
namespace Parser{
double prim(bool) ;
double term(bool) ;
double expr(bool) ;
}
double Parser: :prim(bool get) { /* ... */ }
double Parser: :term(bool get) { /* ... */ }
double Parser: :expr(bool get) { /* ... */ }
Note that as a result of separating the implementation of the interface, each function now has
exactly one declaration and one definition. Users will see only the interface containing declarations.
The implementation – in this case, the function bodies – will be placed ‘‘somewhere else’’ where a
user need not look.
As shown, a member can be declared within a namespace definition and defined later using the
namespace-name::member-name notation.
Members of a namespace must be introduced using this notation:
namespace namespace-name{
/ / declaration and definitions
}
We cannot declare a new member of a namespace outside a namespace definition using the qualifier syntax. For example:
void Parser: :logical(bool) ; / / error: no logical() in Parser
The idea is to make it reasonably easy to find all names in a namespace declaration and also to
catch errors such as misspellings and type mismatches. For example:
double Parser: :trem(bool) ; / / error: no trem() in Parser
double Parser: :prim(int) ; / / error: Parser::prim() takes a bool argument
A namespace is a scope. Thus, ‘‘namespace’’ is a very fundamental and relatively simple concept.
The larger a program is, the more useful namespaces are to express logical separations of its parts.
Ordinary local scopes, global scopes, and classes are namespaces (§C.10.3).
Ideally, every entity in a program belongs to some recognizable logical unit (‘‘module’’).
Therefore, every declaration in a nontrivial program should ideally be in some namespace named to
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 8.2 Namespaces 169
indicate its logical role in the program. The exception is main(), which must be global in order
for the run-time environment to recognize it as special (§8.3.3).
8.2.1 Qualified Names [name.qualified]
A namespace is a scope. The usual scope rules hold for namespaces, so if a name is previously
declared in the namespace or in an enclosing scope, it can be used without further fuss. A name
from another namespace can be used when qualified by the name of its namespace. For example:
double Parser: :term(bool get) / / note Parser:: qualification
{
double left= prim(get) ; / / no qualification needed
for(;;)
switch(Lexer: :curr_tok) { / / note Lexer:: qualification
case Lexer: :MUL: / / note Lexer:: qualification
left*= prim(true) ; / / no qualification needed
/ / ...
}
/ / ...
}
The Parserqualifier is necessary to state that this term() is the one declared in Parserand not
some unrelated global function. Because term() is a member of Parser, it need not use a qualifier
for prim(). However, had the Lexerqualifier not been present, curr_tokwould have been considered undeclared because the members of namespace Lexerare not in scope from within the Parser
namespace.
8.2.2 Using Declarations [name.using.dcl]
When a name is frequently used outside its namespace, it can be a bother to repeatedly qualify it
with its namespace name. Consider:
double Parser: :prim(bool get) / / handle primaries
{
if(get) Lexer: :get_token() ;
switch(Lexer: :curr_tok) {
case Lexer: :NUMBER: / / floating-point constant
Lexer: :get_token() ;
return Lexer: :number_value;
case Lexer: :NAME:
{ double& v= table[Lexer: :string_value] ;
if(Lexer: :get_token() == Lexer: :ASSIGN) v= expr(true) ;
return v;
}
case Lexer: :MINUS: / / unary minus
return-prim(true) ;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
170 Namespaces and Exceptions Chapter 8
case Lexer: :LP:
{ double e= expr(true) ;
if(Lexer: :curr_tok!= Lexer: :RP) return Error: :error(") expected") ;
Lexer: :get_token() ; / / eat ’)’
return e;
}
case Lexer: :END:
return 1;
default:
return Error: :error("primary expected") ;
}
}
The repeated qualification Lexeris tedious and distracting. This redundancy can be eliminated by
a using-declaration to state in one place that the get_tokenused in this scope is Lexer’s get_token.
For example:
double Parser: :prim(bool get) / / handle primaries
{
using Lexer: :get_token; / / use Lexer’s get_token
using Lexer: :curr_tok; / / use Lexer’s curr_tok
using Error: :error; / / use Error’s error
if(get) get_token() ;
switch(curr_tok) {
case Lexer: :NUMBER: / / floating-point constant
get_token() ;
return Lexer: :number_value;
case Lexer: :NAME:
{ double& v= table[Lexer: :string_value] ;
if(get_token() == Lexer: :ASSIGN) v= expr(true) ;
return v;
}
case Lexer: :MINUS: / / unary minus
return-prim(true) ;
case Lexer: :LP:
{ double e= expr(true) ;
if(curr_tok!= Lexer: :RP) return error(") expected") ;
get_token() ; / / eat ’)’
return e;
}
case Lexer: :END:
return 1;
default:
return error("primary expected") ;
}
}
A using-declaration introduces a local synonym.
It is often a good idea to keep local synonyms as local as possible to avoid confusion.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 8.2.2 Using Declarations 171
However, all parser functions use similar sets of names from other modules. We can therefore
place the using-declarations in the Parser’s namespace definition:
namespace Parser{
double prim(bool) ;
double term(bool) ;
double expr(bool) ;
using Lexer: :get_token; / / use Lexer’s get_token
using Lexer: :curr_tok; / / use Lexer’s curr_tok
using Error: :error; / / use Error’s error
}
This allows us to simplify the Parserfunctions almost to our original version (§6.1.1):
double Parser: :term(bool get) / / multiply and divide
{
double left= prim(get) ;
for(;;)
switch(curr_tok) {
case Lexer: :MUL:
left*= prim(true) ;
break;
case Lexer: :DIV:
if(double d= prim(true)) {
left/= d;
break;
}
return error("divide by 0") ;
default:
return left;
}
}
I could have introduced the token names into the Parser’s namespace. However, I left them
explicitly qualified as a reminder of Parser’s dependency on Lexer.
8.2.3 Using Directives [name.using.dir]
What if our aim were to simplify the Parserfunctions to be exactly our original versions? This
would be a reasonable aim for a large program that was being converted to using namespaces from
a previous version with less explicit modularity.
A using-directive makes names from a namespace available almost as if they had been declared
outside their namespace (§8.2.8). For example:
namespace Parser{
double prim(bool) ;
double term(bool) ;
double expr(bool) ;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
172 Namespaces and Exceptions Chapter 8
using namespace Lexer; / / make all names from Lexer available
using namespace Error; / / make all names from Error available
}
This allows us to write Parser’s functions exactly as we originally did (§6.1.1):
double Parser: :term(bool get) / / multiply and divide
{
double left= prim(get) ;
for(;;)
switch(curr_tok) { / / Lexer’s curr_tok
case MUL: / / Lexer’s MUL
left*= prim(true) ;
break;
case DIV: / / Lexer’s DIV
if(double d= prim(true)) {
left/= d;
break;
}
return error("divide by 0") ; / / Error’s error
default:
return left;
}
}
Global using-directives are a tool for transition (§8.2.9) and are otherwise best avoided. In a namespace, a using-directiveis a tool for namespace composition (§8.2.8). In a function (only), a
using-directivecan be safely used as a notational convenience (§8.3.3.1).
8.2.4 Multiple Interfaces [name.multi]
It should be clear that the namespace definition we evolved for Parseris not the interface that the
Parserpresents to its users. Instead, it is the set of declarations that is needed to write the individual parser functions conveniently. The Parser’s interface to its users should be far simpler:
namespace Parser{
double expr(bool) ;
}
Fortunately, the two namespace-definitions for Parsercan coexist so that each can be used where it
is most appropriate. We see the namespace Parserused to provide two things:
[1] The common environment for the functions implementing the parser
[2] The external interface offered by the parser to its users
Thus, the driver code, main(), should see only:
namespace Parser{ / / interface for users
double expr(bool) ;
}
The functions implementing the parser should see whichever interface we decided on as the best for
expressing those functions’ shared environment. That is:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 8.2.4 Multiple Interfaces 173
namespace Parser{ / / interface for implementers
double prim(bool) ;
double term(bool) ;
double expr(bool) ;
using Lexer: :get_token; / / use Lexer’s get_token
using Lexer: :curr_tok; / / use Lexer’s curr_tok
using Error: :error; / / use Error’s error
}
or graphically:
Parser’
Driver
Parser
. . Parserimplementation
The arrows represent ‘‘relies on the interface provided by’’ relations.
Parser´ is the small interface offered to users. The name Parser´ (Parser prime) is not a C++
identifier. It was chosen deliberately to indicate that this interface doesn’t have a separate name in
the program. The lack of a separate name need not lead to confusion because programmers naturally invent different and obvious names for the different interfaces and because the physical layout
of the program (see §9.3.2) naturally provides separate (file) names.
The interface offered to implementers is larger than the interface offered to users. Had this
interface been for a realistically-sized module in a real system, it would change more often than the
interface seen by users. It is important that the users of a module (in this case, main() using
Parser) are insulated from such changes.
We don’t need to use two separate namespaces to express the two different interfaces, but if we
wanted to, we could. Designing interfaces is one of the most fundamental design activities and one
in which major benefits can be gained and lost. Consequently, it is worthwhile to consider what we
are really trying to achieve and to discuss a number of alternatives.
Please keep in mind that the solution presented is the simplest of those we consider, and often
the best. Its main weaknesses are that the two interfaces don’t have separate names and that the
compiler doesn’t necessarily have sufficient information to check the consistency of the two definitions of the namespace. However, even though the compiler doesn’t always get the opportunity to
check the consistency, it usually does. Furthermore, the linker catches most errors missed by the
compiler.
The solution presented here is the one I use for the discussion of physical modularity (§9.3) and
the one I recommend in the absence of further logical constraints (see also §8.2.7).
8.2.4.1 Interface Design Alternatives [name.alternatives]
The purpose of interfaces is to minimize dependencies between different parts of a program. Minimal interfaces lead to systems that are easier to understand, have better data hiding properties, are
easier to modify, and compile faster.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
174 Namespaces and Exceptions Chapter 8
When dependencies are considered, it is important to remember that compilers and programmers tend to take a somewhat simple-minded approach to them: ‘‘If a definition is in scope at point
X, then anything written at point X depends on anything stated in that definition.’’ Typically,
things are not really that bad because most definitions are irrelevant to most code. Given the definitions we have used, consider:
namespace Parser{ / / interface for implementers
/ / ...
double expr(bool) ;
/ / ...
}
int main()
{
/ / ...
Parser: :expr(false) ;
/ / ...
}
The function main() depends on Parser: :expr() only, but it takes time, brain power, computation, etc., to figure that out. Consequently, for realistically-sized programs people and compilation
systems often play it safe and assume that where there might be a dependency, there is one. This is
typically a perfectly reasonable approach.
Thus, our aim is to express our program so that the set of potential dependencies is reduced to
the set of actual dependencies.
First, we try the obvious: define a user interface to the parser in terms of the implementer interface we already have:
namespace Parser{ / / interface for implementers
/ / ...
double expr(bool) ;
/ / ...
}
namespace Parser_interface{ / / interface for users
using Parser: :expr;
}
Clearly, users of Parser_interfacedepend only, and indirectly, on Parser: :expr(). However, a
crude look at the dependency graph gives us this:
Parser_interface
. . Driver
Parser
. . Parserimplementation
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 8.2.4.1 Interface Design Alternatives 175
Now the driverappears vulnerable to any change in the Parserinterface from which it was supposed to be insulated. Even this appearance of a dependency is undesirable, so we explicitly
restrict Parser_interface’s dependency on Parserby having only the relevant part of the implementer interface to parser (that was called Parser´ earlier) in scope where we define
Parser_interface:
namespace Parser{ / / interface for users
double expr(bool) ;
}
namespace Parser_interface{ / / separately named interface for users
using Parser: :expr;
}
or graphically:
Parser’ Parser
Parser_interface
. . Driver
. . Parserimplementation
To ensure the consistency of Parserand Parser´, we again rely on the compilation system as a
whole, rather than on just the compiler working on a single compilation unit. This solution differs
from the one in §8.2.4 only by the extra namespace Parser_interface. If we wanted to, we could
give Parser_interfacea concrete representation by giving it its own expr() function:
namespace Parser_interface{
double expr(bool) ;
}
Now Parserneed not be in scope in order to define Parser_interface. It needs to be in scope only
where Parser_interface: :expr() is defined:
double Parser_interface: :expr(bool get)
{
return Parser: :expr(get) ;
}
This last variant can be represented graphically like this:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
176 Namespaces and Exceptions Chapter 8
Parser_interface Parser
. . Driver. . Parserimplementation
Parser_interface
implementation
Now all dependencies are minimized. Everything is concrete and properly named. However, for
most problems I face, this solution is also massive overkill.
8.2.5 Avoiding Name Clashes [name.clash]
Namespaces are intended to express logical structure. The simplest such structure is the distinction
between code written by one person vs. code written by someone else. This simple distinction can
be of great practical importance.
When we use only a single global scope, it is unnecessarily difficult to compose a program out
of separate parts. The problem is that the supposedly-separate parts each define the same names.
When combined into the same program, these names clash. Consider:
/ / my.h:
char f(char) ;
int f(int) ;
class String{ /* ... */ };
/ / your.h:
char f(char) ;
double f(double) ;
class String{ /* ... */ };
Given these definitions, a third party cannot easily use both my.hand your.h. The obvious solution is to wrap each set of declarations in its own namespace:
namespace My{
char f(char) ;
int f(int) ;
class String{ /* ... */ };
}
namespace Your{
char f(char) ;
double f(double) ;
class String{ /* ... */ };
}
Now we can use declarations from Myand Yourthrough explicit qualification (§8.2.1), usingdeclarations (§8.2.2), or using-directives (§8.2.3).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 8.2.5.1 Unnamed Namespaces 177
8.2.5.1 Unnamed Namespaces [name.unnamed]
It is often useful to wrap a set of declarations in a namespace simply to protect against the possibility of name clashes. That is, the aim is to preserve locality of code rather than to present an interface to users. For example:
#include"header.h"
namespace Mine{
int a;
void f() { /* ... */ }
int g() { /* ... */ }
}
Since we don’t want the name Mineto be known outside a local context, it simply becomes a
bother to invent a redundant global name that might accidentally clash with someone else’s names.
In that case, we can simply leave the namespace without a name:
#include"header.h"
namespace{
int a;
void f() { /* ... */ }
int g() { /* ... */ }
}
Clearly, there has to be some way of accessing members of an unnamed namespace from the outside. Consequently, an unnamed namespace has an implied using-directive. The previous declaration is equivalent to
namespace$$$ {
int a;
void f() { /* ... */ }
int g() { /* ... */ }
}
using namespace$$$;
where $$$ is some name unique to the scope in which the namespace is defined. In particular,
unnamed namespaces in different translation units are different. As desired, there is no way of
naming a member of an unnamed namespace from another translation unit.
8.2.6 Name Lookup [name.koenig]
A function taking an argument of type Tis more often than not defined in the same namespace as
T. Consequently, if a function isn’t found in the context of its use, we look in the namespaces of its
arguments. For example:
namespace Chrono{
class Date{ /* ... */ };
bool operator==(const Date&, const std: :string&) ;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
178 Namespaces and Exceptions Chapter 8
std: :string format(const Date&) ; / / make string representation
/ / ...
}
void f(Chrono: :Date d, int i)
{
std: :string s= format(d) ; / / Chrono::format()
std: :string t= format(i) ; / / error: no format() in scope
}
This lookup rule saves the programmer a lot of typing compared to using explicit qualification, yet
it doesn’t pollute the namespace the way a using-directive (§8.2.3) can. It is especially useful for
operator operands (§11.2.4) and template arguments (§C.13.8.4), where explicit qualification can
be quite cumbersome.
Note that the namespace itself needs to be in scope and the function must be declared before it
can be found and used.
Naturally, a function can take arguments from more than one namespace. For example:
void f(Chrono: :Date d, std: :string s)
{
if(d== s) {
/ / ...
}
else if(d== "August 4, 1914") {
/ / ...
}
}
In such cases, we look for the function in the scope of the call (as ever) and in the namespaces of
every argument (including each argument’s class and base classes) and do the usual overload resolution (§7.4) of all functions we find. In particular, for the call d==s, we look for operator== in
the scope surrounding f(), in the stdnamespace (where == is defined for string), and in the
Chrononamespace. There is a std: :operator==(), but it doesn’t take a Dateargument, so we
use Chrono: :operator==(), which does. See also §11.2.4.
When a class member invokes a function, other members of the same class and its base classes
are preferred over functions potentially found based on the argument types (§11.2.4).
8.2.7 Namespace Aliases [name.alias]
If users give their namespaces short names, the names of different namespaces will clash:
namespace A{ / / short name, will clash (eventually)
/ / ...
}
A: :String s1= "Grieg";
A: :String s2= "Nielsen";
However, long namespace names can be impractical in real code:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 8.2.7 Namespace Aliases 179
namespace American_Telephone_and_Telegraph{ / / too long
/ / ...
}
American_Telephone_and_Telegraph: :String s3= "Grieg";
American_Telephone_and_Telegraph: :String s4= "Nielsen";
This dilemma can be resolved by providing a short alias for a longer namespace name:
/ / use namespace alias to shorten names:
namespace ATT= American_Telephone_and_Telegraph;
ATT: :String s3= "Grieg";
ATT: :String s4= "Nielsen";
Namespace aliases also allow a user to refer to ‘‘the library’’ and have a single declaration defining
what library that really is. For example:
namespace Lib= Foundation_library_v2r11;
/ / ...
Lib: :set s;
Lib: :String s5= "Sibelius";
This can immensely simplify the task of replacing one version of a library with another. By using
Librather than Foundation_library_v2r11directly, you can update to version ‘‘v3r02’’ by changing the initialization of the alias Liband recompiling. The recompile will catch source level incompatibilities. On the other hand, overuse of aliases (of any kind) can lead to confusion.
8.2.8 Namespace Composition [name.compose]
Often, we want to compose an interface out of existing interfaces. For example:
namespace His_string{
class String{ /* ... */ };
String operator+(const String&, const String&) ;
String operator+(const String&, const char*) ;
void fill(char) ;
/ / ...
}
namespace Her_vector{
template<class T> class Vector{ /* ... */ };
/ / ...
}
namespace My_lib{
using namespace His_string;
using namespace Her_vector;
void my_fct(String&) ;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
180 Namespaces and Exceptions Chapter 8
Given this, we can now write the program in terms of My_lib:
void f()
{
My_lib: :String s= "Byron"; / / finds My_lib::His_string::String
/ / ...
}
using namespace My_lib;
void g(Vector<String>& vs)
{
/ / ...
my_fct(vs[5]) ;
/ / ...
}
If an explicitly qualified name (such as My_lib: :String) isn’t declared in the namespace mentioned, the compiler looks in namespaces mentioned in using-directives (such as His_string).
Only if we need to define something, do we need to know the real namespace of an entity:
void My_lib: :fill() / / error: no fill() declared in My_lib
{
/ / ...
}
void His_string: :fill() / / ok: fill() declared in His_string
{
/ / ...
}
void My_lib: :my_fct(My_lib: :Vector<My_lib: :String>& v) / / ok
{
/ / ...
}
Ideally, a namespace should
[1] express a logically coherent set of features,
[2] not give users access to unrelated features, and
[3] not impose a significant notational burden on users.
The composition techniques presented here and in the following subsections – together with the
#includemechanism (§9.2.1) – provide strong support for this.
8.2.8.1 Selection [name.select]
Occasionally, we want access to only a few names from a namespace. We could do that by writing
a namespace declaration containing only those names we want. For example, we could declare a
version of His_stringthat provided the Stringitself and the concatenation operator only:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 8.2.8.1 Selection 181
namespace His_string{ / / part of His_string only
class String{ /* ... */ };
String operator+(const String&, const String&) ;
String operator+(const String&, const char*) ;
}
However, unless I am the designer or maintainer of His_string, this can easily get messy. A
change to the ‘‘real’’ definition of His_stringwill not be reflected in this declaration. Selection of
features from a namespace is more explicitly made with using-declarations:
namespace My_string{
using His_string: :String;
using His_string: :operator+; / / use any + from His_string
}
A using-declaration brings every declaration with a given name into scope. In particular, a single
using-declaration can bring in every variant of an overloaded function.
In this way, if the maintainer of His_stringadds a member function to Stringor an overloaded
version of the concatenation operator, that change will automatically become available to users of
My_string. Conversely, if a feature is removed from His_stringor has its interface changed,
affected uses of My_stringwill be detected by the compiler (see also §15.2.2).
8.2.8.2 Composition and Selection [name.comp]
Combining composition (by using-directives) with selection (by using-declarations) yields the
flexibility needed for most real-world examples. With these mechanisms, we can provide access to
a variety of facilities in such a way that we resolve name clashes and ambiguities arising from their
composition. For example:
namespace His_lib{
class String{ /* ... */ };
template<class T> class Vector{ /* ... */ };
/ / ...
}
namespace Her_lib{
template<class T> class Vector{ /* ... */ };
class String{ /* ... */ };
/ / ...
}
namespace My_lib{
using namespace His_lib; / / everything from His_lib
using namespace Her_lib; / / everything from Her_lib
using His_lib: :String; / / resolve potential clash in favor of His_lib
using Her_lib: :Vector; / / resolve potential clash in favor of Her_lib
template<class T> class List{ /* ... */ }; / / additional stuff
/ / ...
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
182 Namespaces and Exceptions Chapter 8
When looking into a namespace, names explicitly declared there (including names declared by
using-declarations) take priority over names made accessible in another scope by a using-directive
(see also §C.10.1). Consequently, a user of My_libwill see the name clashes for Stringand Vector
resolved in favor of His_lib: :Stringand Her_lib: :Vector. Also, My_lib: :Listwill be used by
default independently of whether His_libor Her_libare providing a List.
Usually, I prefer to leave a name unchanged when including it into a new namespace. In that
way, I don’t have to remember two different names for the same entity. However, sometimes a
new name is needed or simply nice to have. For example:
namespace Lib2{
using namespace His_lib; / / everything from His_lib
using namespace Her_lib; / / everything from Her_lib
using His_lib: :String; / / resolve potential clash in favor of His_lib
using Her_lib: :Vector; / / resolve potential clash in favor of Her_lib
typedef Her_lib: :String Her_string; / / rename
template<class T> class His_vec/ / ‘‘rename’’
: public His_lib: :Vector<T> { /* ... */ };
template<class T> class List{ /* ... */ }; / / additional stuff
/ / ...
}
There is no specific language mechanism for renaming. Instead, the general mechanisms for defining new entities are used.
8.2.9 Namespaces and Old Code [name.get]
Millions of lines of C and C++ code rely on global names and existing libraries. How can we use
namespaces to alleviate problems in such code? Redesigning existing code isn’t always a viable
option. Fortunately, it is possible to use C libraries as if they were defined in a namespace. However, this cannot be done for libraries written in C++ (§9.2.4). On the other hand, namespaces are
designed so that they can be introduced with minimal disruption into an older C++ program.
8.2.9.1 Namespaces and C [name.c]
Consider the canonical first C program:
#include<stdio.h>
int main()
{
printf("Hello, world!\n") ;
}
Breaking this program wouldn’t be a good idea. Making standard libraries special cases isn’t a
good idea either. Consequently, the language rules for namespaces are designed to make it relatively easy to take a program written without namespaces and turn it into a more explicitly structured one using namespaces. In fact, the calculator program (§6.1) is an example of this.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 8.2.9.1 Namespaces and C 183
The using-directive is the key to achieving this. For example, the declarations of the standard C
I/O facilities from the C header stdio.hare wrapped in a namespace like this:
/ / stdio.h:
namespace std{
/ / ...
int printf(const char* ... ) ;
/ / ...
}
using namespace std;
This achieves backwards compatibility. Also, a new header file cstdiois defined for people who
don’t want the names implicitly available:
/ / cstdio:
namespace std{
/ / ...
int printf(const char* ... ) ;
/ / ...
}
C++ standard library implementers who worry about replication of declarations will, of course,
define stdio.hby including cstdio:
/ / stdio.h:
#include<cstdio>
using namespace std;
I consider nonlocal using-directives primarily a transition tool. Most code referring to names from
other namespaces can be expressed more clearly with explicit qualification and using-declarations.
The relationship between namespaces and linkage is described in §9.2.4.
8.2.9.2 Namespaces and Overloading [name.over]
Overloading (§7.4) works across namespaces. This is essential to allow us to migrate existing
libraries to use namespaces with minimal source code changes. For example:
/ / old A.h:
void f(int) ;
/ / ...
/ / old B.h:
void f(char) ;
/ / ...
/ / old user.c:
#include"A.h"
#include"B.h"
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
184 Namespaces and Exceptions Chapter 8
void g()
{
f(´a´) ; / / calls the f() from B.h
}
This program can be upgraded to a version using namespaces without changing the actual code:
/ / new A.h:
namespace A{
void f(int) ;
/ / ...
}
/ / new B.h:
namespace B{
void f(char) ;
/ / ...
}
/ / new user.c:
#include"A.h"
#include"B.h"
using namespace A;
using namespace B;
void g()
{
f(´a´) ; / / calls the f() from B.h
}
Had we wanted to keep user.ccompletely unchanged, we would have placed the using-directives
in the header files.
8.2.9.3 Namespaces Are Open [name.open]
A namespace is open; that is, you can add names to it from several namespace declarations. For
example:
namespace A{
int f() ; / / now A has member f()
}
namespace A{
int g() ; / / now A has two members, f() and g()
}
In this way, we can support large program fragments within a single namespace the way an older
library or application lives within the single global namespace. To do this, we must distribute the
namespace definition over several header and source code files. As shown by the calculator example (§8.2.4), the openness of namespaces allows us to present different interfaces to different kinds
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 8.2.9.3 Namespaces Are Open 185
of users by presenting different parts of a namespace. This openness is also an aid to transition.
For example,
/ / my header:
void f() ; / / my function
/ / ...
#include<stdio.h>
int g() ; / / my function
/ / ...
can be rewritten without reordering of the declarations:
/ / my header:
namespace Mine{
void f() ; / / my function
/ / ...
}
#include<stdio.h>
namespace Mine{
int g() ; / / my function
/ / ...
}
When writing new code, I prefer to use many smaller namespaces (see §8.2.8) rather than putting
really major pieces of code into a single namespace. However, that is often impractical when converting major pieces of software to use namespaces.
When defining a previously declared member of a namespace, it is safer to use the Mine: : syntax than to re-open Mine. For example:
void Mine: :ff() / / error: no ff() declared in Mine
{
/ / ...
}
A compiler catches this error. However, because new functions can be defined within a namespace,
a compiler cannot catch the equivalent error in a re-opened namespace:
namespace Mine{ / / re-opening Mine to define functions
void ff() / / oops! no ff() declared in Mine; ff() is added to Mine by this definition
{
/ / ...
}
/ / ...
}
The compiler has no way of knowing that you didn’t want that new ff().
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
186 Namespaces and Exceptions Chapter 8
8.3 Exceptions [name.except]
When a program is composed of separate modules, and especially when those modules come from
separately developed libraries, error handling needs to be separated into two distinct parts:
[1] The reporting of error conditions that cannot be resolved locally
[2] The handling of errors detected elsewhere
The author of a library can detect run-time errors but does not in general have any idea what to do
about them. The user of a library may know how to cope with such errors but cannot detect them –
or else they would be handled in the user’s code and not left for the library to find.
In the calculator example, we bypassed this problem by designing the program as a whole. By
doing that, we could fit error handling into our overall framework. However, when we separate the
logical parts of the calculator into separate namespaces, we see that every namespace depends on
namespace Error(§8.2.2) and that the error handling in Errorrelies on every module behaving
appropriately after an error. Let’s assume that we don’t have the freedom to design the calculator as
a whole and don’t want the tight coupling between Errorand all other modules. Instead, assume
that the parser, etc., are written without knowledge of how a driver might like to handle errors.
Even though error() was very simple, it embodied a strategy for error handling:
namespace Error{
int no_of_errors;
double error(const char* s)
{
std: :cerr<< "error: " << s<< ´\n´;
no_of_errors++;
return 1;
}
}
The error() function writes out an error message, supplies a default value that allows its caller to
continue a computation, and keeps track of a simple error state. Importantly, every part of the program knows that error() exists, how to call it, and what to expect from it. For a program composed of separately-developed libraries, that would be too much to assume.
Exceptions are C++’s means of separating error reporting from error handling. In this section,
exceptions are briefly described in the context of their use in the calculator example. Chapter 14
provides a more extensive discussion of exceptions and their uses.
8.3.1 Throw and Catch [name.throw]
The notion of an exception is provided to help deal with error reporting. For example:
struct Range_error{
int i;
Range_error(int ii) { i= ii; } / / constructor (§2.5.2, §10.2.3)
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 8.3.1 Throw and Catch 187
char to_char(int i)
{
if(i<numeric_limits<char>: :min() || numeric_limits<char>: :max()<i)/ / see §22.2
throw Range_Error() ;
return c;
}
The to_char() function either returns the charwith the numeric value ior throws a Range_error.
The fundamental idea is that a function that finds a problem it cannot cope with throws an exception, hoping that its (direct or indirect) caller can handle the problem. A function that wants to handle a problem can indicate that it is willing to catch exceptions of the type used to report the problem. For example, to call to_char() and catch the exception it might throw, we could write:
void g(int i)
{
try{
char c= to_char(i) ;
/ / ...
}
catch(Range_error) {
cerr<< "oops\n";
}
}
The construct
catch( /* ... */ ) {
/ / ...
}
is called an exception handler. It can be used only immediately after a block prefixed with the keyword tryor immediately after another exception handler; catchis also a keyword. The parentheses
contain a declaration that is used in a way similar to how a function argument declaration is used.
That is, it specifies the type of the objects that can be caught by this handler and optionally names
the object caught. For example, if we wanted to know the value of the Range_errorthrown, we
would provide a name for the argument to catchexactly the way we name function arguments. For
example:
void h(int i)
{
try{
char c= to_char(i) ;
/ / ...
}
catch(Range_error x) {
cerr<< "oops: to_char(" << x.i<< ")\n";
}
}
If any code in a try-block – or called from it – throws an exception, the try-block’s handlers will be
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
188 Namespaces and Exceptions Chapter 8
examined. If the exception thrown is of a type specified for a handler, that handler is executed. If
not, the exception handlers are ignored and the try-block acts just like an ordinary block.
Basically, C++ exception handling is a way to transfer control to designated code in a calling
function. Where needed, some information about the error can be passed along to the caller. C
programmers can think of exception handling as a well-behaved mechanism replacing
setjmp/longjmp(§16.1.2). The important interaction between exception handling and classes is
described in Chapter 14.
8.3.2 Discrimination of Exceptions [name.discrimination]
Typically, a program will have several different possible run-time errors. Such errors can be
mapped into exceptions with distinct names. I prefer to define types with no other purpose than
exception handling. This minimizes confusion about their purpose. In particular, I never use a
built-in type, such as int, as an exception. In a large program, I would have no effective way to
find unrelated uses of intexceptions. Thus, I could never be sure that such other uses didn’t interfere with my use.
Our calculator (§6.1) must handle two kinds of run-time errors: syntax errors and attempts to
divide by zero. No values need to be passed to a handler from the code that detects an attempt to
divide by zero, so zero divide can be represented by a simple empty type:
struct Zero_divide{ };
On the other hand, a handler would most likely prefer to get an indication of what kind of syntax
error occurred. Here, we pass a string along:
struct Syntax_error{
const char* p;
Syntax_error(const char* q) { p= q; }
};
For notational convenience, I added a constructor (§2.5.2, §10.2.3) to the struct.
A user of the parser can discriminate between the two exceptions by adding handlers for both to
a tryblock. Where needed, the appropriate handler will be entered. If we ‘‘fall through the bottom’’ of a handler, the execution continues at the end of the list of handlers:
try{
/ / ...
expr(false) ;
/ / we get here if and only if expr() didn’t cause an exception
/ / ...
}
catch(Syntax_error) {
/ / handle syntax error
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 8.3.2 Discrimination of Exceptions 189
catch(Zero_divide) {
/ / handle divide by zero
}
/ / we get here if expr didn’t cause an exception or if a Syntax_error
/ / or Zero_divide exception was caught (and its handler didn’t return,
/ / throw an exception, or in some other way alter the flow of control).
A list of handlers looks a bit like a switchstatement, but there is no need for breakstatements. The
syntax of a list of handlers differs from the syntax of a list of cases partly for that reason and partly
to indicate that each handler is a scope (§4.9.4).
A function need not catch all possible exceptions. For example, the previous try-block didn’t
try to catch exceptions potentially generated by the parser’s input operations. Those exceptions
simply ‘‘pass through,’’ searching for a caller with an appropriate handler.
From the language’s point of view, an exception is considered handled immediately upon entry
into its handler so that any exceptions thrown while executing a handler must be dealt with by the
callers of the try-block. For example, this does not cause an infinite loop:
class input_overflow{ /* ... */ };
void f()
{
try{
/ / ...
}
catch(input_overflow) {
/ / ...
throw input_overflow() ;
}
}
Exception handlers can be nested. For example:
class XXII{ /* ... */ };
void f()
{
/ / ...
try{
/ / ...
}
catch(XXII) {
try{
/ / something complicated
}
catch(XXII) {
/ / complicated handler code failed
}
}
/ / ...
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
190 Namespaces and Exceptions Chapter 8
However, such nesting is rare in human-written code and is more often than not an indication of
poor style.
8.3.3 Exceptions in the Calculator [name.calc]
Given the basic exception-handling mechanism, we can rework the calculator example from §6.1 to
separate the handling of errors found at run-time from the main logic of the calculator. This will
result in an organization of the program that more realistically matches what is found in programs
built from separate, loosely connected parts.
First, error() can be eliminated. Instead, the parser functions know only the types used to signal errors:
namespace Error{
struct Zero_divide{ };
struct Syntax_error{
const char* p;
Syntax_error(const char* q) { p= q; }
};
}
The parser detects three syntax errors:
Token_value Lexer: :get_token()
{
using namespace std; / / to use cin, isalpha(), etc.
/ / ...
default: / / NAME, NAME =, or error
if(isalpha(ch)) {
cin.putback(ch) ;
cin>> string_value;
return curr_tok=NAME;
}
throw Error: :Syntax_error("bad token") ;
}
}
double Parser: :prim(bool get) / / handle primaries
{
/ / ...
case Lexer: :LP:
{ double e= expr(true) ;
if(curr_tok!= Lexer: :RP) throw Error: :Syntax_error("‘)´ expected") ;
get_token() ; / / eat ’)’
return e;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 8.3.3 Exceptions in the Calculator 191
case Lexer: :END:
return 1;
default:
throw Error: :Syntax_error("primary expected") ;
}
}
When a syntax error is detected, throwis used to transfer control to a handler defined in some
(direct or indirect) caller. The throwoperator also passes a value to the handler. For example,
throw Syntax_error("primary expected") ;
passes a Syntax_errorobject containing a pointer to the string primary expectedto the handler.
Reporting a divide-by-zero error doesn’t require any data to be passed along:
double Parser: :term(bool get) / / multiply and divide
{
/ / ...
case Lexer: :DIV:
if(double d= prim(true)) {
left/= d;
break;
}
throw Error: :Zero_divide() ;
/ / ...
}
The driver can now be defined to handle Zero_divideand Syntax_errorexceptions. For example:
int main(int argc, char* argv[])
{
/ / ...
while(*input) {
try{
Lexer: :get_token() ;
if(Lexer: :curr_tok== Lexer: :END) break;
if(Lexer: :curr_tok== Lexer: :PRINT) continue;
cout<< Parser: :expr(false) << ´\n´;
}
catch(Error: :Zero_divide) {
cerr<< "attempt to divide by zero\n";
skip() ;
}
catch(Error: :Syntax_error e) {
cerr<< "syntax error:" << e.p<< "\n";
skip() ;
}
}
if(input!= &cin) delete input;
return no_of_errors;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
192 Namespaces and Exceptions Chapter 8
The function skip() tries to bring the parser into a well-defined state after an error by skipping
tokens until it finds an end-of-line or a semicolon. It, no_of_errors,and inputare obvious candidates for a Drivernamespace:
namespace Driver{
int no_of_errors;
std: :istream* input;
void skip() ;
}
void Driver: :skip()
{
no_of_errors++;
while(*input) {
char ch;
input->get(ch) ;
switch(ch) {
case´\n´:
case´;´:
input->get(ch) ;
return;
}
}
}
The code for skip() is deliberately written at a lower level of abstraction than the parser code so as
to avoid being caught by exceptions from the parser while handling parser exceptions.
I retained the idea of counting the number of errors and reporting that number as the program’s
return value. It is often useful to know if a program encountered an error even if it was able to
recover from it.
I did not put main() in the Drivernamespace. The global main() is the initial function of a
program (§3.2); a main() in another namespace has no special meaning.
8.3.3.1 Alternative Error-Handling Strategies [name.strategy]
The original error-handling code was shorter and more elegant than the version using exceptions.
However, it achieved that elegance by tightly coupling all parts of the program. That approach
doesn’t scale well to programs composed of separately developed libraries.
We could consider eliminating the separate error-handling function skip() by introducing a
state variable in main(). For example:
int main(int argc, char* argv[]) / / example of poor style
{
/ / ...
bool in_error= false;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 8.3.3.1 Alternative Error-Handling Strategies 193
while(*Driver: :input) {
try{
Lexer: :get_token() ;
if(Lexer: :curr_tok== Lexer: :END) break;
if(Lexer: :curr_tok== Lexer: :PRINT) {
in_error= false;
continue;
}
if(in_error== false) cout<< Parser: :expr(false) << ´\n´;
}
catch(Error: :Zero_divide) {
cerr<< "attempt to divide by zero\n";
in_error= true;
}
catch(Error: :Syntax_error e) {
cerr<< "syntax error:" << e.p<< "\n";
in_error= true;
}
}
if(Driver: :input!= std: :cin) delete Driver: :input;
return Driver: :no_of_errors;
}
I consider this a bad idea for several reasons:
[1] State variables are a common source of confusion and errors, especially if they are allowed
to proliferate and affect larger sections of a program. In particular, I consider the version of
main() using in_errorless readable than the version using skip().
[2] It is generally a good strategy to keep error handling and ‘‘normal’’ code separate.
[3] Doing error handling using the same level of abstraction as the code that caused the error is
hazardous; the error-handling code might repeat the same error that triggered the error handling in the first place. I leave it as an exercise to find how that can happen for the version
of main() using in_error(§8.5[7]).
[4] It is more work to modify the ‘‘normal’’ code to add error-handling code than to add separate error-handling routines.
Exception handling is intended for dealing with nonlocal problems. If an error can be handled
locally, it almost always should be. For example, there is no reason to use an exception to handle
the too-many-arguments error:
int main(int argc, char* argv[])
{
using namespace std;
using namespace Driver;
switch(argc) {
case 1: / / read from standard input
input= &cin;
break;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
194 Namespaces and Exceptions Chapter 8
case 2: / / read argument string
input= new istringstream(argv[1]) ;
break;
default:
cerr<< "too many arguments\n";
return 1;
}
/ / as before
}
Exceptions are discussed further in Chapter 14.
8.4 Advice [name.advice]
[1] Use namespaces to express logical structure; §8.2.
[2] Place every nonlocal name, except main(), in some namespace; §8.2.
[3] Design a namespace so that you can conveniently use it without accidentally gaining access to
unrelated namespaces; §8.2.4.
[4] Avoid very short names for namespaces; §8.2.7.
[5] If necessary, use namespace aliases to abbreviate long namespaces names; §8.2.7.
[6] Avoid placing heavy notational burdens on users of your namespaces; §8.2.2, §8.2.3.
[7] Use the Namespace: :membernotation when defining namespace members; §8.2.8.
[8] Use using namespaceonly for transition or within a local scope; §8.2.9.
[9] Use exceptions to decouple the treatment of ‘‘errors’’ from the code dealing with the ordinary
processing; §8.3.3.
[10] Use user-defined rather than built-in types as exceptions; §8.3.2.
[11] Don’t use exceptions when local control structures are sufficient; §8.3.3.1.
8.5 Exercises [name.exercises]
1. (∗2.5) Write a doubly-linked list of stringmodule in the style of the Stackmodule from §2.4.
Exercise it by creating a list of names of programming languages. Provide a sort() function
for that list, and provide a function that reverses the order of the strings in it.
2. (∗2) Take some not-too-large program that uses at least one library that does not use namespaces and modify it to use a namespace for that library. Hint: §8.2.9.
3. (∗2) Modify the desk calculator program into a module in the style of §2.4 using namespaces.
Don’t use any global using-directives. Keep a record of the mistakes you made. Suggest ways
of avoiding such mistakes in the future.
4. (∗1) Write a program that throws an exception in one function and catches it in another.
5. (∗2) Write a program consisting of functions calling each other to a calling depth of 10. Give
each function an argument that determines at which level an exception is thrown. Have
main() catch these exceptions and print out which exception is caught. Don’t forget the case
in which an exception is caught in the function that throws it.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 8.5 Exercises 195
6. (∗2) Modify the program from §8.5[5] to measure if there is a difference in the cost of catching
exceptions depending on where in a class stack the exception is thrown. Add a string object to
each function and measure again.
7. (∗1) Find the error in the first version of main() in §8.3.3.1.
8. (∗2) Write a function that either returns a value or that throws that value based on an argument.
Measure the difference in run-time between the two ways.
9. (∗2) Modify the calculator version from §8.5[3] to use exceptions. Keep a record of the mistakes you make. Suggest ways of avoiding such mistakes in the future.
10. (∗2.5) Write plus(), minus(), multiply(), and divide() functions that check for possible
overflow and underflow and that throw exceptions if such errors happen.
11. (∗2) Modify the calculator to use the functions from §8.5[10].
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
196 Namespaces and Exceptions Chapter 8
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
9 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
Source Files and Programs
Form must follow function.
– Le Corbusier
Separate compilation — linking — header files — standard library headers — the onedefinition rule — linkage to non-C++ code — linkage and pointers to functions — using
headers to express modularity — single-header organization — multiple-header organization — include guards — programs — advice — exercises.
9.1 Separate Compilation [file.separate]
A file is the traditional unit of storage (in a file system) and the traditional unit of compilation.
There are systems that do not store, compile, and present C++ programs to the programmer as sets
of files. However, the discussion here will concentrate on systems that employ the traditional use
of files.
Having a complete program in one file is usually impossible. In particular, the code for the
standard libraries and the operating system is typically not supplied in source form as part of a
user’s program. For realistically-sized applications, even having all of the user’s own code in a single file is both impractical and inconvenient. The way a program is organized into files can help
emphasize its logical structure, help a human reader understand the program, and help the compiler
to enforce that logical structure. Where the unit of compilation is a file, all of a file must be recompiled whenever a change (however small) has been made to it or to something on which it depends.
For even a moderately sized program, the amount of time spent recompiling can be significantly
reduced by partitioning the program into files of suitable size.
A user presents a source file to the compiler. The file is then preprocessed; that is, macro processing (§7.8) is done and #includedirectives bring in headers (§2.4.1, §9.2.1). The result of preprocessing is called a translation unit. This unit is what the compiler proper works on and what the
C++ language rules describe. In this book, I differentiate between source file and translation unit
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
198 Source Files and Programs Chapter 9
only where necessary to distinguish what the programmer sees from what the compiler considers.
To enable separate compilation, the programmer must supply declarations providing the type
information needed to analyze a translation unit in isolation from the rest of the program. The
declarations in a program consisting of many separately compiled parts must be consistent in
exactly the same way the declarations in a program consisting of a single source file must be. Your
system will have tools to help ensure this. In particular, the linker can detect many kinds of inconsistencies. The linker is the program that binds together the separately compiled parts. A linker is
sometimes (confusingly) called a loader. Linking can be done completely before a program starts
to run. Alternatively, new code can be added to the program (‘‘dynamically linked’’) later.
The organization of a program into source files is commonly called the physical structure of a
program. The physical separation of a program into separate files should be guided by the logical
structure of the program. The same dependency concerns that guide the composition of programs
out of namespaces guide its composition into source files. However, the logical and physical structure of a program need not be identical. For example, it can be useful to use several source files to
store the functions from a single namespace, to store a collection of namespace definitions in a single file, and to scatter the definition of a namespace over several files (§8.2.4).
Here, we will first consider some technicalities relating to linking and then discuss two ways of
breaking the desk calculator (§6.1, §8.2) into files.
9.2 Linkage [file.link]
Names of functions, classes, templates, variables, namespaces, enumerations, and enumerators
must be used consistently across all translation units unless they are explicitly specified to be local.
It is the programmer’s task to ensure that every namespace, class, function, etc. is properly
declared in every translation unit in which it appears and that all declarations referring to the same
entity are consistent. For example, consider two files:
/ / file1.c:
int x= 1;
int f() { /* do something */ }
/ / file2.c:
extern int x;
int f() ;
void g() { x= f() ; }
The xand f() used by g() in file2.care the ones defined in file1.c. The keyword externindicates that the declaration of xin file2.cis (just) a declaration and not a definition (§4.9). Had x
been initialized, externwould simply be ignored because a declaration with an initializer is always
a definition. An object must be defined exactly once in a program. It may be declared many times,
but the types must agree exactly. For example:
/ / file1.c:
int x= 1;
int b= 1;
extern int c;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 9.2 Linkage 199
/ / file2.c:
int x; / / meaning int x = 0;
extern double b;
extern int c;
There are three errors here: xis defined twice, bis declared twice with different types, and cis
declared twice but not defined. These kinds of errors (linkage errors) cannot be detected by a compiler that looks at only one file at a time. Most, however, are detectable by the linker. Note that a
variable defined without an initializer in the global or a namespace scope is initialized by default.
This is not the case for local variables (§4.9.5, §10.4.2) or objects created on the free store (§6.2.6).
For example, the following program fragment contains two errors:
/ / file1.c:
int x;
int f() { return x; }
/ / file2.c:
int x;
int g() { return f() ; }
The call of f() in file2.cis an error because f() has not been declared in file2.c. Also, the program will not link because xis defined twice. Note that these are not errors in C (§B.2.2).
A name that can be used in translation units different from the one in which it was defined is
said to have external linkage. All the names in the previous examples have external linkage. A
name that can be referred to only in the translation unit in which it is defined is said to have
internal linkage.
An inlinefunction (§7.1.1, §10.2.9) must be defined – by identical definitions (§9.2.3) – in
every translation unit in which it is used. Consequently, the following example isn’t just bad taste;
it is illegal:
/ / file1.c:
inline int f(int i) { return i; }
/ / file2.c:
inline int f(int i) { return i+1; }
Unfortunately, this error is hard for an implementation to catch, and the following – otherwise perfectly logical – combination of external linkage and inlining is banned to make life simpler for
compiler writers:
/ / file1.c:
extern inline int g(int i) ;
int h(int i) { return g(i) ; } / / error: g() undefined in this translation unit
/ / file2.c:
extern inline int g(int i) { return i+1; }
By default, consts (§5.4) and typedefs (§4.9.7) have internal linkage. Consequently, this example
is legal (although potentially confusing):
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
200 Source Files and Programs Chapter 9
/ / file1.c:
typedef int T;
const int x= 7;
/ / file2.c:
typedef void T;
const int x= 8;
Global variables that are local to a single compilation unit are a common source of confusion and
are best avoided. To ensure consistency, you should usually place global consts and inlines in
header files only (§9.2.1).
A constcan be given external linkage by an explicit declaration:
/ / file1.c:
extern const int a= 77;
/ / file2.c:
extern const int a;
void g()
{
cout<< a<< ´\n´;
}
Here, g() will print 77.
An unnamed namespace (§8.2.5) can be used to make names local to a compilation unit. The
effect of an unnamed namespace is very similar to that of internal linkage. For example:
/ / file 1.c:
namespace{
class X{ /* ... */ };
void f() ;
int i;
/ / ...
}
/ / file2.c:
class X{ /* ... */ };
void f() ;
int i;
/ / ...
The function f() in file1.cis not the same function as the f() in file2.c. Having a name local to
a translation unit and also using that same name elsewhere for an entity with external linkage is
asking for trouble.
In C and older C++ programs, the keyword staticis (confusingly) used to mean ‘‘use internal
linkage’’ (§B.2.3). Don’t use staticexcept inside functions (§7.1.2) and classes (§10.2.4).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 9.2.1 Header Files 201
9.2.1 Header Files [file.header]
The types in all declarations of the same object, function, class, etc., must be consistent. Consequently, the source code submitted to the compiler and later linked together must be consistent.
One imperfect but simple method of achieving consistency for declarations in different translation
units is to #include header files containing interface information in source files containing executable code and/or data definitions.
The #includemechanism is a text manipulation facility for gathering source program fragments
together into a single unit (file) for compilation. The directive
#include"to_be_included"
replaces the line in which the #includeappears with the contents of the file to_be_included. The
content should be C++ source text because the compiler will proceed to read it.
To include standard library headers, use the angle brackets < and > around the name instead of
quotes. For example:
#include<iostream> / / from standard include directory
#include"myheader.h" / / from current directory
Unfortunately, spaces are significant within the < > or " " of an include directive:
#include< iostream> / / will not find <iostream>
It may seem extravagant to recompile a file each time it is included somewhere, but the included
files typically contain only declarations and not code needing extensive analysis by the compiler.
Furthermore, most modern C++ implementations provide some form of precompiling of header
files to minimize the work needed to handle repeated compilation of the same header.
As a rule of thumb, a header may contain:
_ _______________________________________________________________________
Named namespaces namespace N{ /* ...*/ }
Type definitions struct Point{ int x, y; };
Template declarations template<class T> class Z;
Template definitions template<class T> class V{ /* ...*/ };
Function declarations extern int strlen(const char*);
Inline function definitions inline char get(char* p) { return*p++; }
Data declarations extern int a;
Constant definitions const float pi= 3.141593;
Enumerations enum Light{ red, yellow, green};
Name declarations class Matrix;
Include directives #include<algorithm>
Macro definitions #define VERSION 12
Conditional compilation directives #ifdef__cplusplus
_ _______________________________________________________________________ Comments /* check for end of file*/

































This rule of thumb for what may be placed in a header is not a language requirement. It is simply a
reasonable way of using the #includemechanism to express the physical structure of a program.
Conversely, a header should never contain:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
202 Source Files and Programs Chapter 9
_____________________________________________________________________
Ordinary function definitions char get(char* p) { return*p++; }
Data definitions int a;
Aggregate definitions short tbl[] = { 1, 2, 3};
Unnamed namespaces namespace{ /* ...*/ }
_ 

_____________________________________________________________________ Exported template definitions export template<class T> f(T t) { /* ...*/ }












Header files are conventionally suffixed by .h, and files containing function or data definitions are
suffixed by .c. They are therefore often referred to as ‘‘.h files’’ and ‘‘.c files,’’ respectively.
Other conventions, such as .C, .cxx, .cpp, and .cc, are also found. The manual for your compiler will be quite specific about this issue.
The reason for recommending that the definition of simple constants, but not the definition of
aggregates, be placed in header files is that it is hard for implementations to avoid replication of
aggregates presented in several translation units. Furthermore, the simple cases are far more common and therefore more important for generating good code.
It is wise not to be too clever about the use of #include. My recommendation is to #include
only complete declarations and definitions and to do so only in the global scope, in linkage specification blocks, and in namespace definitions when converting old code (§9.2.2). As usual, it is wise
to avoid macro magic. One of my least favorite activities is tracking down an error caused by a
name being macro-substituted into something completely different by a macro defined in an indirectly #included header that I have never even heard of.
9.2.2 Standard Library Headers [file.std.header]
The facilities of the standard library are presented through a set of standard headers (§16.1.2). No
suffix is needed for standard library headers; they are known to be headers because they are
included using the #include<...> syntax rather than #include"...". The absence of a .hsuffix does not imply anything about how the header is stored. A header such as <map> may be
stored as a text file called map.hin a standard directory. On the other hand, standard headers are
not required to be stored in a conventional manner. An implementation is allowed to take advantage of knowledge of the standard library definition to optimize the standard library implementation
and the way standard headers are handled. For example, an implementation might have knowledge
of the standard math library (§22.3) built in and treat #include<cmath> as a switch that makes the
standard math functions available without reading any file.
For each C standard-library header <X.h>, there is a corresponding standard C++ header <cX>.
For example, #include<cstdio> provides what #include<stdio.h> does. A typical stdio.hwill
look something like this:
#ifdef__cplusplus/ / for C++ compliers only (§9.2.4)
namespace std{ / / the standard library is defined in namespace std (§8.2.9)
extern"C" { / / stdio functions have C linkage (§9.2.4)
#endif
/ / ...
int printf(const char* ...) ;
/ / ...
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 9.2.2 Standard Library Headers 203
#ifdef__cplusplus
}
}
using namespace std; / / make stdio available in global namespace
#endif
That is, the actual declarations are (most likely) shared, but linkage and namespace issues must be
addressed to allow C and C++ to share a header.
9.2.3 The One-Definition Rule [file.odr]
A given class, enumeration, and template, etc., must be defined exactly once in a program.
From a practical point of view, this means that there must be exactly one definition of, say, a
class residing in a single file somewhere. Unfortunately, the language rule cannot be that simple.
For example, the definition of a class may be composed through macro expansion (ugh!), while a
definition of a class may be textually included in two source files by #includedirectives (§9.2.1).
Worse, a ‘‘file’’ isn’t a concept that is part of the C and C++ language definitions; there exist implementations that do not store programs in source files.
Consequently, the rule in the standard that says that there must be a unique definition of a class,
template, etc., is phrased in a somewhat more complicated and subtle manner. This rule is commonly referred to as ‘‘the one-definition rule,’’ the ODR. That is, two definitions of a class, template, or inline function are accepted as examples of the same unique definition if and only if
[1] they appear in different translation units, and
[2] they are token-for-token identical, and
[3] the meanings of those tokens are the same in both translation units.
For example:
/ / file1.c:
struct S{ int a; char b; };
void f(S*) ;
/ / file2.c:
struct S{ int a; char b; };
void f(S* p) { /* ... */ }
The ODR says that this example is valid and that Srefers to the same class in both source files.
However, it is unwise to write out a definition twice like that. Someone maintaining file2.cwill
naturally assume that the definition of Sin file2.cis the only definition of Sand so feel free to
change it. This could introduce a hard-to-detect error.
The intent of the ODR is to allow inclusion of a class definition in different translation units
from a common source file. For example:
/ / file s.h:
struct S{ int a; char b; };
void f(S*) ;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
204 Source Files and Programs Chapter 9
/ / file1.c:
#include"s.h"
/ / use f() here
/ / file2.c:
#include"s.h"
void f(S* p) { /* ... */ }
or graphically:
struct S{ int a; char b; };
void f(S*);
#include "s.h"
// use f() here
#include "s.h"
void f(S* p) { /* ...*/ }
s.h:
file1.c: file2.c:
Here are examples of the three ways of violating the ODR:
/ / file1.c:
struct S1{ int a; char b; };
struct S1{ int a; char b; }; / / error: double definition
This is an error because a structmay not be defined twice in a single translation unit.
/ / file1.c:
struct S2{ int a; char b; };
/ / file2.c:
struct S2{ int a; char bb; }; / / error
This is an error because S2is used to name classes that differ in a member name.
/ / file1.c:
typedef int X;
struct S3{ X a; char b; };
/ / file2.c:
typedef char X;
struct S3{ X a; char b; }; / / error
Here the two definitions of S3are token-for-token identical, but the example is an error because the
meaning of the name Xhas sneakily been made to differ in the two files.
Checking against inconsistent class definitions in separate translation units is beyond the ability
of most C++ implementations. Consequently, declarations that violate the ODR can be a source of
subtle errors. Unfortunately, the technique of placing shared definitions in headers and #including
them doesn’t protect against this last form of ODR violation. Local typedefs and macros can
change the meaning of #included declarations:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 9.2.3 The One-Definition Rule 205
/ / file s.h:
struct S{ Point a; char b; };
/ / file1.c:
#define Point int
#include"s.h"
/ / ...
/ / file2.c:
class Point{ /* ... */ };
#include"s.h"
/ / ...
The best defense against this kind of hackery is to make headers as self-contained as possible. For
example, if class Pointhad been declared in the s.hheader the error would have been detected.
A template definition can be #included in several translation units as long as the ODR is
adhered to. In addition, an exported template can be used given only a declaration:
/ / file1.c:
export template<class T> T twice(T t) { return t+t; }
/ / file2.c:
template<class T> T twice(T t) ; / / declaration
int g(int i) { return twice(i) ; }
The keyword exportmeans ‘‘accessible from another translation unit’’ (§13.7).
9.2.4 Linkage to Non-C++ Code [file.c]
Typically, a C++ program contains parts written in other languages. Similarly, it is common for
C++ code fragments to be used as parts of programs written mainly in some other language. Cooperation can be difficult between program fragments written in different languages and even between
fragments written in the same language but compiled with different compilers. For example, different languages and different implementations of the same language may differ in their use of
machine registers to hold arguments, the layout of arguments put on a stack, the layout of built-in
types such as strings and integers, the form of names passed by the compiler to the linker, and the
amount of type checking required from the linker. To help, one can specify a linkage convention to
be used in an externdeclaration. For example, this declares the C and C++ standard library function strcpy() and specifies that it should be linked according to the C linkage conventions:
extern"C" char* strcpy(char*, const char*) ;
The effect of this declaration differs from the effect of the ‘‘plain’’ declaration
extern char* strcpy(char*, const char*) ;
only in the linkage convention used for calling strcpy().
The extern "C"directive is particularly useful because of the close relationship between C and
C++. Note that the Cin extern "C"names a linkage convention and not a language. Often, extern
"C"is used to link to Fortran and assembler routines that happen to conform to the conventions of a
C implementation.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
206 Source Files and Programs Chapter 9
An extern "C"directive specifies the linkage convention (only) and does not affect the semantics of calls to the function. In particular, a function declared extern "C"still obeys the C++ type
checking and argument conversion rules and not the weaker C rules. For example:
extern"C" int f() ;
int g()
{
return f(1) ; / / error: no argument expected
}
Adding extern "C"to a lot of declarations can be a nuisance. Consequently, there is a mechanism
to specify linkage to a group of declarations. For example:
extern"C" {
char* strcpy(char*, const char*) ;
int strcmp(const char*, const char*) ;
int strlen(const char*) ;
/ / ...
}
This construct, commonly called a linkage block, can be used to enclose a complete C header to
make a header suitable for C++ use. For example:
extern"C" {
#include<string.h>
}
This technique is commonly used to produce a C++ header from a C header. Alternatively, conditional compilation (§7.8.1) can be used to create a common C and C++ header:
#ifdef__cplusplus
extern"C" {
#endif
char* strcpy(char*, const char*) ;
int strcmp(const char*, const char*) ;
int strlen(const char*) ;
/ / ...
#ifdef__cplusplus
}
#endif
The predefined macro name __cplusplusis used to ensure that the C++ constructs are edited out
when the file is used as a C header.
Any declaration can appear within a linkage block:
extern"C" { / / any declaration here, for example:
int g1; / / definition
extern int g2; / / declaration, not definition
}
In particular, the scope and storage class of variables are not affected, so g1is still a global variable
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 9.2.4 Linkage to Non-C++ Code 207
– and is still defined rather than just declared. To declare but not define a variable, you must apply
the keyword externdirectly in the declaration. For example:
extern"C" int g3; / / declaration, not definition
This looks odd at first glance. However, it is a simple consequence of keeping the meaning
unchanged when adding "C"to an extern declaration and the meaning of a file unchanged when
enclosing it in a linkage block.
A name with C linkage can be declared in a namespace. The namespace will affect the way the
name is accessed in the C++ program, but not the way a linker sees it. The printf() from stdis a
typical example:
#include<cstdio>
void f()
{
std: :printf("Hello, ") ; / / ok
printf("world!\n") ; / / error: no global printf()
}
Even when called std: :printf, it is still the same old C printf() (§21.8).
Note that this allows us to include libraries with C linkage into a namespace of our choice rather
than polluting the global namespace. Unfortunately, the same flexibility is not available to us for
headers defining functions with C++ linkage in the global namespace. The reason is that linkage of
C++ entities must take namespaces into account so that the object files generated will reflect the use
or lack of use of namespaces.
9.2.5 Linkage and Pointers to Functions [file.ptof]
When mixing C and C++ code fragments in one program, we sometimes want to pass pointers to
functions defined in one language to functions defined in the other. If the two implementations of
the two languages share linkage conventions and function-call mechanisms, such passing of pointers to functions is trivial. However, such commonality cannot in general be assumed, so care must
be taken to ensure that a function is called the way it expects to be called.
When linkage is specified for a declaration, the specified linkage applies to all function types,
function names, and variable names introduced by the declaration(s). This makes all kinds of
strange – and occasionally essential – combinations of linkage possible. For example:
typedef int(*FT)(const void*, const void*) ; / / FT has C++ linkage
extern"C" {
typedef int(*CFT)(const void*, const void*) ; / / CFT has C linkage
void qsort(void* p, size_t n, size_t sz, CFT cmp) ; / / cmp has C linkage
}
void isort(void* p, size_t n, size_t sz, FT cmp) ; / / cmp has C++ linkage
void xsort(void* p, size_t n, size_t sz, CFT cmp) ; / / cmp has C linkage
extern"C" void ysort(void* p, size_t n, size_t sz, FT cmp) ; / / cmp has C++ linkage
int compare(const void*, const void*) ; / / compare() has C++ linkage
extern"C" int ccmp(const void*, const void*) ; / / ccmp() has C linkage
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
208 Source Files and Programs Chapter 9
void f(char* v, int sz)
{
qsort(v,sz,1,&compare) ; / / error
qsort(v,sz,1,&ccmp) ; / / ok
isort(v,sz,1,&compare) ; / / ok
isort(v,sz,1,&ccmp) ; / / error
}
An implementation in which C and C++ use the same calling conventions might accept the cases
marked error as a language extension.
9.3 Using Header Files [file.using]
To illustrate the use of headers, I present a few alternative ways of expressing the physical structure
of the calculator program (§6.1, §8.2).
9.3.1 Single Header File [file.single]
The simplest solution to the problem of partitioning a program into several files is to put the definitions in a suitable number of .cfiles and to declare the types needed for them to communicate in a
single .hfile that each .cfile #includes. For the calculator program, we might use five .cfiles –
lexer.c, parser.c, table.c, error.c, and main.c– to hold function and data definitions, plus the
header dc.hto hold the declarations of every name used in more than one .cfile.
The header dc.hwould look like this:
/ / dc.h:
namespace Error{
struct Zero_divide{ };
struct Syntax_error{
const char* p;
Syntax_error(const char* q) { p= q; }
};
}
#include<string>
namespace Lexer{
enum Token_value{
NAME, NUMBER, END,
PLUS=´+´, MINUS=´-´, MUL=´*´, DIV=´/´,
PRINT=´;´, ASSIGN=´=´, LP=´(´, RP=´)´
};
extern Token_value curr_tok;
extern double number_value;
extern std: :string string_value;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 9.3.1 Single Header File 209
Token_value get_token() ;
}
namespace Parser{
double prim(bool get) ; / / handle primaries
double term(bool get) ; / / multiply and divide
double expr(bool get) ; / / add and subtract
using Lexer: :get_token;
using Lexer: :curr_tok;
}
#include<map>
extern std: :map<std: :string,double> table;
namespace Driver{
extern int no_of_errors;
extern std: :istream* input;
void skip() ;
}
The keyword externis used for every declaration of a variable to ensure that multiple definitions do
not occur as we #include dc.hin the various .cfiles. The corresponding definitions are found in
the appropriate .cfiles.
Leaving out the actual code, lexer.cwill look something like this:
/ / lexer.c:
#include"dc.h"
#include<iostream>
#include<cctype>
Lexer: :Token_value Lexer: :curr_tok;
double Lexer: :number_value;
std: :string Lexer: :string_value;
Lexer: :Token_value Lexer: :get_token() { /* ... */ }
Using headers in this manner ensures that every declaration in a header will at some point be
included in the file containing its definition. For example, when compiling lexer.cthe compiler
will be presented with:
namespace Lexer{ / / from dc.h
/ / ...
Token_value get_token() ;
}
/ / ...
Lexer: :Token_value Lexer: :get_token() { /* ... */ }
This ensures that the compiler will detect any inconsistencies in the types specified for a name. For
example, had get_token() been declared to return a Token_value, but defined to return an int, the
compilation of lexer.cwould have failed with a type-mismatch error. If a definition is missing,
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
210 Source Files and Programs Chapter 9
the linker will catch the problem. If a declaration is missing, some .cfile will fail to compile.
File parser.cwill look like this:
/ / parser.c:
#include"dc.h"
double Parser: :prim(bool get) { /* ... */ }
double Parser: :term(bool get) { /* ... */ }
double Parser: :expr(bool get) { /* ... */ }
File table.cwill look like this:
/ / table.c:
#include"dc.h"
std: :map<std: :string,double> table;
The symbol table is simply a variable of the standard library maptype. This defines tableto be
global. In a realistically-sized program, this kind of minor pollution of the global namespace builds
up and eventually causes problems. I left this sloppiness here simply to get an opportunity to warn
against it.
Finally, file main.cwill look like this:
/ / main.c:
#include"dc.h"
#include<sstream>
int Driver: :no_of_errors= 0;
std: :istream* Driver: :input= 0;
void Driver: :skip() { /* ... */ }
int main(int argc, char* argv[]) { /* ... */ }
To be recognized as the main() of the program, main() must be a global function, so no namespace is used here.
The physical structure of the system can be presented like this:
table.c. . parser.c. . driver.c. . lexer.c
. . dc.h
<string>. . <map>. . <cctype>. . <iostream>. . <sstream>.
Note that the headers on the top are all headers for standard library facilities. For many forms of
program analysis, these libraries can be ignored because they are well known and stable. For tiny
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 9.3.1 Single Header File 211
programs, the structure can be simplified by moving all #includedirectives to the common header.
This single-header style of physical partitioning is most useful when the program is small and
its parts are not intended to be used separately. Note that when namespaces are used, the logical
structure of the program is still represented within dc.h. If namespaces are not used, the structure
is obscured, although comments can be a help.
For larger programs, the single header file approach is unworkable in a conventional file-based
development environment. A change to the common header forces recompilation of the whole program, and updates of that single header by several programmers are error-prone. Unless strong
emphasis is placed on programming styles relying heavily on namespaces and classes, the logical
structure deteriorates as the program grows.
9.3.2 Multiple Header Files [file.multi]
An alternative physical organization lets each logical module have its own header defining the
facilities it provides. Each .cfile then has a corresponding .hfile specifying what it provides (its
interface). Each .cfile includes its own .hfile and usually also other .hfiles that specify what it
needs from other modules in order to implement the services advertised in the interface. This physical organization corresponds to the logical organization of a module. The interface for users is put
into its .hfile, the interface for implementers is put into a file suffixed _impl.h, and the module’s
definitions of functions, variables, etc. are placed in .cfiles. In this way, the parser is represented
by three files. The parser’s user interface is provided by parser.h:
/ / parser.h:
namespace Parser{ / / interface for users
double expr(bool get) ;
}
The shared environment for the functions implementing the parser is presented by parser_impl.h:
/ / parser_impl.h:
#include"parser.h"
#include"error.h"
#include"lexer.h"
namespace Parser{ / / interface for implementers
double prim(bool get) ;
double term(bool get) ;
double expr(bool get) ;
using Lexer: :get_token;
using Lexer: :curr_tok;
}
The user’s header parser.his #included to give the compiler a chance to check consistency
(§9.3.1).
The functions implementing the parser are stored in parser.ctogether with #includedirectives
for the headers that the Parserfunctions need:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
212 Source Files and Programs Chapter 9
/ / parser.c:
#include"parser_impl.h"
#include"table.h"
double Parser: :prim(bool get) { /* ... */ }
double Parser: :term(bool get) { /* ... */ }
double Parser: :expr(bool get) { /* ... */ }
Graphically, the parser and the driver’s use of it look like this:
parser.h. . lexer.h. . error.h. . table.h
. . parser_impl.h
. . driver.c. . parser.c
.
As intended, this is a rather close match to the logical structure described in §8.3.3. To simplify
this structure, we could have #included table.hin parser_impl.hrather than in parser.c. However, table.his an example of something that is not necessary to express the shared context of the
parser functions; it is needed only by their implementation. In fact, it is used by just one function,
expr(), so if we were really keen on minimizing dependencies we could place expr() in its own
.cfile and #include table.hthere only:
parser.h. . lexer.h. . error.h. . table.h
. . parser_impl.h
. . parser.c
.
expr.c
.
Such elaboration is not appropriate except for larger modules. For realistically-sized modules, it is
common to #includeextra files where needed for individual functions. Furthermore, it is not
uncommon to have more than one _impl.h, since different subsets of the module’s functions need
different shared contexts.
Please note that the _impl.hnotation is not a standard or even a common convention; it is simply the way I like to name things.
Why bother with this more complicated scheme of multiple header files? It clearly requires far
less thought simply to throw every declaration into a single header, as was done for dc.h.
The multiple-header organization scales to modules several magnitudes larger than our toy
parser and to programs several magnitudes larger than our calculator. The fundamental reason for
using this type of organization is that it provides a better localization of concerns. When analyzing
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 9.3.2 Multiple Header Files 213
and modifying a large program, it is essential for a programmer to focus on a relatively small chunk
of code. The multiple-header organization makes it easy to determine exactly what the parser code
depends on and to ignore the rest of the program. The single-header approach forces us to look at
every declaration used by any module and decide if it is relevant. The simple fact is that maintenance of code is invariably done with incomplete information and from a local perspective. The
multiple-header organization allows us to work successfully ‘‘from the inside out’’ with only a
local perspective. The single-header approach – like every other organization centered around a
global repository of information – requires a top-down approach and will forever leave us wondering exactly what depends on what.
The better localization leads to less information needed to compile a module, and thus to faster
compiles. The effect can be dramatic. I have seen compile times drop by a factor of ten as the
result of a simple dependency analysis leading to a better use of headers.
9.3.2.1 Other Calculator Modules [file.multi.etc]
The remaining calculator modules can be organized similarly to the parser. However, those modules are so small that they don’t require their own _impl.hfiles. Such files are needed only where
a logical module consists of many functions that need a shared context.
The error handler was reduced to the set of exception types so that no error.cwas needed:
/ / error.h:
namespace Error{
struct Zero_divide{ };
struct Syntax_error{
const char* p;
Syntax_error(const char* q) { p= q; }
};
}
The lexer provides a rather large and messy interface:
/ / lexer.h:
#include<string>
namespace Lexer{
enum Token_value{
NAME, NUMBER, END,
PLUS=´+´, MINUS=´-´, MUL=´*´, DIV=´/´,
PRINT=´;´, ASSIGN=´=´, LP=´(´, RP=´)´
};
extern Token_value curr_tok;
extern double number_value;
extern std: :string string_value;
Token_value get_token() ;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
214 Source Files and Programs Chapter 9
In addition to lexer.h, the implementation of the lexer depends on error.h, <iostream>, and the
functions determining the kinds of characters declared in <cctype>:
/ / lexer.c:
#include"lexer.h"
#include"error.h"
#include<iostream>
#include<cctype>
Lexer: :Token_value Lexer: :curr_tok;
double Lexer: :number_value;
std: :string Lexer: :string_value;
Lexer: :Token_value Lexer: :get_token() { /* ... */ }
We could have factored out the #includestatements for error.has the Lexer’s _impl.hfile.
However, I considered that excessive for this tiny program.
As usual, we #includethe interface offered by the module – in this case, lexer.h– in the
module’s implementation to give the compiler a chance to check consistency.
The symbol table is essentially self-contained, although the standard library header <map>
could drag in all kinds of interesting stuff to implement an efficient maptemplate class:
/ / table.h:
#include<map>
#include<string>
extern std: :map<std: :string,double> table;
Because we assume that every header may be #included in several .cfiles, we must separate the
declaration of tablefrom its definition, even though the difference between table.cand table.his
the single keyword extern:
/ / table.c:
#include"table.h"
std: :map<std: :string,double> table;
Basically, the driver depends on everything:
/ / main.c:
#include"parser.h"
#include"lexer.h"
#include"error.h"
#include"table.h"
namespace Driver{
int no_of_errors;
std: :istream* input;
void skip() ;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 9.3.2.1 Other Calculator Modules 215
#include<sstream>
int main(int argc, char* argv[]) { /* ... */ }
Because the Drivernamespace is used exclusively by main(), I placed it in main.c. Alternatively, I could have factored it out as driver.hand #included it.
For a larger system, it is usually worthwhile organizing things so that the driver has fewer direct
dependencies. Often, is it also worth minimizing what is done in main() by having main() call a
driver function placed in a separate source file. This is particularly important for code intended to
be used as a library. Then, we cannot rely on code in main() and must be prepared to be called
from a variety of functions (§9.6[8]).
9.3.2.2 Use of Headers [file.multi.use]
The number of headers to use for a program is a function of many factors. Many of these factors
have more to do with the way files are handled on your system than with C++. For example, if your
editor does not have facilities for looking at several files at the same time, then using many headers
becomes less attractive. Similarly, if opening and reading 20 files of 50 lines each is noticeably
more time-consuming than reading a single file of 1000 lines, you might think twice before using
the multiple-header style for a small project.
A word of caution: a dozen headers plus the standard headers for the program’s execution environment (which can often be counted in the hundreds) are usually manageable. However, if you
partition the declarations of a large program into the logically minimal-sized headers (putting each
structure declaration in its own file, etc.), you can easily get an unmanageable mess of hundreds of
files even for minor projects. I find that excessive.
For large projects, multiple headers are unavoidable. In such projects, hundreds of files (not
counting standard headers) are the norm. The real confusion starts when they start to be counted in
the thousands. At that scale, the basic techniques discussed here still apply, but their management
becomes a Herculean task. Remember that for realistically-sized programs, the single-header style
is not an option. Such programs will have multiple headers. The choice between the two styles of
organization occurs (repeatedly) for the parts that make up the program.
The single-header style and the multiple-header style are not really alternatives to each other.
They are complementary techniques that must be considered whenever a significant module is
designed and must be reconsidered as a system evolves. It’s crucial to remember that one interface
doesn’t serve all equally well. It is usually worthwhile to distinguish between the implementers’
interface and the users’ interface. In addition, many larger systems are structured so that providing
a simple interface for the majority of users and a more extensive interface for expert users is a good
idea. The expert users’ interfaces (‘‘complete interfaces’’) tend to #includemany more features
than the average user would ever want to know about. In fact, the average users’ interface can
often be identified by eliminating features that require the inclusion of headers that define facilities
that would be unknown to the average user. The term ‘‘average user’’ is not derogatory. In the
fields in which I don’t have to be an expert, I strongly prefer to be an average user. In that way, I
minimize hassles.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
216 Source Files and Programs Chapter 9
9.3.3 Include Guards [file.guards]
The idea of the multiple-header approach is to represent each logical module as a consistent, selfcontained unit. Viewed from the program as a whole, many of the declarations needed to make
each logical module complete are redundant. For larger programs, such redundancy can lead to
errors, as a header containing class definitions or inline functions gets #included twice in the same
compilation unit (§9.2.3).
We have two choices. We can
[1] reorganize our program to remove the redundancy, or
[2] find a way to allow repeated inclusion of headers.
The first approach – which led to the final version of the calculator – is tedious and impractical for
realistically-sized programs. We also need that redundancy to make the individual parts of the program comprehensible in isolation.
The benefits of an analysis of redundant #includes and the resulting simplifications of the program can be significant both from a logical point of view and by reducing compile times. However, it can rarely be complete, so some method of allowing redundant #includes must be applied.
Preferably, it must be applied systematically, since there is no way of knowing how thorough an
analysis a user will find worthwhile.
The traditional solution is to insert include guards in headers. For example:
/ / error.h:
#ifndef CALC_ERROR_H
#define CALC_ERROR_H
namespace Error{
/ / ...
}
#endif/ / CALC_ERROR_H
The contents of the file between the #ifndefand #endifare ignored by the compiler if
CALC_ERROR_His defined. Thus, the first time error.his seen during a compilation, its contents are read and CALC_ERROR_His given a value. Should the compiler be presented with
error.hagain during the compilation, the contents are ignored. This is a piece of macro hackery,
but it works and it is pervasive in the C and C++ worlds. The standard headers all have include
guards.
Header files are included in essentially arbitrary contexts, and there is no namespace protection
against macro name clashes. Consequently, I choose rather long and ugly names as my include
guards.
Once people get used to headers and include guards, they tend to include lots of headers directly
and indirectly. Even with C++ implementations that optimize the processing of headers, this can be
undesirable. It can cause unnecessarily long compile time, and it can bring lotsof declarations and
macros into scope. The latter might affect the meaning of the program in unpredictable and adverse
ways. Headers should be included only when necessary.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 9.4 Programs 217
9.4 Programs [file.programs]
A program is a collection of separately compiled units combined by a linker. Every function,
object, type, etc., used in this collection must have a unique definition (§4.9, §9.2.3). The program
must contain exactly one function called main() (§3.2). The main computation performed by the
program starts with the invocation of main() and ends with a return from main(). The int
returned by main() is passed to whatever system invoked main() as the result of the program.
This simple story must be elaborated on for programs that contain global variables (§10.4.9) or
that throw an uncaught exception (§14.7).
9.4.1 Initialization of Nonlocal Variables [file.nonlocal]
In principle, a variable defined outside any function (that is, global, namespace, and class static
variables) is initialized before main() is invoked. Such nonlocal variables in a translation unit are
initialized in their declaration order (§10.4.9). If such a variable has no explicit initializer, it is by
default initialized to the default for its type (§10.4.2). The default initializer value for built-in types
and enumerations is 0. For example:
double x= 2; / / nonlocal variables
double y;
double sqx= sqrt(x+y) ;
Here, xand yare initialized before sqx, so sqrt(2) is called.
There is no guaranteed order of initialization of global variables in different translation units.
Consequently, it is unwise to create order dependencies between initializers of global variables in
different compilation units. In addition, it is not possible to catch an exception thrown by the initializer of a global variable (§14.7). It is generally best to minimize the use of global variables and
in particular to limit the use of global variables requiring complicated initialization.
Several techniques exist for enforcing an order of initialization of global variables in different
translation units. However, none are both portable and efficient. In particular, dynamically linked
libraries do not coexist happily with global variables that have complicated dependencies.
Often, a function returning a reference is a good alternative to a global variable. For example:
int& use_count()
{
static int uc= 0;
return uc;
}
A call use_count() now acts as a global variable except that it is initialized at its first use (§5.5).
For example:
void f()
{
cout<< ++use_count() ; / / read and increment
/ / ...
}
The initialization of nonlocal static variables is controlled by whatever mechanism an
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
218 Source Files and Programs Chapter 9
implementation uses to start up a C++ program. This mechanism is guaranteed to work properly
only if main() is executed. Consequently, one should avoid nonlocal variables that require runtime initialization in C++ code intended for execution as a fragment of a non-C++ program.
Note that variables initialized by constant expressions (§C.5) cannot depend on the value of
objects from other translation units and do not require run-time initialization. Such variables are
therefore safe to use in all cases.
9.4.1.1 Program Termination [file.termination]
A program can terminate in several ways:
– By returning from main()
– By calling exit()
– By calling abort()
– By throwing an uncaught exception
In addition, there are a variety of ill-behaved and implementation-dependent ways of making a program crash.
If a program is terminated using the standard library function exit(), the destructors for constructed static objects are called (§10.4.9, §10.2.4). However, if the program is terminated using
the standard library function abort(), they are not. Note that this implies that exit() does not terminate a program immediately. Calling exit() in a destructor may cause an infinite recursion. The
type of exit() is
void exit(int) ;
Like the return value of main() (§3.2), exit()’s argument is returned to ‘‘the system’’ as the value
of the program. Zero indicates successful completion.
Calling exit() means that the local variables of the calling function and its callers will not have
their destructors invoked. Throwing an exception and catching it ensures that local objects are
properly destroyed (§14.4.7). Also, a call of exit() terminates the program without giving the
caller of the function that called exit() a chance to deal with the problem. It is therefore often best
to leave a context by throwing an exception and letting a handler decide what to do next.
The C (and C++) standard library function atexit() offers the possibility to have code executed
at program termination. For example:
void my_cleanup() ;
void somewhere()
{
if(atexit(&my_cleanup)==0) {
/ / my_cleanup will be called at normal termination
}
else{
/ / oops: too many atexit functions
}
}
This strongly resembles the automatic invocation of destructors for global variables at program termination (§10.4.9, §10.2.4). Note that an argument to atexit() cannot take arguments or return a
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 9.4.1.1 Program Termination 219
result. Also, there is an implementation-defined limit to the number of atexit functions; atexit()
indicates when that limit is reached by returning a nonzero value. These limitations make atexit()
less useful than it appears at first glance.
The destructor of an object created before a call of atexit(f) will be invoked after fis invoked.
The destructor of an object created after a call of atexit(f) will be invoked before fis invoked.
The exit(), abort(), and atexit() functions are declared in <cstdlib>.
9.5 Advice [file.advice]
[1] Use header files to represent interfaces and to emphasize logical structure; §9.1, §9.3.2.
[2] #includea header in the source file that implements its functions; §9.3.1.
[3] Don’t define global entities with the same name and similar-but-different meanings in different translation units; §9.2.
[4] Avoid non-inline function definitions in headers; §9.2.1.
[5] Use #includeonly at global scope and in namespaces; §9.2.1.
[6] #includeonly complete declarations; §9.2.1.
[7] Use include guards; §9.3.3.
[8] #includeC headers in namespaces to avoid global names; §9.3.2.
[9] Make headers self-contained; §9.2.3.
[10] Distinguish between users’ interfaces and implementers’ interfaces; §9.3.2.
[11] Distinguish between average users’ interfaces and expert users’ interfaces; §9.3.2.
[12] Avoid nonlocal objects that require run-time initialization in code intended for use as part of
non-C++ programs; §9.4.1.
9.6 Exercises [file.exercises]
1. (∗2) Find where the standard library headers are kept on your system. List their names. Are
any nonstandard headers kept together with the standard ones? Can any nonstandard headers be
#included using the <> notation?
2. (∗2) Where are the headers for nonstandard library ‘‘foundation’’ libraries kept?
3. (∗2.5) Write a program that reads a source file and writes out the names of files #included.
Indent file names to show files #includedby included files. Try this program on some real
source files (to get an idea of the amount of information included).
4. (∗3) Modify the program from the previous exercise to print the number of comment lines, the
number of non-comment lines, and the number of non-comment, whitespace-separated words
for each file #included.
5. (∗2.5) An external include guard is a construct that tests outside the file it is guarding and
includes only once per compilation. Define such a construct, devise a way of testing it, and discuss its advantages and disadvantages compared to the include guards described in §9.3.3. Is
there any significant run-time advantage to external include guards on your system.
6. (∗3) How is dynamic linking achieved on your system. What restrictions are placed on dynamically linked code? What requirements are placed on code for it to be dynamically linked?
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
220 Source Files and Programs Chapter 9
7. (∗3) Open and read 100 files containing 1500 characters each. Open and read one file containing 150,000 characters. Hint: See example in §21.5.1. Is there a performance difference?
What is the highest number of files that can be simultaneously open on your system? Consider
these questions in relation to the use of #includefiles.
8. (∗2) Modify the desk calculator so that it can be invoked from main() or from other functions
as a simple function call.
9. (∗2) Draw the ‘‘module dependency diagrams’’ (§9.3.2) for the version of the calculator that
used error() instead of exceptions (§8.2.2).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Part II
Abstraction Mechanisms
This part describes C++’s facilities for defining and using new types. Techniques commonly called object-oriented programming and generic programming are presented.
Chapters
10 Classes
11 Operator Overloading
12 Derived Classes
13 Templates
14 Exception Handling
15 Class Hierarchies
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
222 Abstraction Mechanisms Part II
‘‘... there is nothing more difficult to carry out, nor more doubtful of success, nor more
dangerous to handle, than to initiate a new order of things. For the reformer makes
enemies of all those who profit by the old order, and only lukewarm defenders in all
those who would profit by the new order...’’
— Nicollo Machiavelli (‘‘The Prince’’ §vi)
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
10 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
Classes
Those types are not "abstract";
they are as real as int and float.
– Doug McIlroy
Concepts and classes — class members — access control — constructors — static
members — default copy — constmember functions — this— structs — in-class function definition — concrete classes — member functions and helper functions — overloaded operators — use of concrete classes — destructors — default construction —
local variables — user-defined copy — newand delete— member objects — arrays —
static storage — temporary variables — unions — advice — exercises.
10.1 Introduction [class.intro]
The aim of the C++ class concept is to provide the programmer with a tool for creating new types
that can be used as conveniently as the built-in types. In addition, derived classes (Chapter 12) and
templates (Chapter 13) provide ways of organizing related classes that allow the programmer to
take advantage of their relationships.
A type is a concrete representation of a concept. For example, the C++ built-in type floatwith
its operations +, -, *, etc., provides a concrete approximation of the mathematical concept of a real
number. A class is a user-defined type. We design a new type to provide a definition of a concept
that has no direct counterpart among the built-in types. For example, we might provide a type
Trunk_linein a program dealing with telephony, a type Explosionfor a videogame, or a type
list<Paragraph> for a text-processing program. A program that provides types that closely match
the concepts of the application tends to be easier to understand and easier to modify than a program
that does not. A well-chosen set of user-defined types makes a program more concise. In addition,
it makes many sorts of code analysis feasible. In particular, it enables the compiler to detect illegal
uses of objects that would otherwise remain undetected until the program is thoroughly tested.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
224 Classes Chapter 10
The fundamental idea in defining a new type is to separate the incidental details of the implementation (e.g., the layout of the data used to store an object of the type) from the properties essential to the correct use of it (e.g., the complete list of functions that can access the data). Such a separation is best expressed by channeling all uses of the data structure and internal housekeeping routines through a specific interface.
This chapter focuses on relatively simple ‘‘concrete’’ user-defined types that logically don’t differ much from built-in types. Ideally, such types should not differ from built-in types in the way
they are used, only in the way they are created.
10.2 Classes [class.class]
A class is a user-defined type. This section introduces the basic facilities for defining a class, creating objects of a class, and manipulating such objects.
10.2.1 Member Functions [class.member]
Consider implementing the concept of a date using a structto define the representation of a Date
and a set of functions for manipulating variables of this type:
struct Date{ / / representation
int d, m, y;
};
void init_date(Date& d, int, int, int) ; / / initialize d
void add_year(Date& d, int n) ; / / add n years to d
void add_month(Date& d, int n) ; / / add n months to d
void add_day(Date& d, int n) ; / / add n days to d
There is no explicit connection between the data type and these functions. Such a connection can
be established by declaring the functions as members:
struct Date{
int d, m, y;
void init(int dd, int mm, int yy) ; / / initialize
void add_year(int n) ; / / add n years
void add_month(int n) ; / / add n months
void add_day(int n) ; / / add n days
};
Functions declared within a class definition (a structis a kind of class; §10.2.8) are called member
functions and can be invoked only for a specific variable of the appropriate type using the standard
syntax for structure member access. For example:
Date my_birthday;
void f()
{
Date today;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.2.1 Member Functions 225
today.init(16,10,1996) ;
my_birthday.init(30,12,1950) ;
Date tomorrow= today;
tomorrow.add_day(1) ;
/ / ...
}
Because different structures can have member functions with the same name, we must specify the
structure name when defining a member function:
void Date: :init(int dd, int mm, int yy)
{
d= dd;
m= mm;
y= yy;
}
In a member function, member names can be used without explicit reference to an object. In that
case, the name refers to that member of the object for which the function was invoked. For example, when Date: :init() is invoked for today, m=mmassigns to today.m. On the other hand,
when Date: :init() is invoked for my_birthday, m=mmassigns to my_birthday.m. A class
member function always ‘‘knows’’ for which object it was invoked.
The construct
class X{ ... };
is called a class definition because it defines a new type. For historical reasons, a class definition is
often referred to as a class declaration. Also, like declarations that are not definitions, a class definition can be replicated in different source files using #includewithout violating the one-definition
rule (§9.2.3).
10.2.2 Access Control [class.access]
The declaration of Datein the previous subsection provides a set of functions for manipulating a
Date. However, it does not specify that those functions should be the only ones to depend directly
on Date’s representation and the only ones to directly access objects of class Date. This restriction
can be expressed by using a classinstead of a struct:
class Date{
int d, m, y;
public:
void init(int dd, int mm, int yy) ; / / initialize
void add_year(int n) ; / / add n years
void add_month(int n) ; / / add n months
void add_day(int n) ; / / add n days
};
The publiclabel separates the class body into two parts. The names in the first, private, part can be
used only by member functions. The second, public, part constitutes the public interface to objects
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
226 Classes Chapter 10
of the class. A structis simply a classwhose members are public by default (§10.2.8); member
functions can be defined and used exactly as before. For example:
inline void Date: :add_year(int n)
{
y+= n;
}
However, nonmember functions are barred from using private members. For example:
void timewarp(Date& d)
{
d.y-= 200; / / error: Date::y is private
}
There are several benefits to be obtained from restricting access to a data structure to an explicitly
declared list of functions. For example, any error causing a Dateto take on an illegal value (for
example, December 36, 1985) must be caused by code in a member function. This implies that the
first stage of debugging – localization – is completed before the program is even run. This is a
special case of the general observation that any change to the behavior of the type Datecan and
must be effected by changes to its members. In particular, if we change the representation of a
class, we need only change the member functions to take advantage of the new representation.
User code directly depends only on the public interface and need not be rewritten (although it may
need to be recompiled). Another advantage is that a potential user need examine only the definition
of the member functions in order to learn to use a class.
The protection of private data relies on restriction of the use of the class member names. It can
therefore be circumvented by address manipulation and explicit type conversion. But this, of
course, is cheating. C++ protects against accident rather than deliberate circumvention (fraud).
Only hardware can protect against malicious use of a general-purpose language, and even that is
hard to do in realistic systems.
The init() function was added partially because it is generally useful to have a function that
sets the value of an object and partly because making the data private forces us to provide it.
10.2.3 Constructors [class.ctor]
The use of functions such as init() to provide initialization for class objects is inelegant and errorprone. Because it is nowhere stated that an object must be initialized, a programmer can forget to
do so – or do so twice (often with equally disastrous results). A better approach is to allow the programmer to declare a function with the explicit purpose of initializing objects. Because such a
function constructs values of a given type, it is called a constructor. A constructor is recognized by
having the same name as the class itself. For example:
class Date{
/ / ...
Date(int, int, int) ; / / constructor
};
When a class has a constructor, all objects of that class will be initialized. If the constructor
requires arguments, these arguments must be supplied:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.2.3 Constructors 227
Date today= Date(23,6,1983) ;
Date xmas(25,12,1990) ; / / abbreviated form
Date my_birthday; / / error: initializer missing
Date release1_0(10,12) ; / / error: 3rd argument missing
It is often nice to provide several ways of initializing a class object. This can be done by providing
several constructors. For example:
class Date{
int d, m, y;
public:
/ / ...
Date(int, int, int) ; / / day, month, year
Date(int, int) ; / / day, month, today’s year
Date(int) ; / / day, today’s month and year
Date() ; / / default Date: today
Date(const char*) ; / / date in string representation
};
Constructors obey the same overloading rules as do other functions (§7.4). As long as the constructors differ sufficiently in their argument types, the compiler can select the correct one for each use:
Date today(4) ;
Date july4("July 4, 1983") ;
Date guy("5 Nov") ;
Date now; / / default initialized as today
The proliferation of constructors in the Dateexample is typical. When designing a class, a programmer is always tempted to add features just because somebody might want them. It takes more
thought to carefully decide what features are really needed and to include only those. However,
that extra thought typically leads to smaller and more comprehensible programs. One way of
reducing the number of related functions is to use default arguments (§7.5). In the Date, each argument can be given a default value interpreted as ‘‘pick the default: today.’’
class Date{
int d, m, y;
public:
Date(int dd=0, int mm=0, int yy=0) ;
/ / ...
};
Date: :Date(int dd, int mm, int yy)
{
d= dd? dd: today.d;
m= mm? mm: today.m;
y= yy? yy: today.y;
/ / check that the Date is valid
}
When an argument value is used to indicate ‘‘pick the default,’’ the value chosen must be outside
the set of possible values for the argument. For dayand month, this is clearly so, but for year, zero
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
228 Classes Chapter 10
may not be an obvious choice. Fortunately, there is no year zero on the European calendar; 1AD
(year==1) comes immediately after 1BC (year==-1).
10.2.4 Static Members [class.static]
The convenience of a default value for Dates was bought at the cost of a significant hidden problem. Our Dateclass became dependent on the global variable today. This Dateclass can be used
only in a context in which todayis defined and correctly used by every piece of code. This is the
kind of constraint that causes a class to be useless outside the context in which it was first written.
Users get too many unpleasant surprises trying to use such context-dependent classes, and maintenance becomes messy. Maybe ‘‘just one little global variable’’ isn’t too unmanageable, but that
style leads to code that is useless except to its original programmer. It should be avoided.
Fortunately, we can get the convenience without the encumbrance of a publicly accessible global variable. A variable that is part of a class, yet is not part of an object of that class, is called a
staticmember. There is exactly one copy of a staticmember instead of one copy per object, as for
ordinary non-staticmembers. Similarly, a function that needs access to members of a class, yet
doesn’t need to be invoked for a particular object, is called a staticmember function.
Here is a redesign that preserves the semantics of default constructor values for Datewithout
the problems stemming from reliance on a global:
class Date{
int d, m, y;
static Date default_date;
public:
Date(int dd=0, int mm=0, int yy=0) ;
/ / ...
static void set_default(int, int, int) ;
};
We can now define the Dateconstructor like this:
Date: :Date(int dd, int mm, int yy)
{
d= dd? dd: default_date.d;
m= mm? mm: default_date.m;
y= yy? yy: default_date.y;
/ / check that the Date is valid
}
We can change the default date when appropriate. A static member can be referred to like any
other member. In addition, a static member can be referred to without mentioning an object.
Instead, its name is qualified by the name of its class. For example:
void f()
{
Date: :set_default(4,5,1945) ;
}
Static members – both function and data members – must be defined somewhere. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.2.4 Static Members 229
Date Date: :default_date(16,12,1770) ;
void Date: :set_default(int d, int m, int y)
{
Date: :default_date= Date(d,m,y) ;
}
Now the default value is Beethoven’s birth date – until someone decides otherwise.
Note that Date() serves as a notation for the value of Date: :default_date. For example:
Date copy_of_default_date= Date() ;
Consequently, we don’t need a separate function for reading the default date.
10.2.5 Copying Class Objects [class.default.copy]
By default, class objects can be copied. In particular, a class object can be initialized with a copy
of another object of the same class. This can be done even where constructors have been declared.
For example:
Date d= today; / / initialization by copy
By default, the copy of a class object is a copy of each member. If that default is not the behavior
wanted for a class X, a more appropriate behavior can be provided by defining a copy constructor,
X: :X(const X&). This is discussed further in §10.4.4.1.
Similarly, class objects can by default be copied by assignment. For example:
void f(Date& d)
{
d= today;
}
Again, the default semantics is memberwise copy. If that is not the right choice for a class X, the
user can define an appropriate assignment operator (§10.4.4.1).
10.2.6 Constant Member Functions [class.constmem]
The Datedefined so far provides member functions for giving a Datea value and changing it.
Unfortunately, we didn’t provide a way of examining the value of a Date. This problem can easily
be remedied by adding functions for reading the day, month, and year:
class Date{
int d, m, y;
public:
int day() const{ return d; }
int month() const{ return m; }
int year() const;
/ / ...
};
Note the constafter the (empty) argument list in the function declarations. It indicates that these
functions do not modify the state of a Date.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
230 Classes Chapter 10
Naturally, the compiler will catch accidental attempts to violate this promise. For example:
inline int Date: :year() const
{
return y++; / / error: attempt to change member value in const function
}
When a constmember function is defined outside its class, the constsuffix is required:
inline int Date: :year() const/ / correct
{
return y;
}
inline int Date: :year() / / error: const missing in member function type
{
return y;
}
In other words, the constis part of the type of Date: :day() and Date: :year().
A constmember function can be invoked for both constand non-constobjects, whereas a nonconstmember function can be invoked only for non-constobjects. For example:
void f(Date& d, const Date& cd)
{
int i= d.year() ; / / ok
d.add_year(1) ; / / ok
int j= cd.year() ; / / ok
cd.add_year(1) ; / / error: cannot change value of const cd
}
10.2.7 Self-Reference [class.this]
The state update functions add_year(), add_month(), and add_day() were defined not to return
values. For such a set of related update functions, it is often useful to return a reference to the
updated object so that the operations can be chained. For example, we would like to write
void f(Date& d)
{
/ / ...
d.add_day(1).add_month(1).add_year(1) ;
/ / ...
}
to add a day, a month, and a year to d. To do this, each function must be declared to return a reference to a Date:
class Date{
/ / ...
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.2.7 Self-Reference 231
Date& add_year(int n) ; / / add n years
Date& add_month(int n) ; / / add n months
Date& add_day(int n) ; / / add n days
};
Each (nonstatic) member function knows what object it was invoked for and can explictly refer to
it. For example:
Date& Date: :add_year(int n)
{
if(d==29&& m==2&& !leapyear(y+n)) { / / beware of February 29
d= 1;
m= 3;
}
y+= n;
return*this;
}
The expression *thisrefers to the object for which a member function is invoked. It is equivalent
to Simula’s THISand Smalltalk’s self.
In a nonstatic member function, the keyword thisis a pointer to the object for which the function was invoked. In a non-constmember function of class X, the type of thisis X*const. The
constmakes it clear that the user is not supposed to change the value of this. In a constmember
function of class X, the type of thisis const X*constto prevent modification of the object itself
(see also §5.4.1).
Most uses of thisare implicit. In particular, every reference to a nonstatic member from within
a class relies on an implicit use of thisto get the member of the appropriate object. For example,
the add_yearfunction could equivalently, but tediously, have been defined like this:
Date& Date: :add_year(int n)
{
if(this->d==29&& this->m==2&& !leapyear(this->y+n)) {
this->d= 1;
this->m= 3;
}
this->y+= n;
return*this;
}
One common explicit use of thisis in linked-list manipulation (e.g., §24.3.7.4).
10.2.7.1 Physical and Logical Constness [class.const]
Occasionally, a member function is logically const, but it still needs to change the value of a member. To a user, the function appears not to change the state of its object. However, some detail that
the user cannot directly observe is updated. This is often called logical constness. For example,
the Dateclass might have a function returning a string representation that a user could use for output. Constructing this representation could be a relatively expensive operation. Therefore, it would
make sense to keep a copy so that repeated requests would simply return the copy, unless the
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
232 Classes Chapter 10
Date’s value had been changed. Caching values like that is more common for more complicated
data structures, but let’s see how it can be achieved for a Date:
class Date{
bool cache_valid;
string cache;
void compute_cache_value() ; / / fill cache
/ / ...
public:
/ / ...
string string_rep() const; / / string representation
};
From a user’s point of view, string_repdoesn’t change the state of its Date, so it clearly should be
a constmember function. On the other hand, the cache needs to be filled before it can be used.
This can be achieved through brute force:
string Date: :string_rep() const
{
if(cache_valid== false) {
Date* th= const_cast<Date*>(this) ; / / cast away const
th->compute_cache_value() ;
th->cache_valid= true;
}
return cache;
}
That is, the const_castoperator (§15.4.2.1) is used to obtain a pointer of type Date* to this. This
is hardly elegant, and it is not guaranteed to work when applied to an object that was originally
declared as a const. For example:
Date d1;
const Date d2;
string s1= d1.string_rep() ;
string s2= d2.string_rep() ; / / undefined behavior
In the case of d1, string_rep() simply casts back to d1’s original type so that the call will work.
However, d2was defined as a constand the implementation could have applied some form of
memory protection to ensure that its value wasn’t corrupted. Consequently, d2.string_rep() is
not guaranteed to give a single predictable result on all implementations.
10.2.7.2 Mutable [class.mutable]
The explicit type conversion ‘‘casting away const’’ and its consequent implementation-dependent
behavior can be avoided by declaring the data involved in the cache management to be mutable:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.2.7.2 Mutable 233
class Date{
mutable bool cache_valid;
mutable string cache;
void compute_cache_value() const; / / fill (mutable) cache
/ / ...
public:
/ / ...
string string_rep() const; / / string representation
};
The storage specifier mutablespecifies that a member should be stored in a way that allows updating – even when it is a member of a constobject. In other words, mutablemeans ‘‘can never be
const.’’ This can be used to simplify the definition of string_rep():
string Date: :string_rep() const
{
if(!cache_valid) {
compute_cache_value() ;
cache_valid= true;
}
return cache;
}
and makes reasonable uses of string_rep() valid. For example:
Date d3;
const Date d4;
string s3= d3.string_rep() ;
string s4= d4.string_rep() ; / / ok!
Declaring members mutableis most appropriate when (only) part of a representation is allowed to
change. If most of an object changes while the object remains logically const, it is often better to
place the changing data in a separate object and access it indirectly. If that technique is used, the
string-with-cache example becomes:
struct cache{
bool valid;
string rep;
};
class Date{
cache* c; / / initialize in constructor (§10.4.6)
void compute_cache_value() const; / / fill what cache refers to
/ / ...
public:
/ / ...
string string_rep() const; / / string representation
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
234 Classes Chapter 10
string Date: :string_rep() const
{
if(!c->valid) {
compute_cache_value() ;
c->valid= true;
}
return c->rep;
}
The programming techniques that support a cache generalize to various forms of lazy evaluation.
10.2.8 Structures and Classes [class.struct]
By definition, a structis a class in which members are by default public; that is,
struct s{ ...
is simply shorthand for
class s{ public: ...
The access specifier private: can be used to say that the members following are private, just as
public: says that the members following are public. Except for the different names, the following
declarations are equivalent:
class Date1{
int d, m, y;
public:
Date1(int dd, int mm, int yy) ;
void add_year(int n) ; / / add n years
};
struct Date2{
private:
int d, m, y;
public:
Date2(int dd, int mm, int yy) ;
void add_year(int n) ; / / add n years
};
Which style you use depends on circumstances and taste. I usually prefer to use structfor classes
that have all data public. I think of such classes as ‘‘not quite proper types, just data structures.’’
Constructors and access functions can be quite useful even for such structures, but as a shorthand
rather than guarantors of properties of the type (invariants, see §24.3.7.1).
It is not a requirement to declare data first in a class. In fact, it often makes sense to place data
members last to emphasize the functions providing the public user interface. For example:
class Date3{
public:
Date3(int dd, int mm, int yy) ;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.2.8 Structures and Classes 235
void add_year(int n) ; / / add n years
private:
int d, m, y;
};
In real code, where both the public interface and the implementation details typically are more
extensive than in tutorial examples, I usually prefer the style used for Date3.
Access specifiers can be used many times in a single class declaration. For example:
class Date4{
public:
Date4(int dd, int mm, int yy) ;
private:
int d, m, y;
public:
void add_year(int n) ; / / add n years
};
Having more than one public section, as in Date4, tends to be messy. So does having more than
one private section. However, allowing many access specifiers in a class is useful for machinegenerated code.
10.2.9 In-Class Function Definitions [class.inline]
A member function defined within the class definition – rather than simply declared there – is
taken to be an inline member function. That is, in-class definition of member functions is for small,
frequently-used functions. Like the class definition it is part of, a member function defined in-class
can be replicated in several translation units using #include. Like the class itself, its meaning must
be the same wherever it is used (§9.2.3).
The style of placing the definition of data members last in a class can lead to a minor problem
with public inline functions that refer to the representation. Consider:
class Date{ / / potentially confusing
public:
int day() const{ return d; } / / return Date::d
/ / ...
private:
int d, m, y;
};
This is perfectly good C++ code because a member function declared within a class can refer to
every member of the class as if the class were completely defined before the member function bodies were considered. However, this can confuse human readers.
Consequently, I usually either place the data first or define the inline member functions after the
class itself. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
236 Classes Chapter 10
class Date{
public:
int day() const;
/ / ...
private:
int d, m, y;
};
inline int Date: :day() const{ return d; }
10.3 Efficient User-Defined Types [class.concrete]
The previous section discussed bits and pieces of the design of a Dateclass in the context of introducing the basic language features for defining classes. Here, I reverse the emphasis and discuss
the design of a simple and efficient Dateclass and show how the language features support this
design.
Small, heavily-used abstractions are common in many applications. Examples are Latin characters, Chinese characters, integers, floating-point numbers, complex numbers, points, pointers, coordinates, transforms, (pointer,offset) pairs, dates, times, ranges, links, associations, nodes,
(value,unit) pairs, disk locations, source code locations, BCDcharacters, currencies, lines, rectangles, scaled fixed-point numbers, numbers with fractions, character strings, vectors, and arrays.
Every application uses several of these. Often, a few of these simple concrete types are used heavily. A typical application uses a few directly and many more indirectly from libraries.
C++ and other programming languages directly support a few of these abstractions. However,
most are not, and cannot be, supported directly because there are too many of them. Furthermore,
the designer of a general-purpose programming language cannot foresee the detailed needs of every
application. Consequently, mechanisms must be provided for the user to define small concrete
types. Such types are called concrete types or concrete classes to distinguish them from abstract
classes (§12.3) and classes in class hierarchies (§12.2.4, §12.4).
It was an explicit aim of C++ to support the definition and efficient use of such user-defined
data types very well. They are a foundation of elegant programming. As usual, the simple and
mundane is statistically far more significant than the complicated and sophisticated.
In this light, let us build a better date class:
class Date{
public: / / public interface:
enum Month{ jan=1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec};
class Bad_date{ }; / / exception class
Date(int dd=0, Month mm=Month(0) , int yy=0) ; / / 0 means ‘‘pick a default’’
/ / functions for examining the Date:
int day() const;
Month month() const;
int year() const;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.3 Efficient User-Defined Types 237
string string_rep() const; / / string representation
void char_rep(char s[]) const; / / C-style string representation
static void set_default(int, Month, int) ;
/ / functions for changing the Date:
Date& add_year(int n) ; / / add n years
Date& add_month(int n) ; / / add n months
Date& add_day(int n) ; / / add n days
private:
int d, m, y; / / representation
static Date default_date;
};
This set of operations is fairly typical for a user-defined type:
[1] A constructor specifying how objects/variables of the type are to be initialized.
[2] A set of functions allowing a user to examine a Date. These functions are marked constto
indicate that they don’t modify the state of the object/variable for which they are called.
[3] A set of functions allowing the user to manipulate Dates without actually having to know
the details of the representation or fiddle with the intricacies of the semantics.
[4] A set of implicitly defined operations to allow Dates to be freely copied.
[5] A class, Bad_date, to be used for reporting errors as exceptions.
I defined a Monthtype to cope with the problem of remembering, for example, whether the 7th of
June is written Date(6,7) (American style) or Date(7,6) (European style). I also added a
mechanism for dealing with default arguments.
I considered introducing separate types Dayand Yearto cope with possible confusion of
Date(1995,jul,27) and Date(27,jul,1995). However, these types would not be as useful as
the Monthtype. Almost all such errors are caught at run-time anyway – the 26th of July year 27 is
not a common date in my work. How to deal with historical dates before year 1800 or so is a tricky
issue best left to expert historians. Furthermore, the day of the month can’t be properly checked in
isolation from its month and year. See §11.7.1 for a way of defining a convenient Yeartype.
The default date must be defined as a valid Datesomewhere. For example:
Date Date: :default_date(22,jan,1901) ;
I omitted the cache technique from §10.2.7.1 as unnecessary for a type this simple. If needed, it
can be added as an implementation detail without affecting the user interface.
Here is a small – and contrived – example of how Dates can be used:
void f(Date& d)
{
Date lvb_day= Date(16,Date: :dec,d.year()) ;
if(d.day()==29&& d.month()==Date: :feb) {
/ / ...
}
if(midnight()) d.add_day(1) ;
cout<< "day after:" << d+1<< ´\n´;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
238 Classes Chapter 10
This assumes that the output operator << and the addition operator + have been declared for Dates.
I do that in §10.3.3.
Note the Date: :febnotation. The function f() is not a member of Date, so it must specify that
it is referring to Date’s feband not to some other entity.
Why is it worthwhile to define a specific type for something as simple as a date? After all, we
could define a structure:
struct Date{
int day, month, year;
};
and let programmers decide what to do with it. If we did that, though, every user would either have
to manipulate the components of Dates directly or provide separate functions for doing so. In
effect, the notion of a date would be scattered throughout the system, which would make it hard to
understand, document, or change. Inevitably, providing a concept as only a simple structure causes
extra work for every user of the structure.
Also, even though the Datetype seems simple, it takes some thought to get right. For example,
incrementing a Datemust deal with leap years, with the fact that months are of different lengths,
and so on (note: §10.6[1]). Also, the day-month-and-year representation is rather poor for many
applications. If we decided to change it, we would need to modify only a designated set of functions. For example, to represent a Dateas the number of days before or after January 1, 1970, we
would need to change only Date’s member functions (§10.6[2]).
10.3.1 Member Functions [class.memfct]
Naturally, an implementation for each member function must be provided somewhere. For example, here is the definition of Date’s constructor:
Date: :Date(int dd, Month mm, int yy)
{
if(yy== 0) yy= default_date.year() ;
if(mm== 0) mm= default_date.month() ;
if(dd== 0) dd= default_date.day() ;
int max;
switch(mm) {
case feb:
max= 28+leapyear(yy) ;
break;
case apr: case jun: case sep: case nov:
max= 30;
break;
case jan: case mar: case may: case jul: case aug: case oct: case dec:
max= 31;
break;
default:
throw Bad_date() ; / / someone cheated
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.3.1 Member Functions 239
if(dd<1|| max<dd) throw Bad_date() ;
y= yy;
m= mm;
d= dd;
}
The constructor checks that the data supplied denotes a valid Date. If not, say for
Date(30,Date: :feb,1994), it throws an exception (§8.3, Chapter 14), which indicates that
something went wrong in a way that cannot be ignored. If the data supplied is acceptable, the obvious initialization is done. Initialization is a relatively complicated operation because it involves
data validation. This is fairly typical. On the other hand, once a Datehas been created, it can be
used and copied without further checking. In other words, the constructor establishes the invariant
for the class (in this case, that it denotes a valid date). Other member functions can rely on that
invariant and must maintain it. This design technique can simplify code immensely (see §24.3.7.1).
I’m using the value Month(0) – which doesn’t represent a month – to represent ‘‘pick the
default month.’’ I could have defined an enumerator in Monthspecifically to represent that. But I
decided that it was better to use an obviously anomalous value to represent ‘‘pick the default
month’’ rather than give the appearance that there were 13 months in a year. Note that 0can be
used because it is within the range guaranteed for the enumeration Month(§4.8).
I considered factoring out the data validation in a separate function is_date(). However, I
found the resulting user code more complicated and less robust than code relying on catching the
exception. For example, assuming that >> is defined for Date:
void fill(vector<Date>& aa)
{
while(cin) {
Date d;
try{
cin>> d;
}
catch(Date: :Bad_date) {
/ / my error handling
continue;
}
aa.push_back(d) ; / / see §3.7.3
}
}
As is common for such simple concrete types, the definitions of member functions vary between
the trivial and the not-too-complicated. For example:
inline int Date: :day() const
{
return d;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
240 Classes Chapter 10
Date& Date: :add_month(int n)
{
if(n==0) return*this;
if(n>0) {
int delta_y= n/12;
int mm= m+n%12;
if(12< mm) { / / note: int(dec)==12
delta_y++;
mm-= 12;
}
/ / handle the cases where Month(mm) doesn’t have day d
y+= delta_y;
m= Month(mm) ;
return*this;
}
/ / handle negative n
return*this;
}
10.3.2 Helper Functions [class.helper]
Typically, a class has a number of functions associated with it that need not be defined in the class
itself because they don’t need direct access to the representation. For example:
int diff(Date a, Date b) ; / / number of days in the range [a,b) or [b,a)
bool leapyear(int y) ;
Date next_weekday(Date d) ;
Date next_saturday(Date d) ;
Defining such functions in the class itself would complicate the class interface and increase the
number of functions that would potentially need to be examined when a change to the representation was considered.
How are such functions ‘‘associated’’ with class Date? Traditionally, their declarations were
simply placed in the same file as the declaration of class Date, and users who needed Dates would
make them all available by including the file that defined the interface (§9.2.1). For example:
#include"Date.h"
In addition to using a specific Date.hheader, or as an alternative, we can make the association
explicit by enclosing the class and its helper functions in a namespace (§8.2):
namespace Chrono{ / / facilities for dealing with time
class Date{ /* ... */};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.3.2 Helper Functions 241
int diff(Date a, Date b) ;
bool leapyear(int y) ;
Date next_weekday(Date d) ;
Date next_saturday(Date d) ;
/ / ...
}
The Chrononamespace would naturally also contain related classes, such as Timeand Stopwatch,
and their helper functions. Using a namespace to hold a single class is usually an over-elaboration
that leads to inconvenience.
10.3.3 Overloaded Operators [class.over]
It is often useful to add functions to enable conventional notation. For example, the operator==
function defines the equality operator == to work for Dates:
inline bool operator==(Date a, Date b) / / equality
{
return a.day()==b.day() && a.month()==b.month() && a.year()==b.year() ;
}
Other obvious candidates are:
bool operator!=(Date, Date) ; / / inequality
bool operator<(Date, Date) ; / / less than
bool operator>(Date, Date) ; / / greater than
/ / ...
Date& operator++(Date& d) ; / / increase Date by one day
Date& operator--(Date& d) ; / / decrease Date by one day
Date& operator+=(Date& d, int n) ; / / add n days
Date& operator-=(Date& d, int n) ; / / subtract n days
Date operator+(Date d, int n) ; / / add n days
Date operator-(Date d, int n) ; / / subtract n days
ostream& operator<<(ostream&, Date d) ; / / output d
istream& operator>>(istream&, Date& d) ; / / read into d
For Date, these operators can be seen as mere conveniences. However, for many types – such as
complex numbers (§11.3), vectors (§3.7.1), and function-like objects (§18.4) – the use of conventional operators is so firmly entrenched in people’s minds that their definition is almost mandatory.
Operator overloading is discussed in Chapter 11.
10.3.4 The Significance of Concrete Classes [class.significance]
I call simple user-defined types, such as Date, concrete types to distinguish them from abstract
classes (§2.5.4) and class hierarchies (§12.3) and also to emphasize their similarity to built-in types
such as intand char. They have also been called value types, and their use value-oriented
programming. Their model of use and the ‘‘philosophy’’ behind their design are quite different
from what is often advertised as object-oriented programming (§2.6.2).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
242 Classes Chapter 10
The intent of a concrete type is to do a single, relatively small thing well and efficiently. It is
not usually the aim to provide the user with facilities to modify the behavior of a concrete type. In
particular, concrete types are not intended to display polymorphic behavior (see §2.5.5, §12.2.6).
If you don’t like some detail of a concrete type, you build a new one with the desired behavior.
If you want to ‘‘reuse’’ a concrete type, you use it in the implementation of your new type exactly
as you would have used an int. For example:
class Date_and_time{
private:
Date d;
Time t;
public:
Date_and_time(Date d, Time t) ;
Date_and_time(int d, Date: :Month m, int y, Time t) ;
/ / ...
};
The derived class mechanism discussed in Chapter 12 can be used to define new types from a concrete class by describing the desired differences. The definition of Vecfrom vector(§3.7.2) is an
example of this.
With a reasonably good compiler, a concrete class such as Dateincurs no hidden overhead in
time or space. The size of a concrete type is known at compile time so that objects can be allocated
on the run-time stack (that is, without free-store operations). The layout of each object is known at
compile time so that inlining of operations is trivially achieved. Similarly, layout compatibility
with other languages, such as C and Fortran, comes without special effort.
A good set of such types can provide a foundation for applications. Lack of suitable ‘‘small
efficient types’’ in an application can lead to gross run-time and space inefficiencies when overly
general and expensive classes are used. Alternatively, lack of concrete types can lead to obscure
programs and time wasted when each programmer writes code to directly manipulate ‘‘simple and
frequently used’’ data structures.
10.4 Objects [class.objects]
Objects can be created in several ways. Some are local variables, some are global variables, some
are members of classes, etc. This section discusses these alternatives, the rules that govern them,
the constructors used to initialize objects, and the destructors used to clean up objects before they
become unusable.
10.4.1 Destructors [class.dtor]
A constructor initializes an object. In other words, it creates the environment in which the member
functions operate. Sometimes, creating that environment involves acquiring a resource – such as a
file, a lock, or some memory – that must be released after use (§14.4.7). Thus, some classes need a
function that is guaranteed to be invoked when an object is destroyed in a manner similar to the
way a constructor is guaranteed to be invoked when an object is created. Inevitably, such functions
are called destructors. They typically clean up and release resources. Destructors are called
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.4.1 Destructors 243
implicitly when an automatic variable goes out of scope, an object on the free store is deleted, etc.
Only in very unusual circumstances does the user need to call a destructor explicitly (§10.4.11).
The most common use of a destructor is to release memory acquired in a constructor. Consider
a simple table of elements of some type Name. The constructor for Tablemust allocate memory to
hold the elements. When the table is somehow deleted, we must ensure that this memory is
reclaimed for further use elsewhere. We do this by providing a special function to complement the
constructor:
class Name{
const char* s;
/ / ...
};
class Table{
Name* p;
size_t sz;
public:
Table(size_t s= 15) { p= new Name[sz= s] ; }/ / constructor
~Table() { delete[] p; } / / destructor
Name* lookup(const char*) ;
bool insert(Name*) ;
};
The destructor notation ~Table() uses the complement symbol ~ to hint at the destructor’s relation to the Table() constructor.
A matching constructor/destructor pair is the usual mechanism for implementing the notion of a
variably-sized object in C++. Standard library containers, such as map, use a variant of this technique for providing storage for their elements, so the following discussion illustrates techniques
you rely on every time you use a standard container (including a standard string). The discussion
applies to types without a destructor, also. Such types are seen simply as having a destructor that
does nothing.
10.4.2 Default Constructors [class.default]
Similarly, most types can be considered to have a default constructor. A default constructor is a
constructor that can be called without supplying an argument. Because of the default argument 15,
Table: :Table(size_t) is a default constructor. If a user has declared a default constructor, that
one will be used; otherwise, the compiler will try to generate one if needed and if the user hasn’t
declared other constructors. A compiler-generated default constructor implicitly calls the default
constructors for a class’ members of class type and bases (§12.2.2). For example:
struct Tables{
int i;
int vi[10] ;
Table t1;
Table vt[10] ;
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
244 Classes Chapter 10
Tables tt;
Here, ttwill be initialized using a generated default constructor that calls Table(15) for tt.t1and
each element of tt.vt. On the other hand, tt.iand the elements of tt.viare not initialized because
those objects are not of a class type. The reasons for the dissimilar treatment of classes and built-in
types are C compatibility and fear of run-time overhead.
Because consts and references must be initialized (§5.5, §5.4), a class containing constor reference members cannot be default-constructed unless the programmer explicitly supplies a constructor (§10.4.6.1). For example:
struct X{
const int a;
const int& r;
};
X x; / / error: no default constructor for X
Default constructors can be invoked explicitly (§10.4.10). Built-in types also have default constructors (§6.2.8).
10.4.3 Construction and Destruction [class.ctor.dtor]
Consider the different ways an object can be created and how it gets destroyed afterwards. An
object can be created as:
§10.4.4 A named automatic object, which is created each time its declaration is encountered
in the execution of the program and destroyed each time the program exits the block
in which it occurs
§10.4.5 A free-store object, which is created using the newoperator and destroyed using the
deleteoperator
§10.4.6 A nonstatic member object, which is created as a member of another class object and
created and destroyed when the object of which it is a member is created and
destroyed
§10.4.7 An array element, which is created and destroyed when the array of which it is an element is created and destroyed
§10.4.8 A local static object, which is created the first time its declaration is encountered in
the execution of the program and destroyed once at the termination of the program
§10.4.9 A global, namespace, or class static object, which is created once ‘‘at the start of the
program’’ and destroyed once at the termination of the program
§10.4.10 A temporary object, which is created as part of the evaluation of an expression and
destroyed at the end of the full expression in which it occurs
§10.4.11 An object placed in memory obtained from a user-supplied function guided by arguments supplied in the allocation operation
§10.4.12 A unionmember, which may not have a constructor or a destructor
This list is roughly sorted in order of importance. The following subsections explain these various
ways of creating objects and their uses.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.4.4 Local Variables 245
10.4.4 Local Variables [class.local]
The constructor for a local variable is executed each time the thread of control passes through the
declaration of the local variable. The destructor for a local variable is executed each time the local
variable’s block is exited. Destructors for local variables are executed in reverse order of their construction. For example:
void f(int i)
{
Table aa;
Table bb;
if(i>0) {
Table cc;
/ / ...
}
Table dd;
/ / ...
}
Here, aa, bb, and ddare constructed (in that order) each time f() is called, and dd, bb, and aaare
destroyed (in that order) each time we return from f(). If i>0for a call, ccwill be constructed after
bband destroyed before ddis constructed.
10.4.4.1 Copying Objects [class.copy]
If t1and t2are objects of a class Table, t2=t1by default means a memberwise copy of t1into t2
(§10.2.5). Having assignment interpreted this way can cause a surprising (and usually undesired)
effect when used on objects of a class with pointer members. Memberwise copy is usually the
wrong semantics for copying objects containing resources managed by a constructor/destructor
pair. For example:
void h()
{
Table t1;
Table t2= t1; / / copy initialization: trouble
Table t3;
t3= t2; / / copy assignment: trouble
}
Here, the Tabledefault constructor is called twice: once each for t1and t3. It is not called for t2
because that variable was initialized by copying. However, the Tabledestructor is called three
times: once each for t1, t2, and t3! The default interpretation of assignment is memberwise copy, so
t1, t2, and t3will, at the end of h(), each contain a pointer to the array of names allocated on the
free store when t1was created. No pointer to the array of names allocated when t3was created
remains because it was overwritten by the t3=t2assignment. Thus, in the absence of automatic
garbage collection (§10.4.5), its storage will be lost to the program forever. On the other hand, the
array created for t1appears in t1, t2, and t3, so it will be deleted thrice. The result of that is undefined and probably disastrous.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
246 Classes Chapter 10
Such anomalies can be avoided by defining what it means to copy a Table:
class Table{
/ / ...
Table(const Table&) ; / / copy constructor
Table& operator=(const Table&) ; / / copy assignment
};
The programmer can define any suitable meaning for these copy operations, but the traditional one
for this kind of container is to copy the contained elements (or at least to give the user of the container the appearance that a copy has been done; see §11.12). For example:
Table: :Table(const Table& t) / / copy constructor
{
p= new Name[sz=t.sz] ;
for(int i= 0; i<sz; i++) p[i] = t.p[i] ;
}
Table& Table: :operator=(const Table& t) / / assignment
{
if(this!= &t) { / / beware of self-assignment: t = t
delete[] p;
p= new Name[sz=t.sz] ;
for(int i= 0; i<sz; i++) p[i] = t.p[i] ;
}
return*this;
}
As is almost always the case, the copy constructor and the copy assignment differ considerably.
The fundamental reason is that a copy constructor initializes uninitialized memory, whereas the
copy assignment operator must correctly deal with a well-constructed object.
Assignment can be optimized in some cases, but the general strategy for an assignment operator
is simple: protect against self-assignment, delete old elements, initialize, and copy in new elements.
Usually every nonstatic member must be copied (§10.4.6.3).
10.4.5 Free Store [class.free]
An object created on the free store has its constructor invoked by the newoperator and exists until
the deleteoperator is applied to a pointer to it. Consider:
int main()
{
Table* p= new Table;
Table* q= new Table;
delete p;
delete p; / / probably causes run-time error
}
The constructor Table: :Table() is called twice. So is the destructor Table: :~Table(). Unfortunately, the news and the deletes in this example don’t match, so the object pointed to by pis
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.4.5 Free Store 247
deleted twice and the object pointed to by qnot at all. Not deleting an object is typically not an
error as far as the language is concerned; it is only a waste of space. However, in a program that is
meant to run for a long time, such a memory leak is a serious and hard-to-find error. There are
tools available for detecting such leaks. Deleting ptwice is a serious error; the behavior is undefined and most likely disastrous.
Some C++ implementations automatically recycle the storage occupied by unreachable objects
(garbage collecting implementations), but their behavior is not standardized. Even when a garbage
collector is running, deletewill invoke a destructor if one is defined, so it is still a serious error to
delete an object twice. In many cases, that is only a minor inconvenience. In particular, where a
garbage collector is known to exist, destructors that do memory management only can be eliminated. This simplification comes at the cost of portability and for some programs, a possible
increase in run time and a loss of predictability of run-time behavior (§C.9.1).
After deletehas been applied to an object, it is an error to access that object in any way. Unfortunately, implementations cannot reliably detect such errors.
The user can specify how newdoes allocation and how deletedoes deallocation (see §6.2.6.2
and §15.6). It is also possible to specify the way an allocation, initialization (construction), and
exceptions interact (see §14.4.5 and §19.4.5). Arrays on the free store are discussed in §10.4.7.
10.4.6 Class Objects as Members [class.m]
Consider a class that might be used to hold information for a small organization:
class Club{
string name;
Table members;
Table officers;
Date founded;
/ / ...
Club(const string& n, Date fd) ;
};
The Club’s constructor takes the name of the club and its founding date as arguments. Arguments
for a member’s constructor are specified in a member initializer list in the definition of the constructor of the containing class. For example:
Club: :Club(const string& n, Date fd)
: name(n) , members() , officers() , founded(fd)
{
/ / ...
}
The member initializers are preceded by a colon and the individual member initializers are separated by commas.
The members’ constructors are called before the body of the containing class’ own constructor
is executed. The constructors are called in the order in which they are declared in the class rather
than the order in which they appear in the initializer list. To avoid confusion, it is best to specify
the initializers in declaration order. The member destructors are called in the reverse order of construction.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
248 Classes Chapter 10
If a member constructor needs no arguments, the member need not be mentioned in the member
initializer list, so
Club: :Club(const string& n, Date fd)
: name(n) , founded(fd)
{
/ / ...
}
is equivalent to the previous version. In each case, Club: :officersis constructed by Table: :Table
with the default argument 15.
When a class object containing class objects is destroyed, the body of that object’s own
destructor (if one is specified) is executed first and then the members’ destructors are executed in
reverse order of declaration. A constructor assembles the execution environment for the member
functions for a class from the bottom up (members first). The destructor disassembles it from the
top down (members last).
10.4.6.1 Necessary Member Initialization [class.ref.init]
Member initializers are essential for types for which initialization differs from assignment – that is,
for member objects of classes without default constructors, for constmembers, and for reference
members. For example:
class X{
const int i;
Club c;
Club& pc;
/ / ...
X(int ii, const string& n, Date d, Club& c) : i(ii) , c(n,d) , pc(c) { }
};
There isn’t any other way to initialize such members, and it is an error not to initialize objects of
those types. For most types, however, the programmer has a choice between using an initializer
and using an assignment. In that case, I usually prefer to use the member initializer syntax, thus
making explicit the fact that initialization is being done. Often, there also is an efficiency advantage to using the initializer syntax. For example:
class Person{
string name;
string address;
/ / ...
Person(const Person&) ;
Person(const string& n, const string& a) ;
};
Person: :Person(const string& n, const string& a)
: name(n)
{
address= a;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.4.6.1 Necessary Member Initialization 249
Here nameis initialized with a copy of n. On the other hand, addressis first initialized to the
empty string and then a copy of ais assigned.
10.4.6.2 Member Constants [class.memconst]
It is also possible to initialize a static integral constant member by adding a constant-expression initializer to its member declaration. For example:
class Curious{
public:
static const int c1= 7; / / ok, but remember definition
static int c2= 11; / / error: not const
const int c3= 13; / / error: not static
static const int c4= f(17) ; / / error: in-class initializer not constant
static const float c5= 7.0; / / error: in-class not integral
/ / ...
};
If (and only if) you use an initialized member in a way that requires it to be stored as an object in
memory, the member must be (uniquely) defined somewhere. The initializer may not be repeated:
const int Curious: :c1; / / necessary, but don’t repeat initializer here
const int* p= &Curious: :c1; / / ok: Curious::c1 has been defined
Alternatively, you can use an enumerator (§4.8, §14.4.6, §15.3) as a symbolic constant within a
class declaration. For example:
class X{
enum{ c1= 7, c2= 11, c3= 13, c4= 17};
/ / ...
};
In that way, you are not tempted to initialize variables, floating-point numbers, etc. within a class.
10.4.6.3 Copying Members [class.mem.copy]
A default copy constructor or default copy assignment (§10.4.4.1) copies all elements of a class. If
this copy cannot be done, it is an error to try to copy an object of such a class. For example:
class Unique_handle{
private: / / copy operations are private to prevent copying (§11.2.2)
Unique_handle(const Unique_handle&) ;
Unique_handle& operator=(const Unique_handle&) ;
public:
/ / ...
};
struct Y{
/ / ...
Unique_handle a; / / requires explicit initialization
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
250 Classes Chapter 10
Y y1;
Y y2= y1; / / error: cannot copy Y::a
In addition, a default assignment cannot be generated if a nonstatic member is a reference, a const,
or a user-defined type without a copy assignment.
Note that the default copy constructor leaves a reference member referring to the same object in
both the original and the copied object. This can be a problem if the object referred to is supposed
to be deleted.
When writing a copy constructor, we must take care to copy every element that needs to be
copied. By default, elements are default-initialized, but that is often not what is desired in a copy
constructor. For example:
Person: :Person(const Person& a) : name(a.name) { } / / beware!
Here, I forgot to copy the address, so addressis initialized to the empty string by default. When
adding a new member to a class, always check if there are user-defined constructors that need to be
updated in order to initialize and copy the new member.
10.4.7 Arrays [class.array]
If an object of a class can be constructed without supplying an explicit initializer, then arrays of that
class can be defined. For example:
Table tbl[10] ;
This will create an array of 10 Tables and initialize each Tableby a call of Table: :Table() with
the default argument 15.
There is no way to specify explicit arguments for a constructor in an array declaration. If you
absolutely must initialize members of an array with different values, you can write a default constructor that directly or indirectly reads and writes nonlocal data. For example:
class Ibuffer{
string buf;
public:
Ibuffer() { cin>>buf; }
/ / ...
};
void f()
{
Ibuffer words[100] ; / / each word initialized from cin
/ / ...
}
It is usually best to avoid such subtleties.
The destructor for each constructed element of an array is invoked when that array is destroyed.
This is done implicitly for arrays that are not allocated using new. Like C, C++ doesn’t distinguish
between a pointer to an individual object and a pointer to the initial element of an array (§5.3).
Consequently, the programmer must state whether an array or an individual object is being deleted.
For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.4.7 Arrays 251
void f(int sz)
{
Table* t1= new Table;
Table* t2= new Table[sz] ;
Table* t3= new Table;
Table* t4= new Table[sz] ;
delete t1; / / right
delete[] t2; / / right
delete[] t3; / / wrong: trouble
delete t4; / / wrong: trouble
}
Exactly how arrays and individual objects are allocated is implementation-dependent. Therefore,
different implementations will react differently to incorrect uses of the deleteand delete[] operators. In simple and uninteresting cases like the previous one, a compiler can detect the problem, but
generally something nasty will happen at run time.
The special destruction operator for arrays, delete[], isn’t logically necessary. However, suppose the implementation of the free store had been required to hold sufficient information for every
object to tell if it was an individual or an array. The user could have been relieved of a burden, but
that obligation would have imposed significant time and space overheads on some C++ implementations.
As always, if you find C-style arrays too cumbersome, use a class such as vector(§3.7.1, §16.3)
instead. For example:
void g()
{
vector<Table>* p1= new vector<Table>(10) ;
Table* p2= new Table;
delete p1;
delete p2;
}
10.4.8 Local Static Store [class.obj.static]
The constructor for a local static object (§7.1.2) is called the first time the thread of control passes
through the object’s definition. Consider this:
void f(int i)
{
static Table tbl;
/ / ...
if(i) {
static Table tbl2;
/ / ...
}
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
252 Classes Chapter 10
int main()
{
f(0) ;
f(1) ;
f(2) ;
/ / ...
}
Here, the constructor is called for tblonce the first time f() is called. Because tblis declared
static, it does not get destroyed on return from f() and it does not get constructed a second time
when f() is called again. Because the block containing the declaration of tbl2doesn’t get executed
for the call f(0), tbl2doesn’t get constructed until the call f(1). It does not get constructed again
when its block is entered a second time.
The destructors for local static objects are invoked in the reverse order of their construction
when the program terminates (§9.4.1.1). Exactly when is unspecified.
10.4.9 Nonlocal Store [class.global]
A variable defined outside any function (that is, global, namespace, and class staticvariables) is
initialized (constructed) before main() is invoked, and any such variable that has been constructed
will have its destructor invoked after exit from main(). Dynamic linking complicates this picture
slightly by delaying the initialization until the code is linked into the running program.
Constructors for nonlocal objects in a translation unit are executed in the order their definitions
occur. Consider:
class X{
/ / ...
static Table memtbl;
};
Table tbl;
Table X: :memtbl;
namespace Z{
Table tbl2;
}
The order of construction is tbl, then X: :memtbl, and then Z: :tbl2. Note that a declaration (as
opposed to a definition), such as the declaration of memtblin X, doesn’t affect the order of construction. The destructors are called in the reverse order of construction: Z: :tbl2, then
X: :memtbl, and then tbl.
No implementation-independent guarantees are made about the order of construction of nonlocal objects in different compilation units. For example:
/ / file1.c:
Table tbl1;
/ / file2.c:
Table tbl2;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.4.9 Nonlocal Store 253
Whether tbl1is constructed before tbl2or vice versa is implementation-dependent. The order isn’t
even guaranteed to be fixed in every particular implementation. Dynamic linking, or even a small
change in the compilation process, can alter the sequence. The order of destruction is similarly
implementation-dependent.
Sometimes when you design a library, it is necessary, or simply convenient, to invent a type
with a constructor and a destructor with the sole purpose of initialization and cleanup. Such a type
would be used once only: to allocate a static object so that the constructor and the destructor are
called. For example:
class Zlib_init{
Zlib_init() ; / / get Zlib ready for use
~Zlib_init() ; / / clean up after Zlib
};
class Zlib{
static Zlib_init x;
/ / ...
};
Unfortunately, it is not guaranteed that such an object is initialized before its first use and destroyed
after its last use in a program consisting of separately compiled units. A particular C++ implementation may provide such a guarantee, but most don’t. A programmer may ensure proper initialization by implementing the strategy that the implementations usually employ for local static
objects: a first-time switch. For example:
class Zlib{
static bool initialized;
static void initialize() { /* initialize */ initialized= true; }
public:
/ / no constructor
void f()
{
if(initialized== false) initialize() ;
/ / ...
}
/ / ...
};
If there are many functions that need to test the first-time switch, this can be tedious, but it is often
manageable. This technique relies on the fact that statically allocated objects without constructors
are initialized to 0. The really difficult case is the one in which the first operation may be timecritical so that the overhead of testing and possible initialization can be serious. In that case, further
trickery is required (§21.5.2).
An alternative approach for a simple object is to present it as a function (§9.4.1):
int& obj() { static int x= 0; return x; } / / initialized upon first use
First-time switches do not handle every conceivable situation. For example, it is possible to create
objects that refer to each other during construction. Such examples are best avoided. If such
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
254 Classes Chapter 10
objects are necessary, they must be constructed carefully in stages. Also, there is no similarly simple last-time switch construct. Instead, see §9.4.1.1 and §21.5.2.
10.4.10 Temporary Objects [class.temp]
Temporary objects most often are the result of arithmetic expressions. For example, at some point
in the evaluation of x*y+zthe partial result x*ymust exist somewhere. Except when performance
is the issue (§11.6), temporary objects rarely become the concern of the programmer. However, it
happens (§11.6, §22.4.7).
Unless bound to a reference or used to initialize a named object, a temporary object is destroyed
at the end of the full expression in which it was created. A full expression is an expression that is
not a subexpression of some other expression.
The standard stringclass has a member function c_str() that returns a C-style, zero-terminated
array of characters (§3.5.1, §20.4.1). Also, the operator + is defined to mean string concatenation.
These are very useful facilities for strings. However, in combination they can cause obscure problems. For example:
void f(string& s1, string& s2, string& s3)
{
const char* cs= (s1+s2).c_str() ;
cout<< cs;
if(strlen(cs=(s2+s3).c_str())<8&& cs[0]==´a´) {
/ / cs used here
}
}
Probably, your first reaction is ‘‘but don’t do that,’’ and I agree. However, such code does get written, so it is worth knowing how it is interpreted.
A temporary object of class stringis created to hold s1+s2. Next, a pointer to a C-style string
is extracted from that object. Then – at the end of the expression – the temporary object is deleted.
Now, where was the C-style string allocated? Probably as part of the temporary object holding
s1+s2, and that storage is not guaranteed to exist after that temporary is destroyed. Consequently,
cspoints to deallocated storage. The output operation cout<<csmight work as expected, but that
would be sheer luck. A compiler can detect and warn against many variants of this problem.
The example with the if-statement is a bit more subtle. The condition will work as expected
because the full expression in which the temporary holding s2+s3is created is the condition itself.
However, that temporary is destroyed before the controlled statement is entered, so any use of cs
there is not guaranteed to work.
Please note that in this case, as in many others, the problems with temporaries arose from using
a high-level data type in a low-level way. A cleaner programming style would have not only
yielded a more understandable program fragment, but also avoided the problems with temporaries
completely. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.4.10 Temporary Objects 255
void f(string& s1, string& s2, string& s3)
{
cout<< s1+s2;
string s= s2+s3;
if(s.length()<8&& s[0]==´a´) {
/ / use s here
}
}
A temporary can be used as an initializer for a constreference or a named object. For example:
void g(const string&, const string&) ;
void h(string& s1, string& s2)
{
const string& s= s1+s2;
string ss= s1+s2;
g(s,ss) ; / / we can use s and ss here
}
This is fine. The temporary is destroyed when ‘‘its’’ reference or named object go out of scope.
Remember that returning a reference to a local variable is an error (§7.3) and that a temporary
object cannot be bound to a non-constreference (§5.5).
A temporary object can also be created by explicitly invoking a constructor. For example:
void f(Shape& s, int x, int y)
{
s.move(Point(x,y)) ; / / construct Point to pass to Shape::move()
/ / ...
}
Such temporaries are destroyed in exactly the same way as the implicitly generated temporaries.
10.4.11 Placement of Objects [class.placement]
Operator newcreates its object on the free store by default. What if we wanted the object allocated
elsewhere? Consider a simple class:
class X{
public:
X(int) ;
/ / ...
};
We can place objects anywhere by providing an allocator function with extra arguments and then
supplying such extra arguments when using new:
void* operator new(size_t, void* p) { return p; } / / explicit placement operator
void* buf= reinterpret_cast<void*>(0xF00F) ; / / significant address
X* p2= new(buf)X; / / construct an X at ‘buf;’ invokes: operator new(sizeof(X),buf)
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
256 Classes Chapter 10
Because of this usage, the new(buf)Xsyntax for supplying extra arguments to operator new() is
known as the placement syntax. Note that every operator new() takes a size as its first argument
and that the size of the object allocated is implicitly supplied (§15.6). The operator new() used
by the newoperator is chosen by the usual argument matching rules (§7.4); every operator new()
has a size_tas its first argument.
The ‘‘placement’’ operator new() is the simplest such allocator. It is defined in the standard
header <new>.
The reinterpret_castis the crudest and potentially nastiest of the type conversion operators
(§6.2.7). In most cases, it simply yields a value with the same bit pattern as its argument with the
type required. Thus, it can be used for the inherently implementation-dependent, dangerous, and
occasionally absolutely necessary activity of converting integer values to pointers and vice versa.
The placement newconstruct can also be used to allocate memory from a specific arena:
class Arena{
public:
virtual void* alloc(size_t) =0;
virtual void free(void*) =0;
/ / ...
};
void* operator new(size_t sz, Arena* a)
{
return a->alloc(sz) ;
}
Now objects of arbitrary types can be allocated from different Arenas as needed. For example:
extern Arena* Persistent;
extern Arena* Shared;
void g(int i)
{
X* p= new(Persistent) X(i) ; / / X in persistent storage
X* q= new(Shared) X(i) ; / / X in shared memory
/ / ...
}
Placing an object in an area that is not (directly) controlled by the standard free-store manager
implies that some care is required when destroying the object. The basic mechanism for that is an
explicit call of a destructor:
void destroy(X* p, Arena* a)
{
p->~X() ; / / call destructor
a->free(p) ; / / free memory
}
Note that explicit calls of destructors, like the use of special-purpose global allocators, should be
avoided wherever possible. Occasionally, they are essential. For example, it would be hard to
implement an efficient general container along the lines of the standard library vector(§3.7.1,
§16.3.8) without using explicit destructor class. However, a novice should think thrice before
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.4.11 Placement of Objects 257
calling a destructor explicitly and also should ask a more experienced colleague before doing so.
See §14.4.7 for an explanation of how placement new interacts with exception handling.
There is no special syntax for placement of arrays. Nor need there be, since arbitrary types can
be allocated by placement new. However, a special operator delete() can be defined for arrays
(§19.4.5).
10.4.12 Unions [class.union]
A named union is defined as a struct, where every member has the same address (see §C.8.2). A
union can have member functions but not static members.
In general, a compiler cannot know what member of a union is used; that is, the type of the
object stored in a union is unknown. Consequently, a union may not have members with constructors or destructors. It wouldn’t be possible to protect that object against corruption or to guarantee
that the right destructor is called when the union goes out of scope.
Unions are best used in low-level code, or as part of the implementation of classes that keep
track of what is stored in the union (see §10.6[20]).
10.5 Advice [class.advice]
[1] Represent concepts as classes; §10.1.
[2] Use public data (structs) only when it really is just data and no invariant is meaningful for the
data members; §10.2.8.
[3] A concrete type is the simplest kind of class. Where applicable, prefer a concrete type over
more complicated classes and over plain data structures; §10.3.
[4] Make a function a member only if it needs direct access to the representation of a class;
§10.3.2.
[5] Use a namespace to make the association between a class and its helper functions explicit;
§10.3.2.
[6] Make a member function that doesn’t modify the value of its object a constmember function;
§10.2.6.
[7] Make a function that needs access to the representation of a class but needn’t be called for a
specific object a staticmember function; §10.2.4.
[8] Use a constructor to establish an invariant for a class; §10.3.1.
[9] If a constructor acquires a resource, its class needs a destructor to release the resource;
§10.4.1.
[10] If a class has a pointer member, it needs copy operations (copy constructor and copy assignment); §10.4.4.1.
[11] If a class has a reference member, it probably needs copy operations (copy constructor and
copy assignment); §10.4.6.3.
[12] If a class needs a copy operation or a destructor, it probably needs a constructor, a destructor, a
copy assignment, and a copy constructor; §10.4.4.1.
[13] Check for self-assignment in copy assignments; §10.4.4.1.
[14] When writing a copy constructor, be careful to copy every element that needs to be copied
(beware of default initializers); §10.4.4.1.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
258 Classes Chapter 10
[15] When adding a new member to a class, always check to see if there are user-defined constructors that need to be updated to initialize the member; §10.4.6.3.
[16] Use enumerators when you need to define integer constants in class declarations; §10.4.6.1.
[17] Avoid order dependencies when constructing global and namespace objects; §10.4.9.
[18] Use first-time switches to minimize order dependencies; §10.4.9.
[19] Remember that temporary objects are destroyed at the end of the full expression in which they
are created; §10.4.10.
10.6 Exercises [class.exercises]
1. (∗1) Find the error in Date: :add_year() in §10.2.2. Then find two additional errors in the
version in §10.2.7.
2. (∗2.5) Complete and test Date. Reimplement it with ‘‘number of days after 1/1/1970’’ representation.
3. (∗2) Find a Dateclass that is in commercial use. Critique the facilities it offers. If possible,
then discuss that Datewith a real user.
4. (∗1) How do you access set_defaultfrom class Datefrom namespace Chrono(§10.3.2)? Give
at least three different ways.
5. (∗2) Define a class Histogramthat keeps count of numbers in some intervals specified as arguments to Histogram’s constructor. Provide functions to print out the histogram. Handle outof-range values.
6. (∗2) Define some classes for providing random numbers of certain distributions (for example,
uniform and exponential). Each class has a constructor specifying parameters for the distribution and a function drawthat returns the next value.
7. (∗2.5) Complete class Tableto hold (name,value) pairs. Then modify the desk calculator program from §6.1 to use class Tableinstead of map. Compare and contrast the two versions.
8. (∗2) Rewrite Tnodefrom §7.10[7] as a class with constructors, destructors, etc. Define a tree of
Tnodes as a class with constructors, destructors, etc.
9. (∗3) Define, implement, and test a set of integers, class Intset. Provide union, intersection, and
symmetric difference operations.
10. (∗1.5) Modify class Intsetinto a set of nodes, where Nodeis a structure you define.
11. (∗3) Define a class for analyzing, storing, evaluating, and printing simple arithmetic expressions
consisting of integer constants and the operators +, -, *, and /. The public interface should
look like this:
class Expr{
/ / ...
public:
Expr(char*) ;
int eval() ;
void print() ;
};
The string argument for the constructor Expr: :Expr() is the expression. The function
Expr: :eval() returns the value of the expression, and Expr: :print() prints a representation
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 10.6 Exercises 259
of the expression on cout. A program might look like this:
Expr x("123/4+123*4-3") ;
cout<< "x= " << x.eval() << "\n";
x.print() ;
Define class Exprtwice: once using a linked list of nodes as the representation and once using a
character string as the representation. Experiment with different ways of printing the expression: fully parenthesized, postfix notation, assembly code, etc.
12. (∗2) Define a class Char_queueso that the public interface does not depend on the representation. Implement Char_queue(a) as a linked list and (b) as a vector. Do not worry about concurrency.
13. (∗3) Design a symbol table class and a symbol table entry class for some language. Have a look
at a compiler for that language to see what the symbol table really looks like.
14. (∗2) Modify the expression class from §10.6[11] to handle variables and the assignment operator =. Use the symbol table class from §10.6[13].
15. (∗1) Given this program:
#include<iostream>
int main()
{
std: :cout<< "Hello, world!\n";
}
modify it to produce this output:
Initialize
Hello, world!
Clean up
Do not change main() in any way.
16. (∗2) Define a Calculatorclass for which the calculator functions from §6.1 provide most of the
implementation. Create Calculators and invoke them for input from cin, from command-line
arguments, and for strings in the program. Allow output to be delivered to a variety of targets
similar to the way input can be obtained from a variety of sources.
17. (∗2) Define two classes, each with a staticmember, so that the construction of each static
member involves a reference to the other. Where might such constructs appear in real code?
How can these classes be modified to eliminate the order dependence in the constructors?
18. (∗2.5) Compare class Date(§10.3) with your solution to §5.9[13] and §7.10[19]. Discuss errors
found and likely differences in maintenance of the two solutions.
19. (∗3) Write a function that, given an istreamand a vector<string>, produces a
map<string,vector<int>> holding each string and the numbers of the lines on which the string
appears. Run the program on a text-file with no fewer than 1,000 lines looking for no fewer
than 10 words.
20. (∗2) Take class Entryfrom §C.8.2 and modify it so that each union member is always used
according to its type.
.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
260 Classes Chapter 10
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
11 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
Operator Overloading
When I use a word it means just what
I choose it to mean – neither more nor less.
– Humpty Dumpty
Notation — operator functions — binary and unary operators — predefined meanings
for operators — user-defined meanings for operators — operators and namespaces — a
complex type — member and nonmember operators — mixed-mode arithmetic —
initialization — copying — conversions — literals — helper functions — conversion
operators — ambiguity resolution — friends — members and friends — large objects —
assignment and initialization — subscripting — function call — dereferencing — increment and decrement — a string class — advice — exercises.
11.1 Introduction [over.intro]
Every technical field – and most nontechnical fields – have developed conventional shorthand
notation to make convenient the presentation and discussion involving frequently-used concepts.
For example, because of long acquaintance
x+y*z
is clearer to us than
multiply y by z and add the result to x
It is hard to overestimate the importance of concise notation for common operations.
Like most languages, C++ supports a set of operators for its built-in types. However, most concepts for which operators are conventionally used are not built-in types in C++, so they must be represented as user-defined types. For example, if you need complex arithmetic, matrix algebra, logic
signals, or character strings in C++, you use classes to represent these notions. Defining operators
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
262 Operator Overloading Chapter 11
for such classes sometimes allows a programmer to provide a more conventional and convenient
notation for manipulating objects than could be achieved using only the basic functional notation.
For example,
class complex{ / / very simplified complex
double re, im;
public:
complex(double r, double i) : re(r) , im(i) { }
complex operator+(complex) ;
complex operator*(complex) ;
};
defines a simple implementation of the concept of complex numbers. A complexis represented by
a pair of double-precision floating-point numbers manipulated by the operators + and *. The programmer defines complex: :operator+() and complex: :operator*() to provide meanings for +
and *, respectively. For example, if band care of type complex, b+cmeans b.operator+(c).
We can now approximate the conventional interpretation of complexexpressions:
void f()
{
complex a= complex(1, 3.1) ;
complex b= complex(1.2, 2) ;
complex c= b;
a= b+c;
b= b+c*a;
c= a*b+complex(1,2) ;
}
The usual precedence rules hold, so the second statement means b=b+(c*a), not b=(b+c)*a.
Many of the most obvious uses of operator overloading are for concrete types (§10.3). However, the usefulness of user-defined operators is not restricted to concrete types. For example, the
design of general and abstract interfaces often leads to the use of operators such as ->, [], and ().
11.2 Operator Functions [over.oper]
Functions defining meanings for the following operators (§6.2) can be declared:
+ - * / % ^ &
| ~ ! = < > +=
-= *= /= %= ^= &= |=
<< >> >>= <<= == != <=
>= && || ++ -- ->* ,
-> [] () new new[] delete delete[]
The following operators cannot be defined by a user:
:: (scope resolution; §4.9.4, §10.2.4),
. (member selection; §5.7), and
.* (member selection through pointer to function; §15.5).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.2 Operator Functions 263
They take a name, rather than a value, as their second operand and provide the primary means of
referring to members. Allowing them to be overloaded would lead to subtleties [Stroustrup,1994].
It is not possible to define new operator tokens, but you can use the function-call notation when
this set of operators is not adequate. For example, use pow(), not **. These restrictions may
seem Draconian, but more flexible rules can easily lead to ambiguities. For example, defining an
operator ** to mean exponentiation may seem an obvious and easy task at first glance, but think
again. Should ** bind to the left (as in Fortran) or to the right (as in Algol)? Should the expression a**pbe interpreted as a*(*p) or as (a)**(p)?
The name of an operator function is the keyword operatorfollowed by the operator itself; for
example, operator<<. An operator function is declared and can be called like any other function.
A use of the operator is only a shorthand for an explicit call of the operator function. For example:
void f(complex a, complex b)
{
complex c= a+ b; / / shorthand
complex d= a.operator+(b) ; / / explicit call
}
Given the previous definition of complex, the two initializers are synonymous.
11.2.1 Binary and Unary Operators [over.binary]
A binary operator can be defined by either a nonstatic member function taking one argument or a
nonmember function taking two arguments. For any binary operator @, aa@bbcan be interpreted as
either aa.operator@(bb) or operator@(aa,bb). If both are defined, overload resolution (§7.4)
determines which, if any, interpretation is used. For example:
class X{
public:
void operator+(int) ;
X(int) ;
};
void operator+(X,X) ;
void operator+(X,double) ;
void f(X a)
{
a+1; / / a.operator+(1)
1+a; / / ::operator+(X(1),a)
a+1.0; / / ::operator+(a,1.0)
}
A unary operator, whether prefix or postfix, can be defined by either a nonstatic member function
taking no arguments or a nonmember function taking one argument. For any prefix unary operator
@, @aacan be interpreted as either aa.operator@() or operator@(aa). If both are defined, overload resolution (§7.4) determines which, if any, interpretation is used. For any postfix unary operator @, aa@ can be interpreted as either aa.operator@(int) or operator@(aa,int). This is
explained further in §11.11. If both are defined, overload resolution (§7.4) determines which, if
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
264 Operator Overloading Chapter 11
any, interpretation is used. An operator can be declared only for the syntax defined for it in the
grammar (§A.5). For example, a user cannot define a unary % or a ternary +. Consider:
class X{
/ / members (with implicit ‘this’ pointer):
X* operator&() ; / / prefix unary & (address of)
X operator&(X) ; / / binary & (and)
X operator++(int) ; / / postfix increment (see §11.11)
X operator&(X,X) ; / / error: ternary
X operator/() ; / / error: unary /
};
/ / nonmember functions :
X operator-(X) ; / / prefix unary minus
X operator-(X,X) ; / / binary minus
X operator--(X&,int) ; / / postfix decrement
X operator-() ; / / error: no operand
X operator-(X,X,X) ; / / error: ternary
X operator%(X) ; / / error: unary %
Operator [] is described in §11.8, operator () in §11.9, operator -> in §11.10, operators ++ and
-- in §11.11, and the allocation and deallocation operators in §6.2.6.2, §10.4.11, and §15.6.
11.2.2 Predefined Meanings for Operators [over.predefined]
Only a few assumptions are made about the meaning of a user-defined operator. In particular,
operator=, operator[], operator(), and operator-> must be nonstatic member functions; this
ensures that their first operands will be lvalues (§4.9.6).
The meanings of some built-in operators are defined to be equivalent to some combination of
other operators on the same arguments. For example, if ais an int, ++ameans a+=1, which in turn
means a=a+1. Such relations do not hold for user-defined operators unless the user happens to
define them that way. For example, a compiler will not generate a definition of Z: :operator+=()
from the definitions of Z: :operator+() and Z: :operator=().
Because of historical accident, the operators = (assignment), & (address-of), and , (sequencing;
§6.2.2) have predefined meanings when applied to class objects. These predefined meanings can
be made inaccessible to general users by making them private:
class X{
private:
void operator=(const X&) ;
void operator&() ;
void operator,(const X&) ;
/ / ...
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.2.2 Predefined Meanings for Operators 265
void f(X a, X b)
{
a= b; / / error: operator= private
&a; / / error: operator& private
a,b; / / error: operator, private
}
Alternatively, they can be given new meanings by suitable definitions.
11.2.3 Operators and User-Defined Types [over.user]
An operator function must either be a member or take at least one argument of a user-defined type
(functions redefining the newand deleteoperators need not). This rule ensures that a user cannot
change the meaning of an expression unless the expression contains an object of a user-defined
type. In particular, it is not possible to define an operator function that operates exclusively on
pointers. This ensures that C++ is extensible but not mutable (with the exception of operators =, &,
and , for class objects).
An operator function intended to accept a basic type as its first operand cannot be a member
function. For example, consider adding a complex variable aato the integer 2: aa+2can, with a
suitably declared member function, be interpreted as aa.operator+(2), but 2+aacannot because
there is no class intfor which to define + to mean 2.operator+(aa). Even if there were, two different member functions would be needed to cope with 2+aaand aa+2. Because the compiler does
not know the meaning of a user-defined +, it cannot assume that it is commutative and so interpret
2+aaas aa+2. This example is trivially handled using nonmember functions (§11.3.2, §11.5).
Enumerations are user-defined types so that we can define operators for them. For example:
enum Day{ sun, mon, tue, wed, thu, fri, sat};
Day& operator++(Day& d)
{
return d= (sat==d) ? sun: Day(d+1) ;
}
Every expression is checked for ambiguities. Where a user-defined operator provides a possible
interpretation, the expression is checked according to the rules in §7.4.
11.2.4 Operators in Namespaces [over.namespace]
An operator is either a member of a class or defined in some namespace (possibly the global namespace). Consider this simplified version of string I/O from the standard library:
namespace std{ / / simplified std
class ostream{
/ / ...
ostream& operator<<(const char*) ;
};
extern ostream cout;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
266 Operator Overloading Chapter 11
class string{
/ / ...
};
ostream& operator<<(ostream&, const string&) ;
}
int main()
{
char* p= "Hello";
std: :string s= "world";
std: :cout<< p<< ", " << s<< "!\n";
}
Naturally, this writes out Hello, world! But why? Note that I didn’t make everything from std
accessible by writing:
using namespace std;
Instead, I used the std: : prefix for stringand cout. In other words, I was at my best behavior and
didn’t pollute the global namespace or in other ways introduce unnecessary dependencies.
The output operator for C-style strings (char*) is a member of std: :ostream, so by definition
std: :cout<< p
means
std: :cout.operator<<(p)
However, std: :ostreamdoesn’t have a member function to output a std: :string, so
std: :cout<< s
means
operator<<(std: :cout,s)
Operators defined in namespaces can be found based on their operand types just like functions can
be found based on their argument types (§8.2.6). In particular, coutis in namespace std, so stdis
considered when looking for a suitable definition of <<. In that way, the compiler finds and uses:
std: :operator<<(std: :ostream&, const std: :string&)
For a binary operator @, x@ywhere xis of type Xand yis of type Yis resolved like this:
[1] If Xis a class, determine whether class Xor a base of Xdefines operator@ as a member; if
so, that is the @ to try to use.
[2] Otherwise,
– look for declarations of @ in the context surrounding x@y; and
– if Xis defined in namespace N, look for declarations of @ in N; and
– if Yis defined in namespace M, look for declarations of @ in M.
If declarations of operator@ are found in the surrounding context, in N, or in M, we try to use
those operators.
In either case, declarations for several operator@s may be found and overload resolution rules
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.2.4 Operators in Namespaces 267
(§7.4) are used to find the best match, if any. This lookup mechanism is applied only if the operator has at least one operand of a user-defined type. Therefore, user-defined conversions (§11.3.2,
§11.4) will be considered. Note that a typedefname is just a synonym and not a user-defined type
(§4.9.7).
11.3 A Complex Number Type [over.complex]
The implementation of complex numbers presented in the introduction is too restrictive to please
anyone. For example, from looking at a math textbook we would expect this to work:
void f()
{
complex a= complex(1,2) ;
complex b= 3;
complex c= a+2.3;
complex d= 2+b;
complex e= -b-c;
b= c*2*c;
}
In addition, we would expect to be provided with a few additional operators, such as == for comparison and << for output, and a suitable set of mathematical functions, such as sin() and sqrt().
Class complexis a concrete type, so its design follows the guidelines from §10.3. In addition,
users of complex arithmetic rely so heavily on operators that the definition of complexbrings into
play most of the basic rules for operator overloading.
11.3.1 Member and Nonmember Operators [over.member]
I prefer to minimize the number of functions that directly manipulate the representation of an
object. This can be achieved by defining only operators that inherently modify the value of their
first argument, such as +=, in the class itself. Operators that simply produce a new value based on
the values of its arguments, such as +, are then defined outside the class and use the essential operators in their implementation:
class complex{
double re, im;
public:
complex& operator+=(complex a) ; / / needs access to representation
/ / ...
};
complex operator+(complex a, complex b)
{
complex r= a;
return r+= b; / / access representation through +=
}
Given these declarations, we can write:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
268 Operator Overloading Chapter 11
void f(complex x, complex y, complex z)
{
complex r1= x+y+z; / / r1 = operator+(x,operator+(y,z))
complex r2= x; / / r2 = x
r2+= y; / / r2.operator+=(y)
r2+= z; / / r2.operator+=(z)
}
Except for possible efficiency differences, the computations of r1and r2are equivalent.
Composite assignment operators such as += and *= tend to be simpler to define than their
‘‘simple’’ counterparts + and *. This surprises most people at first, but it follows from the fact that
three objects are involved in a + operation (the two operands and the result), whereas only two
objects are involved in a += operation. In the latter case, run-time efficiency is improved by eliminating the need for temporary variables. For example:
inline complex& complex: :operator+=(complex a)
{
re+= a.re;
im+= a.im;
return*this;
}
does not require a temporary variable to hold the result of the addition and is simple for a compiler
to inline perfectly.
A good optimizer will generate close to optimal code for uses of the plain + operator also.
However, we don’t always have a good optimizer and not all types are as simple as complex, so
§11.5 discusses ways of defining operators with direct access to the representation of classes.
11.3.2 Mixed-Mode Arithmetic [over.mixed]
To cope with
complex d= 2+b;
we need to define operator + to accept operands of different types. In Fortran terminology, we
need mixed-mode arithmetic. We can achieve that simply by adding appropriate versions of the
operators:
class complex{
double re, im;
public:
complex& operator+=(complex a) {
re+= a.re;
im+= a.im;
return*this;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.3.2 Mixed-Mode Arithmetic 269
complex& operator+=(double a) {
re+= a;
return*this;
}
/ / ...
};
complex operator+(complex a, complex b)
{
complex r= a;
return r+= b; / / calls complex::operator+=(complex)
}
complex operator+(complex a, double b)
{
complex r= a;
return r+= b; / / calls complex::operator+=(double)
}
complex operator+(double a, complex b)
{
complex r= b;
return r+= a; / / calls complex::operator+=(double)
}
Adding a doubleto a complex number is a simpler operation than adding a complex. This is
reflected in these definitions. The operations taking doubleoperands do not touch the imaginary
part of a complex number and thus will be more efficient.
Given these declarations, we can write:
void f(complex x, complex y)
{
complex r1= x+y; / / calls operator+(complex,complex)
complex r2= x+2; / / calls operator+(complex,double)
complex r3= 2+x; / / calls operator+(double,complex)
}
11.3.3 Initialization [over.ctor]
To cope with assignments and initialization of complexvariables with scalars, we need a conversion of a scalar (integer or floating-point number) to a complex. For example:
complex b= 3; / / should mean b.re=3, b.im=0
A constructor taking a single argument specifies a conversion from its argument type to the
constructor’s type. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
270 Operator Overloading Chapter 11
class complex{
double re, im;
public:
complex(double r) :re(r) , im(0) { }
/ / ...
};
The constructor specifies the traditional embedding of the real line in the complex plane.
A constructor is a prescription for creating a value of a given type. The constructor is used
when a value of a type is expected and when such a value can be created by a constructor from the
value supplied as an initializer or assigned value. Thus, a constructor requiring a single argument
need not be called explicitly. For example,
complex b= 3;
means
complex b= complex(3) ;
A user-defined conversion is implicitly applied only if it is unique (§7.4). See §11.7.1 for a way of
specifying constructors that can only be explicitly invoked.
Naturally, we still need the constructor that takes two doubles, and a default constructor initializing a complexto (0,0) is also useful:
class complex{
double re, im;
public:
complex() : re(0) , im(0) { }
complex(double r) : re(r) , im(0) { }
complex(double r, double i) : re(r) , im(i) { }
/ / ...
};
Using default arguments, we can abbreviate:
class complex{
double re, im;
public:
complex(double r=0, double i=0) : re(r) , im(i) { }
/ / ...
};
When a constructor is explicitly declared for a type, it is not possible to use an initializer list (§5.7,
§4.9.5) as the initializer. For example:
complex z1= { 3}; / / error: complex has a constructor
complex z2= { 3, 4}; / / error: complex has a constructor
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.3.4 Copying 271
11.3.4 Copying [over.copy]
In addition to the explicitly declared constructors, complexby default gets a copy constructor
defined (§10.2.5). A default copy constructor simply copies all members. To be explicit, we could
equivalently have written:
class complex{
double re, im;
public:
complex(const complex& c) : re(c.re) , im(c.im) { }
/ / ...
};
However, for types where the default copy constructor has the right semantics, I prefer to rely on
that default. It is less verbose than anything I can write, and people should understand the default.
Also, compilers know about the default and its possible optimization opportunities. Furthermore,
writing out the memberwise copy by hand is tedious and error-prone for classes with many data
members (§10.4.6.3).
I use a reference argument for the copy constructor because I must. The copy constructor
defines what copying means – including what copying an argument means – so writing
complex: :complex(complex c) : re(c.re) , im(c.im) { } / / error
is an error because any call would have involved an infinite recursion.
For other functions taking complexarguments, I use value arguments rather than reference
arguments. Here, the designer has a choice. From a user’s point of view, there is little difference
between a function that takes a complexargument and one that takes a const complex& argument.
This issue is discussed further in §11.6.
In principle, copy constructors are used in simple initializations such as
complex x= 2; / / create complex(2); then initialize x with it
complex y= complex(2,0) ; / / create complex(2,0); then initialize y with it
However, the calls to the copy constructor are trivially optimized away. We could equivalently
have written:
complex x(2) ; / / initialize x by 2
complex y(2,0) ; / / initialize x by (2,0)
For arithmetic types, such as complex, I like the look of the version using = better. It is possible to
restrict the set of values accepted by the = style of initialization compared to the ()style by making
the copy constructor private (§11.2.2) or by declaring a constructor explicit(§11.7.1).
Similar to initialization, assignment of two objects of the same class is by default defined as
memberwise assignment (§10.2.5). We could explicitly define complex: :operator= to do that.
However, for a simple type like complexthere is no reason to do so. The default is just right.
The copy constructor – whether user-defined or compiler-generated – is used not only for the
initialization of variables, but also for argument passing, value return, and exception handling (see
§11.7). The semantics of these operations is defined to be the semantics of initialization (§7.1,
§7.3, §14.2.1).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
272 Operator Overloading Chapter 11
11.3.5 Constructors and Conversions [over.conv]
We defined three versions of each of the four standard arithmetic operators:
complex operator+(complex,complex) ;
complex operator+(complex,double) ;
complex operator+(double,complex) ;
/ / ...
This can get tedious, and what is tedious easily becomes error-prone. What if we had three alternatives for the type of each argument for each function? We would need three versions of each
single-argument function, nine versions of each two-argument function, twenty-seven versions of
each three-argument function, etc. Often these variants are very similar. In fact, almost all variants
involve a simple conversion of arguments to a common type followed by a standard algorithm.
The alternative to providing different versions of a function for each combination of arguments
is to rely on conversions. For example, our complexclass provides a constructor that converts a
doubleto a complex. Consequently, we could simply declare only one version of the equality
operator for complex:
bool operator==(complex,complex) ;
void f(complex x, complex y)
{
x==y; / / means operator==(x,y)
x==3; / / means operator==(x,complex(3))
3==y; / / means operator==(complex(3),y)
}
There can be reasons for preferring to define separate functions. For example, in some cases the
conversion can impose overheads, and in other cases, a simpler algorithm can be used for specific
argument types. Where such issues are not significant, relying on conversions and providing only
the most general variant of a function – plus possibly a few critical variants – contains the combinatorial explosion of variants that can arise from mixed-mode arithmetic.
Where several variants of a function or an operator exist, the compiler must pick ‘‘the right’’
variant based on the argument types and the available (standard and user-defined) conversions.
Unless a best match exists, an expression is ambiguous and is an error (see §7.4).
An object constructed by explicit or implicit use of a constructor is automatic and will be
destroyed at the first opportunity (see §10.4.10).
No implicit user-defined conversions are applied to the left-hand side of a . (or a ->). This is
the case even when the . is implicit. For example:
void g(complex z)
{
3+z; / / ok: complex(3)+z
3.operator+=(z) ; / / error: 3 is not a class object
3+=z; / / error: 3 is not a class object
}
Thus, you can express the notion that an operator requires an lvalue as their left-hand operand by
making that operator a member.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.3.6 Literals 273
11.3.6 Literals [over.literals]
It is not possible to define literals of a class type in the sense that 1.2and 12e3are literals of type
double. However, literals of the basic types can often be used instead if class member functions are
used to provide an interpretation for them. Constructors taking a single argument provide a general
mechanism for this. When constructors are simple and inline, it is quite reasonable to think of constructor invocations with literal arguments as literals. For example, I think of complex(3) as a literal of type complex, even though technically it isn’t.
11.3.7 Additional Member Functions [over.additional]
So far, we have provided class complexwith constructors and arithmetic operators only. That is
not quite sufficient for real use. In particular, we often need to be able to examine the value of the
real and imaginary parts:
class complex{
double re, im;
public:
double real() const{ return re; }
double imag() const{ return im; }
/ / ...
};
Unlike the other members of complex, real() and imag() do not modify the value of a complex,
so they can be declared const.
Given real() and imag(), we can define all kinds of useful operations without granting them
direct access to the representation of complex. For example:
inline bool operator==(complex a, complex b)
{
return a.real()==b.real() && a.imag()==b.imag() ;
}
Note that we need only to be able to read the real and imaginary parts; writing them is less often
needed. If we must do a ‘‘partial update,’’ we can:
void f(complex& z, double d)
{
/ / ...
z= complex(z.real() ,d) ; / / assign d to z.im
}
A good optimizer generates a single assignment for that statement.
11.3.8 Helper Functions [over.helpers]
If we put all the bits and pieces together, the complexclass becomes:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
274 Operator Overloading Chapter 11
class complex{
double re, im;
public:
complex(double r=0, double i=0) : re(r) , im(i) { }
double real() const{ return re; }
double imag() const{ return im; }
complex& operator+=(complex) ;
complex& operator+=(double) ;
/ / –=, *=, and /=
};
In addition, we must provide a number of helper functions:
complex operator+(complex,complex) ;
complex operator+(complex,double) ;
complex operator+(double,complex) ;
/ / – , *, and /
complex operator-(complex) ; / / unary minus
complex operator+(complex) ; / / unary plus
bool operator==(complex,complex) ;
bool operator!=(complex,complex) ;
istream& operator>>(istream&,complex&) ; / / input
ostream& operator<<(ostream&,complex) ; / / output
Note that the members real() and imag() are essential for defining the comparisons. The definition of most of the following helper functions similarly relies on real() and imag().
We might provide functions to allow users to think in terms of polar coordinates:
complex polar(double rho, double theta) ;
complex conj(complex) ;
double abs(complex) ;
double arg(complex) ;
double norm(complex) ;
double real(complex) ; / / for notational convenience
double imag(complex) ; / / for notational convenience
Finally, we must provide an appropriate set of standard mathematical functions:
complex acos(complex) ;
complex asin(complex) ;
complex atan(complex) ;
/ / ...
From a user’s point of view, the complex type presented here is almost identical to the
complex<double> found in <complex> in the standard library (§22.5).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.4 Conversion Operators 275
11.4 Conversion Operators [over.conversion]
Using a constructor to specify type conversion is convenient but has implications that can be undesirable. A constructor cannot specify
[1] an implicit conversion from a user-defined type to a basic type (because the basic types are
not classes), or
[2] a conversion from a new class to a previously defined class (without modifying the declaration for the old class).
These problems can be handled by defining a conversion operator for the source type. A member
function X: :operator T(), where Tis a type name, defines a conversion from Xto T. For example, one could define a 6-bit non-negative integer, Tiny, that can mix freely with integers in arithmetic operations:
class Tiny{
char v;
void assign(int i) { if(i&~077) throw Bad_range() ; v=i; }
public:
class Bad_range{ };
Tiny(int i) { assign(i) ; }
Tiny& operator=(int i) { assign(i) ; return*this; }
operator int() const{ return v; } / / conversion to int function
};
The range is checked whenever a Tinyis initialized by an intand whenever an intis assigned to
one. No range check is needed when we copy a Tiny, so the default copy constructor and assignment are just right.
To enable the usual integer operations on Tinyvariables, we define the implicit conversion from
Tinyto int, Tiny: :operator int(). Note that the type being converted to is part of the name of the
operator and cannot be repeated as the return value of the conversion function:
Tiny: :operator int() const{ return v; } / / right
int Tiny: :operator int() const{ return v; } / / error
In this respect also, a conversion operator resembles a constructor.
Whenever a Tinyappears where an intis needed, the appropriate intis used. For example:
int main()
{
Tiny c1= 2;
Tiny c2= 62;
Tiny c3= c2-c1; / / c3 = 60
Tiny c4= c3; / / no range check (not necessary)
int i= c1+c2; / / i = 64
c1= c1+c2; / / range error: c1 can’t be 64
i= c3-64; / / i = – 4
c2= c3-64; / / range error: c2 can’t be – 4
c3= c4; / / no range check (not necessary)
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
276 Operator Overloading Chapter 11
Conversion functions appear to be particularly useful for handling data structures when reading
(implemented by a conversion operator) is trivial, while assignment and initialization are distinctly
less trivial.
The istreamand ostreamtypes rely on a conversion function to enable statements such as
while(cin>>x) cout<<x;
The input operation cin>>xreturns an istream&. That value is implicitly converted to a value indicating the state of cin. This value can then be tested by the while(see §21.3.3). However, it is typically not a good idea to define an implicit conversion from one type to another in such a way that
information is lost in the conversion.
In general, it is wise to be sparing in the introduction of conversion operators. When used in
excess, they lead to ambiguities. Such ambiguities are caught by the compiler, but they can be a
nuisance to resolve. Probably the best idea is initially to do conversions by named functions, such
as X: :make_int(). If such a function becomes popular enough to make explicit use inelegant, it
can be replaced by a conversion operator X: :operator int().
If both user-defined conversions and user-defined operators are defined, it is possible to get
ambiguities between the user-defined operators and the built-in operators. For example:
int operator+(Tiny,Tiny) ;
void f(Tiny t, int i)
{
t+i; / / error, ambiguous: operator+(t,Tiny(i)) or int(t)+i ?
}
It is therefore often best to rely on user-defined conversions or user-defined operators for a given
type, but not both.
11.4.1 Ambiguities [over.ambig]
An assignment of a value of type Vto an object of class Xis legal if there is an assignment operator
X: :operator=(Z) so that Vis Zor there is a unique conversion of Vto Z. Initialization is treated
equivalently.
In some cases, a value of the desired type can be constructed by repeated use of constructors or
conversion operators. This must be handled by explicit conversions; only one level of user-defined
implicit conversion is legal. In some cases, a value of the desired type can be constructed in more
than one way; such cases are illegal. For example:
class X{ /* ... */ X(int) ; X(char*) ; };
class Y{ /* ... */ Y(int) ; };
class Z{ /* ... */ Z(X) ; };
X f(X) ;
Y f(Y) ;
Z g(Z) ;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.4.1 Ambiguities 277
void k1()
{
f(1) ; / / error: ambiguous f(X(1)) or f(Y(1))?
f(X(1)) ; / / ok
f(Y(1)) ; / / ok
g("Mack") ; / / error: two user-defined conversions needed; g(Z(X("Mack"))) not tried
g(X("Doc")) ; / / ok: g(Z(X("Doc")))
g(Z("Suzy")) ; / / ok: g(Z(X("Suzy")))
}
User-defined conversions are considered only if they are necessary to resolve a call. For example:
class XX{ /* ... */ XX(int) ; };
void h(double) ;
void h(XX) ;
void k2()
{
h(1) ; / / h(double(1)) or h(XX(1))? h(double(1))!
}
The call h(1) means h(double(1)) because that alternative uses only a standard conversion
rather than a user-defined conversion (§7.4).
The rules for conversion are neither the simplest to implement, the simplest to document, nor
the most general that could be devised. They are, however, considerably safer, and the resulting
resolutions are less surprising. It is far easier to manually resolve an ambiguity than to find an error
caused by an unsuspected conversion.
The insistence on strict bottom-up analysis implies that the return type is not used in overloading resolution. For example:
class Quad{
public:
Quad(double) ;
/ / ...
};
Quad operator+(Quad,Quad) ;
void f(double a1, double a2)
{
Quad r1= a1+a2; / / double-precision add
Quad r2= Quad(a1)+a2; / / force quad arithmetic
}
The reason for this design choice is partly that strict bottom-up analysis is more comprehensible
and partly that it is not considered the compiler’s job to decide which precision the programmer
might want for the addition.
Once the types of both sides of an initialization or assignment have been determined, both types
are used to resolve the initialization or assignment. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
278 Operator Overloading Chapter 11
class Real{
public:
operator double() ;
operator int() ;
/ / ...
};
void g(Real a)
{
double d= a; / / d = a.double();
int i= a; / / i = a.int();
d= a; / / d = a.double();
i= a; / / i = a.int();
}
In these cases, the type analysis is still bottom-up, with only a single operator and its argument
types considered at any one time.
11.5 Friends [over.friends]
An ordinary member function declaration specifies three logically distinct things:
[1] The function can access the private part of the class declaration, and
[2] the function is in the scope of the class, and
[3] the function must be invoked on an object (has a thispointer).
By declaring a member function static(§10.2.4), we can give it the first two properties only. By
declaring a function a friend, we can give it the first property only.
For example, we could define an operator that multiplies a Matrixby a Vector. Naturally,
Vectorand Matrixeach hide their representation and provide a complete set of operations for
manipulating objects of their type. However, our multiplication routine cannot be a member of
both. Also, we don’t really want to provide low-level access functions to allow every user to both
read and write the complete representation of both Matrixand Vector. To avoid this, we declare
the operator* a friend of both:
class Matrix;
class Vector{
float v[4] ;
/ / ...
friend Vector operator*(const Matrix&, const Vector&) ;
};
class Matrix{
Vector v[4] ;
/ / ...
friend Vector operator*(const Matrix&, const Vector&) ;
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.5 Friends 279
Vector operator*(const Matrix& m, const Vector& v)
{
Vector r;
for(int i= 0; i<4; i++) { / / r[i] = m[i] * v;
r.v[i] = 0;
for(int j= 0; j<4; j++) r.v[i] += m.v[i].v[j] * v.v[j] ;
}
return r;
}
A frienddeclaration can be placed in either the private or the public part of a class declaration; it
does not matter where. Like a member function, a friend function is explicitly declared in the
declaration of the class of which it is a friend. It is therefore as much a part of that interface as is a
member function.
A member function of one class can be the friend of another. For example:
class List_iterator{
/ / ...
int* next() ;
};
class List{
friend int* List_iterator: :next() ;
/ / ...
};
It is not unusual for all functions of one class to be friends of another. There is a shorthand for this:
class List{
friend class List_iterator;
/ / ...
};
This friend declaration makes all of List_iterator’s member functions friends of List.
Clearly, friendclasses should be used only to express closely connected concepts. Often, there
is a choice between making a class a member (a nested class) or a friend (§24.4).
11.5.1 Finding Friends [over.lookup]
Like a member declaration, a frienddeclaration does not introduce a name into an enclosing scope.
For example:
class Matrix{
friend class Xform;
friend Matrix invert(const Matrix&) ;
/ / ...
};
Xform x; / / error: no Xform in scope
Matrix(*p)(const Matrix&) = &invert; / / error: no invert() in scope
For large programs and large classes, it is nice that a class doesn’t ‘‘quietly’’ add names to its
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
280 Operator Overloading Chapter 11
enclosing scope. For a template class that can be instantiated in many different contexts (Chapter
13), this is very important.
A friend class must be previously declared in an enclosing scope or defined in the non-class
scope immediately enclosing the class that is declaring it a friend. For example:
class X{ /* ... */ }; / / Y’s friend
namespace N{
class Y{
friend class X;
friend class Z;
friend class AE;
};
class Z{ /* ... */ }; / / Y’s friend
}
class AE{ /* ... */ }; / / not a friend of Y
A friend function can be explicitly declared just like friend classes, or it can be found through its
argument types (§8.2.6) as if it was declared in the non-class scope immediately enclosing its class.
For example:
void f(Matrix& m)
{
invert(m) ; / / Matrix’s friend invert()
}
It follows that a friend function should either be explicitly declared in an enclosing scope or take an
argument of its class. If not, the friend cannot be called. For example:
/ / no f() here
void g() ; / / X’s friend
class X{
friend void f() ; / / useless
friend void g() ;
friend void h(const X&) ; / / can be found through its argument
};
void f() { /* ... */ } / / not a friend of X
11.5.2 Friends and Members [over.friends.members]
When should we use a friend function, and when is a member function the better choice for specifying an operation? First, we try to minimize the number of functions that access the representation
of a class and try to make the set of access functions as appropriate as possible. Therefore, the first
question is not, ‘‘Should it be a member, a static member, or a friend?’’ but rather, ‘‘Does it really
need access?’’ Typically, the set of functions that need access is smaller than we are willing to
believe at first.
Some operations must be members – for example, constructors, destructors, and virtual
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.5.2 Friends and Members 281
functions (§12.2.6) – but typically there is a choice. Because member names are local to the class,
a function should be a member unless there is a specific reason for it to be a nonmember.
Consider a class Xpresenting alternative ways of presenting an operation:
class X{
/ / ...
X(int) ;
int m1() ;
int m2() const;
friend int f1(X&) ;
friend int f2(const X&) ;
friend int f3(X) ;
};
Member functions can be invoked for objects of their class only; no user-defined conversions are
applied. For example:
void g()
{
99.m1() ; / / error: X(99).m1() not tried
99.m2() ; / / error: X(99).m2() not tried
}
The conversion X(int) is not applied to make an Xout of 99.
The global function f1() has a similar property because implicit conversions are not used for
non-constreference arguments (§5.5, §11.3.5). However, conversions may be applied to the arguments of f2() and f3():
void h()
{
f1(99) ; / / error: f1(X(99)) not tried
f2(99) ; / / ok: f2(X(99));
f3(99) ; / / ok: f3(X(99));
}
An operation modifying the state of a class object should therefore be a member or a global function taking a non-constreference argument (or a non-constpointer argument). Operators that
require lvalue operands for the fundamental types (=, *=, ++, etc.) are most naturally defined as
members for user-defined types.
Conversely, if implicit type conversion is desired for all operands of an operation, the function
implementing it must be a nonmember function taking a constreference argument or a nonreference argument. This is often the case for the functions implementing operators that do not
require lvalue operands when applied to fundamental types (+, -, ||, etc.). Such operators often
need access to the representations of their operand class. Consequently, binary operators are the
most common source of friendfunctions.
If no type conversions are defined, there appears to be no compelling reason to choose a member over a friend taking a reference argument, or vice versa. In some cases, the programmer may
have a preference for one call syntax over another. For example, most people seem to prefer the
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
282 Operator Overloading Chapter 11
notation inv(m) for inverting a Matrix mto the alternative m.inv(). Naturally, if inv() really
does invert mitself, rather than return a new Matrixthat is the inverse of m, it should be a member.
All other things considered equal, choose a member. It is not possible to know if someone
someday will define a conversion operator. It is not always possible to predict if a future change
may require changes to the state of the object involved. The member function call syntax makes it
clear to the user that the object may be modified; a reference argument is far less obvious. Furthermore, expressions in the body of a member can be noticeably shorter than the equivalent expressions in a global function; a nonmember function must use an explicit argument, whereas the member can use thisimplicitly. Also, because member names are local to the class they tend to be
shorter than the names of nonmember functions.
11.6 Large Objects [over.large]
We defined the complexoperators to take arguments of type complex. This implies that for each
use of a complexoperator, each operand is copied. The overhead of copying two doublescan be
noticeable but often less than what a pair of pointers impose. Unfortunately, not all classes have a
conveniently small representation. To avoid excessive copying, one can declare functions to take
reference arguments. For example:
class Matrix{
double m[4][4] ;
public:
Matrix() ;
friend Matrix operator+(const Matrix&, const Matrix&) ;
friend Matrix operator*(const Matrix&, const Matrix&) ;
};
References allow the use of expressions involving the usual arithmetic operators for large objects
without excessive copying. Pointers cannot be used because it is not possible to redefine the meaning of an operator applied to a pointer. Addition could be defined like this:
Matrix operator+(const Matrix& arg1, const Matrix& arg2)
{
Matrix sum;
for(int i=0; i<4; i++)
for(int j=0; j<4; j++)
sum.m[i][j] = arg1.m[i][j] + arg2.m[i][j] ;
return sum;
}
This operator+() accesses the operands of + through references but returns an object value.
Returning a reference would appear to be more efficient:
class Matrix{
/ / ...
friend Matrix& operator+(const Matrix&, const Matrix&) ;
friend Matrix& operator*(const Matrix&, const Matrix&) ;
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.6 Large Objects 283
This is legal, but it causes a memory allocation problem. Because a reference to the result will be
passed out of the function as a reference to the return value, the return value cannot be an automatic
variable (§7.3). Since an operator is often used more than once in an expression, the result cannot
be a staticlocal variable. The result would typically be allocated on the free store. Copying the
return value is often cheaper (in execution time, code space, and data space) than allocating and
(eventually) deallocating an object on the free store. It is also much simpler to program.
There are techniques you can use to avoid copying the result. The simplest is to use a buffer of
static objects. For example:
const max_matrix_temp= 7;
Matrix& get_matrix_temp()
{
static int nbuf= 0;
static Matrix buf[max_matrix_temp] ;
if(nbuf== max_matrix_temp) nbuf= 0;
return buf[nbuf++] ;
}
Matrix& operator+(const Matrix& arg1, const Matrix& arg2)
{
Matrix& res= get_matrix_temp() ;
/ / ...
return res;
}
Now a Matrixis copied only when the result of an expression is assigned. However, heaven help
you if you write an expression that involves more than max_matrix_temptemporaries!
A less error-prone technique involves defining the matrix type as a handle (§25.7) to a representation type that really holds the data. In that way, the matrix handles can manage the representation
objects in such a way that allocation and copying are minimized (see §11.12 and §11.14[18]).
However, that strategy relies on operators returning objects rather than references or pointers.
Another technique is to define ternary operations and have them automatically invoked for expressions such as a=b+cand a+b*i(§21.4.6.3, §22.4.7).
11.7 Essential Operators [over.essential]
In general, for a type X, the copy constructor X(const X&) takes care of initialization by an object
of the same type X. It cannot be overemphasized that assignment and initialization are different
operations (§10.4.4.1). This is especially important when a destructor is declared. If a class Xhas
a destructor that performs a nontrivial task, such as free-store deallocation, the class is likely to
need the full complement of functions that control construction, destruction, and copying:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
284 Operator Overloading Chapter 11
class X{
/ / ...
X(Sometype) ; / / constructor: create objects
X(const X&) ; / / copy constructor
X& operator=(const X&) ; / / copy assignment: cleanup and copy
~X() ; / / destructor: cleanup
};
There are three more cases in which an object is copied: as a function argument, as a function
return value, and as an exception. When an argument is passed, a hitherto uninitialized variable –
the formal parameter – is initialized. The semantics are identical to those of other initializations.
The same is the case for function return values and exceptions, although that is less obvious. In
such cases, the copy constructor will be applied. For example:
string g(string arg)
{
return arg;
}
int main()
{
string s= "Newton";
s= g(s) ;
}
Clearly, the value of sought to be "Newton"after the call of g(). Getting a copy of the value of s
into the argument argis not difficult; a call of string’s copy constructor does that. Getting a copy
of that value out of g() takes another call of string(const string&); this time, the variable initialized is a temporary one, which is then assigned to s. Often one, but not both, of these copy operations can be optimized away. Such temporary variables are, of course, destroyed properly using
string: :~string() (see §10.4.10).
For a class Xfor which the assignment operator X: :operator=(const X&) and the copy constructor X: :X(const X&) are not explicitly declared by the programmer, the missing operation or
operations will be generated by the compiler (§10.2.5).
11.7.1 Explicit Constructors [over.explicit]
By default, a single argument constructor also defines an implicit conversion. For some types, that
is ideal. For example:
complex z= 2; / / initialize z with complex(2)
In other cases, the implicit conversion is undesirable and error-prone. For example:
string s= ´a´; / / make s a string with int(’a’) elements
It is quite unlikely that this was what the person defining smeant.
Implicit conversion can be suppressed by declaring a constructor explicit. That is, an explicit
constructor will be invoked only explicitly. In particular, where a copy constructor is in principle
needed (§11.3.4), an explicitconstructor will not be implicitly invoked. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.7.1 Explicit Constructors 285
class String{
/ / ...
explicit String(int n) ; / / preallocate n bytes
String(const char* p) ; / / initial value is the C-style string p
};
String s1= ´a´; / / error: no implicit char– >String conversion
String s2(10) ; / / ok: String with space for 10 characters
String s3= String(10) ; / / ok: String with space for 10 characters
String s4= "Brian"; / / ok: s4 = String("Brian")
String s5("Fawlty") ;
void f(String) ;
String g()
{
f(10) ; / / error: no implicit int– >String conversion
f(String(10)) ;
f("Arthur") ; / / ok: f(String("Arthur"))
f(s1) ;
String* p1= new String("Eric") ;
String* p2= new String(10) ;
return 10; / / error: no implicit int– >String conversion
}
The distinction between
String s1= ´a´; / / error: no implicit char– >String conversion
and
String s2(10) ; / / ok: string with space for 10 characters
may seem subtle, but it is less so in real code than in contrived examples.
In Date, we used a plain intto represent a year (§10.3). Had Datebeen critical in our design,
we might have introduced a Yeartype to allow stronger compile-time checking. For example:
class Year{
int y;
public:
explicit Year(int i) : y(i) { } / / construct Year from int
operator int() const{ return y; } / / conversion: Year to int
};
class Date{
public:
Date(int d, Month m, Year y) ;
/ / ...
};
Date d3(1978,feb,21) ; / / error: 21 is not a Year
Date d4(21,feb,Year(1978)) ; / / ok
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
286 Operator Overloading Chapter 11
The Yearclass is a simple ‘‘wrapper’’ around an int. Thanks to the operator int(), a Yearis
implicitly converted into an intwherever needed. By declaring the constructor explicit, we make
sure that the intto Yearhappens only when we ask for it and that ‘‘accidental’’ assignments are
caught at compile time. Because Year’s member functions are easily inlined, no run-time or space
costs are added.
A similar technique can be used to define range types (§25.6.1).
11.8 Subscripting [over.subscript]
An operator[] function can be used to give subscripts a meaning for class objects. The second
argument (the subscript) of an operator[] function may be of any type. This makes it possible to
define vectors, associative arrays, etc.
As an example, let us recode the example from §5.5 in which an associative array is used to
write a small program for counting the number of occurrences of words in a file. There, a function
is used. Here, an associative array type is defined:
class Assoc{
struct Pair{
string name;
double val;
Pair(string n="", double v=0) :name(n) , val(v) { }
};
vector<Pair> vec;
Assoc(const Assoc&) ; / / private to prevent copying
Assoc& operator=(const Assoc&) ; / / private to prevent copying
public:
Assoc() {}
double& operator[](const string&) ;
void print_all() const;
};
An Assockeeps a vector of Pairs. The implementation uses the same trivial and inefficient search
method as in §5.5:
double& Assoc: :operator[](const string& s)
/ / search for s; return its value if found; otherwise, make a new Pair and return the default value 0
{
for(vector<Pair>: :const_iterator p= vec.begin() ; p!=vec.end() ; ++p)
if(s== p->name) return p->val;
vec.push_back(Pair(s,0)) ; / / initial value: 0
return vec.back().val; / / return last element (§16.3.3)
}
Because the representation of an Associs hidden, we need a way of printing it:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.8 Subscripting 287
void Assoc: :print_all() const
{
for(vector<Pair>: :const_iterator p= vec.begin() ; p!=vec.end() ; ++p)
cout<< p->name<< ": " << p->val<< ´\n´;
}
Finally, we can write the trivial main program:
int main() / / count the occurrences of each word on input
{
string buf;
Assoc vec;
while(cin>>buf) vec[buf]++;
vec.print_all() ;
}
A further development of the idea of an associative array can be found in §17.4.1.
An operator[]() must be a member function.
11.9 Function Call [over.call]
Function call, that is, the notation expression(expression-list), can be interpreted as a binary operation with the expression as the left-hand operand and the expression-list as the right-hand operand.
The call operator () can be overloaded in the same way as other operators can. An argument list
for an operator()() is evaluated and checked according to the usual argument-passing rules.
Overloading function call seems to be useful primarily for defining types that have only a single
operation and for types for which one operation is predominant.
The most obvious, and probably also the most important, use of the () operator is to provide
the usual function call syntax for objects that in some way behave like functions. An object that
acts like a function is often called a function-like object or simply a function object (§18.4). Such
function objects are important because they allow us to write code that takes nontrivial operations
as parameters. For example, the standard library provides many algorithms that invoke a function
for each element of a container. Consider:
void negate(complex& c) { c= -c; }
void f(vector<complex>& aa, list<complex>& ll)
{
for_each(aa.begin() ,aa.end() ,negate) ; / / negate all vector elements
for_each(ll.begin() ,ll.end() ,negate) ; / / negate all list elements
}
This negates every element in the vector and the list.
What if we wanted to add complex(2,3) to every element? That is easily done like this:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
288 Operator Overloading Chapter 11
void add23(complex& c)
{
c+= complex(2,3) ;
}
void g(vector<complex>& aa, list<complex>& ll)
{
for_each(aa.begin() ,aa.end() ,add23) ;
for_each(ll.begin() ,ll.end() ,add23) ;
}
How would we write a function to repeatedly add an arbitrary complex value? We need something
to which we can pass that arbitrary value and which can then use that value each time it is called.
That does not come naturally for functions. Typically, we end up ‘‘passing’’ the arbitrary value by
leaving it in the function’s surrounding context. That’s messy. However, we can write a class that
behaves in the desired way:
class Add{
complex val;
public:
Add(complex c) { val= c; } / / save value
Add(double r, double i) { val= complex(r,i) ; }
void operator()(complex& c) const{ c+= val; } / / add value to argument
};
An object of class Addis initialized with a complex number, and when invoked using (), it adds
that number to its argument. For example:
void h(vector<complex>& aa, list<complex>& ll, complex z)
{
for_each(aa.begin() ,aa.end() ,Add(2,3)) ;
for_each(ll.begin() ,ll.end() ,Add(z)) ;
}
This will add complex(2,3) to every element of the array and zto every element on the list. Note
that Add(z) constructs an object that is used repeatedly by for_each(). It is not simply a function
that is called once or even called repeatedly. The function that is called repeatedly is Add(z)’s
operator()().
This all works because for_eachis a template that applies () to its third argument without caring exactly what that third argument really is:
template<class Iter, class Fct> Iter for_each(Iter b, Iter e, Fct f)
{
while(b!= e) f(*b++) ;
return b;
}
At first glance, this technique may look esoteric, but it is simple, efficient, and extremely useful
(see §3.8.5, §18.4).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.9 Function Call 289
Other popular uses of operator()() are as a substring operator and as a subscripting operator
for multidimensional arrays (§22.4.5).
An operator()() must be a member function.
11.10 Dereferencing [over.deref]
The dereferencing operator -> can be defined as a unary postfix operator. That is, given a class
class Ptr{
/ / ...
X* operator->() ;
};
objects of class Ptrcan be used to access members of class Xin a very similar manner to the way
pointers are used. For example:
void f(Ptr p)
{
p->m= 7; / / (p.operator– >())– >m = 7
}
The transformation of the object pinto the pointer p.operator->() does not depend on the member mpointed to. That is the sense in which operator->() is a unary postfix operator. However,
there is no new syntax introduced, so a member name is still required after the ->. For example:
void g(Ptr p)
{
X* q1= p->; / / syntax error
X* q2= p.operator->() ; / / ok
}
Overloading -> is primarily useful for creating ‘‘smart pointers,’’ that is, objects that act like pointers and in addition perform some action whenever an object is accessed through them. For example, one could define a class Rec_ptrfor accessing objects of class Recstored on disk. Rec_ptr’s
constructor takes a name that can be used to find the object on disk, Rec_ptr: :operator->()
brings the object into main memory when accessed through its Rec_ptr, and Rec_ptr’s destructor
eventually writes the updated object back out to disk:
class Rec_ptr{
Rec* in_core_address;
const char* identifier;
/ / ...
public:
Rec_ptr(const char* p) : identifier(p) , in_core_address(0) { }
~Rec_ptr() { write_to_disk(in_core_address,identifier) ; }
Rec* operator->() ;
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
290 Operator Overloading Chapter 11
Rec* Rec_ptr: :operator->()
{
if(in_core_address== 0) in_core_address= read_from_disk(identifier) ;
return in_core_address;
}
Rec_ptrmight be used like this:
struct Rec{ / / the Rec that a Rec_ptr points to
string name;
/ / ...
};
void update(const char* s)
{
Rec_ptr p(s) ; / / get Rec_ptr for s
p->name= "Roscoe"; / / update s; if necessary, first retrieve from disk
/ / ...
}
Naturally, a real Rec_ptrwould be a template so that the Rectype is a parameter. Also, a realistic
program would contain error-handling code and use a less naive way of interacting with the disk.
For ordinary pointers, use of -> is synonymous with some uses of unary * and []. Given
Y* p;
it holds that
p->m== (*p).m== p[0].m
As usual, no such guarantee is provided for user-defined operators. The equivalence can be provided where desired:
class Ptr_to_Y{
Y* p;
public:
Y* operator->() { return p; }
Y& operator*() { return*p; }
Y& operator[](int i) { return p[i] ; }
};
If you provide more than one of these operators, it might be wise to provide the equivalence, just as
it is wise to ensure that ++xand x+=1have the same effect as x=x+1for a simple variable xof
some class if ++, +=, =, and + are provided.
The overloading of -> is important to a class of interesting programs and not just a minor
curiosity. The reason is that indirection is a key concept and that overloading -> provides a clean,
direct, and efficient way of representing indirection in a program. Iterators (Chapter 19) provide an
important example of this. Another way of looking at operator -> is to consider it as a way of providing C++ with a limited, but useful, form of delegation (§24.2.4).
Operator -> must be a member function. If used, its return type must be a pointer or an object
of a class to which you can apply ->. When declared for a template class, operator->() is
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.10 Dereferencing 291
frequently unused, so it makes sense to postpone checking the constraint on the return type until
actual use.
11.11 Increment and Decrement [over.incr]
Once people invent ‘‘smart pointers,’’ they often decide to provide the increment operator ++ and
the decrement operator -- to mirror these operators’ use for built-in types. This is especially obvious and necessary where the aim is to replace an ordinary pointer type with a ‘‘smart pointer’’ type
that has the same semantics, except that it adds a bit of run-time error checking. For example, consider a troublesome traditional program:
void f1(T a) / / traditional use
{
T v[200] ;
T* p= &v[0] ;
p--;
*p= a; / / Oops: ‘p’ out of range, uncaught
++p;
*p= a; / / ok
}
We might want to replace the pointer pwith an object of a class Ptr_to_Tthat can be dereferenced
only provided it actually points to an object. We would also like to ensure that pcan be incremented and decremented, only provided it points to an object within an array and the increment and
decrement operations yield an object within the array. That is we would like something like this:
class Ptr_to_T{
/ / ...
};
void f2(T a) / / checked
{
T v[200] ;
Ptr_to_T p(&v[0] ,v,200) ;
p--;
*p= a; / / run-time error: ‘p’ out of range
++p;
*p= a; / / ok
}
The increment and decrement operators are unique among C++ operators in that they can be used as
both prefix and postfix operators. Consequently, we must define prefix and postfix increment and
decrement Ptr_to_T. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
292 Operator Overloading Chapter 11
class Ptr_to_T{
T* p;
T* array;
int size;
public:
Ptr_to_T(T* p, T* v, int s) ; / / bind to array v of size s, initial value p
Ptr_to_T(T* p) ; / / bind to single object, initial value p
Ptr_to_T& operator++() ; / / prefix
Ptr_to_T operator++(int) ; / / postfix
Ptr_to_T& operator--() ; / / prefix
Ptr_to_T operator--(int) ; / / postfix
T& operator*() ; / / prefix
};
The intargument is used to indicate that the function is to be invoked for postfix application of ++.
This intis never used; the argument is simply a dummy used to distinguish between prefix and
postfix application. The way to remember which version of an operator++ is prefix is to note that
the version without the dummy argument is prefix, exactly like all the other unary arithmetic and
logical operators. The dummy argument is used only for the ‘‘odd’’ postfix ++ and --.
Using Ptr_to_T, the example is equivalent to:
void f3(T a) / / checked
{
T v[200] ;
Ptr_to_T p(&v[0] ,v,200) ;
p.operator--(0) ;
p.operator*() = a; / / run-time error: ‘p’ out of range
p.operator++() ;
p.operator*() = a; / / ok
}
Completing class Ptr_to_Tis left as an exercise (§11.14[19]). Its elaboration into a template using
exceptions to report the run-time errors is another exercise (§14.12[2]). An example of operators
++ and -- for iteration can be found in §19.3. A pointer template that behaves correctly with
respect to inheritance is presented in (§13.6.3).
11.12 A String Class [over.string]
Here is a more realistic version of class String. I designed it as the minimal string that served my
needs. This string provides value semantics, character read and write operations, checked and
unchecked access, stream I/O, literal strings as literals, and equality and concatenation operators. It
represents strings as C-style, zero-terminated arrays of characters and uses reference counts to minimize copying. Writing a better string class and/or one that provides more facilities is a good exercise (§11.14[7-12]). That done, we can throw away our exercises and use the standard library
string (Chapter 20).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.12 A String Class 293
My almost-real Stringemploys three auxiliary classes: Srep, to allow an actual representation
to be shared between several Strings with the same value; Range, to be thrown in case of range
errors, and Cref, to help implement a subscript operator that distinguishes between reading and
writing:
class String{
struct Srep; / / representation
Srep*rep;
public:
class Cref; / / reference to char
class Range{ }; / / for exceptions
/ / ...
};
Like other members, a member class (often called a nested class) can be declared in the class itself
and defined later:
struct String: :Srep{
char* s; / / pointer to elements
int sz; / / number of characters
int n; / / reference count
Srep(int nsz, const char* p)
{
n= 1;
sz= nsz;
s= new char[sz+1] ; / / add space for terminator
strcpy(s,p) ;
}
~Srep() { delete[] s; }
Srep* get_own_copy() / / clone if necessary
{
if(n==1) return this;
n--;
return new Srep(sz,s) ;
}
void assign(int nsz, const char* p)
{
if(sz!= nsz) {
delete[] s;
sz= nsz;
s= new char[sz+1] ;
}
strcpy(s,p) ;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
294 Operator Overloading Chapter 11
private: / / prevent copying:
Srep(const Srep&) ;
Srep& operator=(const Srep&) ;
};
Class Stringprovides the usual set of constructors, destructor, and assignment operations:
class String{
/ / ...
String() ; / / x = ""
String(const char*) ; / / x = "abc"
String(const String&) ; / / x = other_string
String& operator=(const char*) ;
String& operator=(const String&) ;
~String() ;
/ / ...
};
This Stringhas value semantics. That is, after an assignment s1=s2, the two strings s1and s2are
fully distinct and subsequent changes to the one have no effect on the other. The alternative would
be to give Stringpointer semantics. That would be to let changes to s2after s1=s2also affect the
value of s1. For types with conventional arithmetic operations, such as complex, vector, matrix,
and string, I prefer value semantics. However, for the value semantics to be affordable, a Stringis
implemented as a handle to its representation and the representation is copied only when necessary:
String: :String() / / the empty string is the default value
{
rep= new Srep(0,"") ;
}
String: :String(const String& x) / / copy constructor
{
x.rep->n++;
rep= x.rep; / / share representation
}
String: :~String()
{
if(--rep->n== 0) delete rep;
}
String& String: :operator=(const String& x) / / copy assignment
{
x.rep->n++; / / protects against ‘‘st = st’’
if(--rep->n== 0) delete rep;
rep= x.rep; / / share representation
return*this;
}
Pseudo-copy operations taking const char* arguments are provided to allow string literals:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.12 A String Class 295
String: :String(const char* s)
{
rep= new Srep(strlen(s) ,s) ;
}
String& String: :operator=(const char* s)
{
if(rep->n== 1) / / recycle Srep
rep->assign(strlen(s) ,s) ;
else{ / / use new Srep
rep->n--;
rep= new Srep(strlen(s) ,s) ;
}
return*this;
}
The design of access operators for a string is a difficult topic because ideally access is by conventional notation (that is, using []), maximally efficient, and range checked. Unfortunately, you cannot have all of these properties simultaneously. My choice here has been to provide efficient
unchecked operations with a slightly inconvenient notation plus slightly less efficient checked operators with the conventional notation:
class String{
/ / ...
void check(int i) const{ if(i<0|| rep->sz<=i) throw Range() ; }
char read(int i) const{ return rep->s[i] ; }
void write(int i, char c) { rep=rep->get_own_copy() ; rep->s[i]=c; }
Cref operator[](int i) { check(i) ; return Cref(*this,i) ; }
char operator[](int i) const{ check(i) ; return rep->s[i] ; }
int size() const{ return rep->sz; }
/ / ...
};
The idea is to use [] to get checked access for ordinary use, but to allow the user to optimize by
checking the range once for a set of accesses. For example:
int hash(const String& s)
{
int h= s.read(0) ;
const int max= s.size() ;
for(int i= 1; i<max; i++) h^= s.read(i)>>1; / / unchecked access to s
return h;
}
Defining an operator, such as [], to be used for both reading and writing is difficult where it is not
acceptable simply to return a reference and let the user decide what to do with it. Here, that is not a
reasonable alternative because I have defined Stringso that the representation is shared between
Strings that have been assigned, passed as value arguments, etc., until someone actually writes to a
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
296 Operator Overloading Chapter 11
String. Then, and only then, is the representation copied. This technique is usually called copyon-write. The actual copy is done by String: :Srep: :get_own_copy().
To get these access functions inlined, their definitions must be placed so that the definition of
Srepis in scope. This implies that either Srepis defined within Stringor the access functions are
defined inlineoutside Stringand after String: :Srep(§11.14[2]).
To distinguish between a read and a write, String: :operator[]() returns a Crefwhen called
for a non-constobject. A Crefbehaves like a char&, except that it calls
String: :Srep: :get_own_copy() when written to:
class String: :Cref{ / / reference to s[i]
friend class String;
String& s;
int i;
Cref(String& ss, int ii) : s(ss) , i(ii) { }
public:
operator char() { return s.read(i) ; } / / yield value
void operator=(char c) { s.write(i,c) ; } / / change value
};
For example:
void f(String s, const String& r)
{
int c1= s[1] ; / / c1 = s.operator[](1).operator char()
s[1] = ´c´; / / s.operator[](1).operator=(’c’)
int c2= r[1] ; / / c2 = r.operator[](1)
r[1] = ´d´; / / error: assignment to char, r.operator[](1) = ’d’
}
Note that for a non-constobject s.operator[](1) is Cref(s,1).
To complete class String, I provide a set of useful functions:
class String{
/ / ...
String& operator+=(const String&) ;
String& operator+=(const char*) ;
friend ostream& operator<<(ostream&, const String&) ;
friend istream& operator>>(istream&, String&) ;
friend bool operator==(const String& x, const char* s)
{ return strcmp(x.rep->s, s) == 0; }
friend bool operator==(const String& x, const String& y)
{ return strcmp(x.rep->s, y.rep->s) == 0; }
friend bool operator!=(const String& x, const char* s)
{ return strcmp(x.rep->s, s) != 0; }
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.12 A String Class 297
friend bool operator!=(const String& x, const String& y)
{ return strcmp(x.rep->s, y.rep->s) != 0; }
};
String operator+(const String&, const String&) ;
String operator+(const String&, const char*) ;
To save space, I have left the I/O and concatenation operations as exercises.
The main program simply exercises the Stringoperators a bit:
String f(String a, String b)
{
a[2] = ´x´;
char c= b[3] ;
cout<< "in f: " << a<< ´ ´ << b<< ´ ´ << c<< ´\n´;
return b;
}
int main()
{
String x, y;
cout<< "Please enter two strings\n";
cin>> x>> y;
cout<< "input: " << x<< ´ ´ << y<< ´\n´;
String z= x;
y= f(x,y) ;
if(x!= z) cout<< "x corrupted!\n";
x[0] = ´!´;
if(x== z) cout<< "write failed!\n";
cout<< "exit: " << x<< ´ ´ << y<< ´ ´ << z<< ´\n´;
}
This Stringlacks many features that you might consider important or even essential. For example,
it offers no operation of producing a C-string representation of its value (§11.14[10], Chapter 20).
11.13 Advice [class.advice]
[1] Define operators primarily to mimic conventional usage; §11.1.
[2] For large operands, use constreference argument types; §11.6.
[3] For large results, consider optimizing the return; §11.6.
[4] Prefer the default copy operations if appropriate for a class; §11.3.4.
[5] Redefine or prohibit copying if the default is not appropriate for a type; §11.2.2.
[6] Prefer member functions over nonmembers for operations that need access to the representation; §11.5.2.
[7] Prefer nonmember functions over members for operations that do not need access to the representation; §11.5.2.
[8] Use namespaces to associate helper functions with ‘‘their’’ class; §11.2.4.
[9] Use nonmember functions for symmetric operators; §11.3.2.
[10] Use () for subscripting multidimensional arrays; §11.9.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
298 Operator Overloading Chapter 11
[11] Make constructors that take a single ‘‘size argument’’ explicit; §11.7.1.
[12] For non-specialized uses, prefer the standard string(Chapter 20) to the result of your own
exercises; §11.12.
[13] Be cautious about introducing implicit conversions; §11.4.
[14] Use member functions to express operators that require an lvalue as its left-hand operand;
§11.3.5.
11.14 Exercises [over.exercises]
1. (∗2) In the following program, which conversions are used in each expression?
struct X{
int i;
X(int) ;
operator+(int) ;
};
struct Y{
int i;
Y(X) ;
operator+(X) ;
operator int() ;
};
extern X operator*(X, Y) ;
extern int f(X) ;
X x= 1;
Y y= x;
int i= 2;
int main()
{
i+ 10; y+ 10; y+ 10* y;
x+ y+ i; x* x+ i; f(7) ;
f(y) ; y+ y; 106+ y;
}
Modify the program so that it will run and print the values of each legal expression.
2. (∗2) Complete and test class Stringfrom §11.12.
3. (∗2) Define a class INTthat behaves exactly like an int. Hint: Define INT: :operator int().
4. (∗1) Define a class RINTthat behaves like an intexcept that the only operations allowed are +
(unary and binary), - (unary and binary), *, /, and %. Hint: Do not define RINT: :operator
int().
5. (∗3) Define a class LINTthat behaves like a RINT, except that it has at least 64 bits of precision.
6. (∗4) Define a class implementing arbitrary precision arithmetic. Test it by calculating the factorial of 1000. Hint: You will need to manage storage in a way similar to what was done for class
String.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 11.14 Exercises 299
7. (∗2) Define an external iterator for class String:
class String_iter{
/ / refer to string and string element
public:
String_iter(String& s) ; / / iterator for s
char& next() ; / / reference to next element
/ / more operations of your choice
};
Compare this in utility, programming style, and efficiency to having an internal iterator for
String(that is, a notion of a current element for the Stringand operations relating to that element).
8. (∗1.5) Provide a substring operator for a string class by overloading (). What other operations
would you like to be able to do on a string?
9. (∗3) Design class Stringso that the substring operator can be used on the left-hand side of an
assignment. First, write a version in which a string can be assigned to a substring of the same
length. Then, write a version in which the lengths may differ.
10. (∗2) Define an operation for Stringthat produces a C-string representation of its value. Discuss
the pros and cons of having that operation as a conversion operator. Discuss alternatives for
allocating the memory for that C-string representation.
11. (∗2.5) Define and implement a simple regular expression pattern match facility for class String.
12. (∗1.5) Modify the pattern match facility from §11.14[11] to work on the standard library string.
Note that you cannot modify the definition of string.
13. (∗2) Write a program that has been rendered unreadable through use of operator overloading
and macros. An idea: Define + to mean - and vice versa for INTs. Then, use a macro to define
intto mean INT. Redefine popular functions using reference type arguments. Writing a few
misleading comments can also create great confusion.
14. (∗3) Swap the result of §11.14[13] with a friend. Without running it, figure out what your
friend’s program does. When you have completed this exercise, you’ll know what to avoid.
15. (∗2) Define a type Vec4as a vector of four floats. Define operator[] for Vec4. Define operators +, -, *, /, =, +=, -=, *=, and /= for combinations of vectors and floating-point numbers.
16. (∗3) Define a class Mat4as a vector of four Vec4s. Define operator[] to return a Vec4for
Mat4. Define the usual matrix operations for this type. Define a function doing Gaussian elimination for a Mat4.
17. (∗2) Define a class Vectorsimilar to Vec4but with the size given as an argument to the constructor Vector: :Vector(int).
18. (∗3) Define a class Matrixsimilar to Mat4but with the dimensions given as arguments to the
constructor Matrix: :Matrix(int,int).
19. (∗2) Complete class Ptr_to_Tfrom §11.11 and test it. To be complete, Ptr_to_Tmust have at
least the operators *, ->, =, ++, and -- defined. Do not cause a run-time error until a wild
pointer is actually dereferenced.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
300 Operator Overloading Chapter 11
20. (∗1) Given two structures:
struct S{ int x, y; };
struct T{ char* p; char* q; };
write a class Cthat allows the use of xand pfrom some Sand T, much as if xand phad been
members of C.
21. (∗1.5) Define a class Indexto hold the index for an exponentiation function
mypow(double,Index). Find a way to have 2**Icall mypow(2,I).
22. (∗2) Define a class Imaginaryto represent imaginary numbers. Define class Complexbased on
that. Implement the fundamental arithmetic operators.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
12 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
Derived Classes
Do not multiply objects without necessity.
– W. Occam
Concepts and classes — derived classes — member functions — construction and
destruction — class hierarchies — type fields — virtual functions — abstract classes —
traditional class hierarchies — abstract classes as interfaces — localizing object creation
— abstract classes and class hierarchies — advice — exercises.
12.1 Introduction [derived.intro]
From Simula, C++ borrowed the concept of a class as a user-defined type and the concept of class
hierarchies. In addition, it borrowed the idea for system design that classes should be used to
model concepts in the programmer’s and the application’s world. C++ provides language constructs that directly support these design notions. Conversely, using the language features in support of design concepts distinguishes effective use of C++. Using language constructs only as notational props for more traditional types of programming is to miss key strengths of C++.
A concept does not exist in isolation. It coexists with related concepts and derives much of its
power from relationships with related concepts. For example, try to explain what a car is. Soon
you’ll have introduced the notions of wheels, engines, drivers, pedestrians, trucks, ambulances,
roads, oil, speeding tickets, motels, etc. Since we use classes to represent concepts, the issue
becomes how to represent relationships between concepts. However, we can’t express arbitrary
relationships directly in a programming language. Even if we could, we wouldn’t want to. Our
classes should be more narrowly defined than our everyday concepts – and more precise. The
notion of a derived class and its associated language mechanisms are provided to express hierarchical relationships, that is, to express commonality between classes. For example, the concepts of a
circle and a triangle are related in that they are both shapes; that is, they have the concept of a shape
in common. Thus, we must explicitly define class Circleand class Triangleto have class Shapein
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
302 Derived Classes Chapter 12
common. Representing a circle and a triangle in a program without involving the notion of a shape
would be to lose something essential. This chapter is an exploration of the implications of this simple idea, which is the basis for what is commonly called object-oriented programming.
The presentation of language features and techniques progress from the simple and concrete to
the more sophisticated and abstract. For many programmers, this will also be a progression from
the familiar towards the less well known. This is not a simple journey from ‘‘bad old techniques’’
towards ‘‘the one right way.’’ When I point out limitations of one technique as a motivation for
another, I do so in the context of specific problems; for different problems or in other contexts, the
first technique may indeed be the better choice. Useful software has been constructed using all of
the techniques presented here. The aim is to help you attain sufficient understanding of the techniques to be able to make intelligent and balanced choices among them for real problems.
In this chapter, I first introduce the basic language features supporting object-oriented programming. Next, the use of those features to develop well-structured programs is discussed in the context of a larger example. Further facilities supporting object-oriented programming, such as multiple inheritance and run-time type identification, are discussed in Chapter 15.
12.2 Derived Classes [derived.derived]
Consider building a program dealing with people employed by a firm. Such a program might have
a data structure like this:
struct Employee{
string first_name, family_name;
char middle_initial;
Date hiring_date;
short department;
/ / ...
};
Next, we might try to define a manager:
struct Manager{
Employee emp; / / manager’s employee record
set<Employee*> group; / / people managed
short level;
/ / ...
};
A manager is also an employee; the Employeedata is stored in the empmember of a Manager
object. This may be obvious to a human reader – especially a careful reader – but there is nothing
that tells the compiler and other tools that Manageris also an Employee. A Manager* is not an
Employee*, so one cannot simply use one where the other is required. In particular, one cannot put
a Manageronto a list of Employees without writing special code. We could either use explicit
type conversion on a Manager* or put the address of the empmember onto a list of employees.
However, both solutions are inelegant and can be quite obscure. The correct approach is to explicitly state that a Manager is an Employee, with a few pieces of information added:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 12.2 Derived Classes 303
struct Manager: public Employee{
set<Employee*> group;
short level;
/ / ...
};
The Manageris derived from Employee, and conversely, Employeeis a base class for Manager.
The class Managerhas the members of class Employee(name, age, etc.) in addition to its own
members (group, level, etc.).
Derivation is often represented graphically by a pointer from the derived class to its base class
indicating that the derived class refers to its base (rather than the other way around):
Employee
Manager
.
A derived class is often said to inherit properties from its base, so the relationship is also called
inheritance. A base class is sometimes called a superclass and a derived class a subclass. This terminology, however, is confusing to people who observe that the data in a derived class object is a
superset of the data of an object of its base class. A derived class is larger than its base class in the
sense that it holds more data and provides more functions.
A popular and efficient implementation of the notion of derived classes has an object of the
derived class represented as an object of the base class, with the information belonging specifically
to the derived class added at the end. For example:
first_name
family_name
...
first_name
family_name
...
group
level
...
Employee: Manager:
Deriving Managerfrom Employeein this way makes Managera subtype of Employeeso that a
Managercan be used wherever an Employeeis acceptable. For example, we can now create a list
of Employees, some of whom are Managers:
void f(Manager m1, Employee e1)
{
list<Employee*> elist;
elist.push_front(&m1) ;
elist.push_front(&e1) ;
/ / ...
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
304 Derived Classes Chapter 12
A Manageris (also) an Employee, so a Manager* can be used as a Employee*. However, an
Employeeis not necessarily a Manager, so an Employee* cannot be used as a Manager*. In general, if a class Derivedhas a public base class (§15.3) Base, then a Derived* can be assigned to a
variable of type Base* without the use of explicit type conversion. The opposite conversion, from
Base* to Derived*, must be explicit. For example:
void g(Manager mm, Employee ee)
{
Employee* pe= &mm; / / ok: every Manager is an Employee
Manager* pm= &ee; / / error: not every Employee is a Manager
pm->level= 2; / / disaster: ee doesn’t have a ‘level’
pm= static_cast<Manager*>(pe) ; / / brute force: works because pe points
/ / to the Manager mm
pm->level= 2; / / fine: pm points to the Manager mm that has a ‘level’
}
In other words, an object of a derived class can be treated as an object of its base class when manipulated through pointers and references. The opposite is not true. The use of static_castand
dynamic_castis discussed in §15.4.2.
Using a class as a base is equivalent to declaring an (unnamed) object of that class. Consequently, a class must be defined in order to be used as a base (§5.7):
class Employee; / / declaration only, no definition
class Manager: public Employee{ / / error: Employee not defined
/ / ...
};
12.2.1 Member Functions [derived.member]
Simple data structures, such as Employeeand Manager, are really not that interesting and often not
particularly useful. We need to give the information as a proper type that provides a suitable set of
operations that present the concept, and we need to do this without tying us to the details of a particular representation. For example:
class Employee{
string first_name, family_name;
char middle_initial;
/ / ...
public:
void print() const;
string full_name() const
{ return first_name+ ´ ´ + middle_initial+ ´ ´ + family_name; }
/ / ...
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 12.2.1 Member Functions 305
class Manager: public Employee{
/ / ...
public:
void print() const;
/ / ...
};
A member of a derived class can use the public – and protected (see §15.3) – members of its base
class as if they were declared in the derived class itself. For example:
void Manager: :print() const
{
cout<< "name is" << full_name() << ´\n´;
/ / ...
}
However, a derived class cannot use a base class’ private names:
void Manager: :print() const
{
cout<< " name is" << family_name<< ´\n´; / / error!
/ / ...
}
This second version of Manager: :print() will not compile. A member of a derived class has no
special permission to access private members of its base class, so family_nameis not accessible to
Manager: :print().
This comes as a surprise to some, but consider the alternative: that a member function of a
derived class could access the private members of its base class. The concept of a private member
would be rendered meaningless by allowing a programmer to gain access to the private part of a
class simply by deriving a new class from it. Furthermore, one could no longer find all uses of a
private name by looking at the functions declared as members and friends of that class. One would
have to examine every source file of the complete program for derived classes, then examine every
function of those classes, then find every class derived from those classes, etc. This is, at best,
tedious and often impractical. Where it is acceptable, protected– rather than private– members
can be used. A protected member is like a public member to a member of a derived class, yet it is
like a private member to other functions (see §15.3).
Typically, the cleanest solution is for the derived class to use only the public members of its
base class. For example:
void Manager: :print() const
{
Employee: :print() ; / / print Employee information
cout<< level; / / print Manager-specific information
/ / ...
}
Note that : : must be used because print() has been redefined in Manager. Such reuse of names
is typical. The unwary might write this:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
306 Derived Classes Chapter 12
void Manager: :print() const
{
print() ; / / oops!
/ / print Manager-specific information
}
and find the program involved in an unexpected sequence of recursive calls.
12.2.2 Constructors and Destructors [derived.ctor]
Some derived classes need constructors. If a base class has constructors, then a constructor must be
invoked. Default constructors can be invoked implicitly. However, if all constructors for a base
require arguments, then a constructor for that base must be explicitly called. Consider:
class Employee{
string first_name, family_name;
short department;
/ / ...
public:
Employee(const string& n, int d) ;
/ / ...
};
class Manager: public Employee{
set<Employee*> group; / / people managed
short level;
/ / ...
public:
Manager(const string& n, int d, int lvl) ;
/ / ...
};
Arguments for the base class’ constructor are specified in the definition of a derived class’ constructor. In this respect, the base class acts exactly like a member of the derived class (§10.4.6).
For example:
Employee: :Employee(const string& n, int d)
: family_name(n) , department(d) / / initialize members
{
/ / ...
}
Manager: :Manager(const string& n, int d, int lvl)
: Employee(n,d) , / / initialize base
level(lvl) / / initialize members
{
/ / ...
}
A derived class constructor can specify initializers for its own members and immediate bases only;
it cannot directly initialize members of a base. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 12.2.2 Constructors and Destructors 307
Manager: :Manager(const string& n, int d, int lvl)
: family_name(n) , / / error: family_name not declared in manager
department(d) , / / error: department not declared in manager
level(lvl)
{
/ / ...
}
This definition contains three errors: it fails to invoke Employee´sconstructor, and twice it
attempts to initialize members of Employeedirectly.
Class objects are constructed from the bottom up: first the base, then the members, and then the
derived class itself. They are destroyed in the opposite order: first the derived class itself, then the
members, and then the base. Members and bases are constructed in order of declaration in the class
and destroyed in the reverse order. See also §10.4.6 and §15.2.4.1.
12.2.3 Copying [derived.copy]
Copying of class objects is defined by the copy constructor and assignments (§10.4.4.1). Consider:
class Employee{
/ / ...
Employee& operator=(const Employee&) ;
Employee(const Employee&) ;
};
void f(const Manager& m)
{
Employee e= m; / / construct e from Employee part of m
e= m; / / assign Employee part of m to e
}
Because the Employeecopy functions do not know anything about Managers, only the Employee
part of a Manageris copied. This is commonly referred to as slicing and can be a source of surprises and errors. One reason to pass pointers and references to objects of classes in a hierarchy is
to avoid slicing. Other reasons are to preserve polymorphic behavior (§2.5.4, §12.2.6) and to gain
efficiency.
12.2.4 Class Hierarchies [derived.hierarchy]
A derived class can itself be a base class. For example:
class Employee{ /* ... */ };
class Manager: public Employee{ /* ... */ };
class Director: public Manager{ /* ... */ };
Such a set of related classes is traditionally called a class hierarchy. Such a hierarchy is most often
a tree, but it can also be a more general graph structure. For example:
class Temporary{ /* ... */ };
class Secretary: public Employee{ /* ... */ };
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
308 Derived Classes Chapter 12
class Tsec: public Temporary, public Secretary{ /* ... */ };
class Consultant: public Temporary, public Manager{ /* ... */ };
Or graphically:
Temporary Employee
Tsec
Secretary Manager
Consultant Director
.
Thus, as is explained in detail in §15.2, C++ can express a directed acyclic graph of classes.
12.2.5 Type Fields [derived.typefield]
To use derived classes as more than a convenient shorthand in declarations, we must solve the following problem: Given a pointer of type base*, to which derived type does the object pointed to
really belong? There are four fundamental solutions to the problem:
[1] Ensure that only objects of a single type are pointed to (§2.7, Chapter 13).
[2] Place a type field in the base class for the functions to inspect.
[3] Use dynamic_cast(§15.4.2, §15.4.5).
[4] Use virtual functions (§2.5.5, §12.2.6).
Pointers to base classes are commonly used in the design of container classes such as set, vector,
and list. In this case, solution 1 yields homogeneous lists, that is, lists of objects of the same type.
Solutions 2, 3, and 4 can be used to build heterogeneous lists, that is, lists of (pointers to) objects of
several different types. Solution 3 is a language-supported variant of solution 2. Solution 4 is a
special type-safe variation of solution 2. Combinations of solutions 1 and 4 are particularly interesting and powerful; in almost all situations, they yield cleaner code than do solutions 2 and 3.
Let us first examine the simple type-field solution to see why it is most often best avoided. The
manager/employee example could be redefined like this:
struct Employee{
enum Empl_type{ M, E};
Empl_type type;
Employee() : type(E) { }
string first_name, family_name;
char middle_initial;
Date hiring_date;
short department;
/ / ...
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 12.2.5 Type Fields 309
struct Manager: public Employee{
Manager() { type= M; }
set<Employee*> group; / / people managed
short level;
/ / ...
};
Given this, we can now write a function that prints information about each Employee:
void print_employee(const Employee* e)
{
switch(e->type) {
case Employee: :E:
cout<< e->family_name<< ´\t´ << e->department<< ´\n´;
/ / ...
break;
case Employee: :M:
{ cout<< e->family_name<< ´\t´ << e->department<< ´\n´;
/ / ...
const Manager* p= static_cast<const Manager*>(e) ;
cout<< " level" << p->level<< ´\n´;
/ / ...
break;
}
}
}
and use it to print a list of Employees, like this:
void print_list(const list<Employee*>& elist)
{
for(list<Employee*>: :const_iterator p= elist.begin() ; p!=elist.end() ; ++p)
print_employee(*p) ;
}
This works fine, especially in a small program maintained by a single person. However, it has the
fundamental weakness in that it depends on the programmer manipulating types in a way that cannot be checked by the compiler. This problem is usually made worse because functions such as
print_employee() are organized to take advantage of the commonality of the classes involved.
For example:
void print_employee(const Employee* e)
{
cout<< e->family_name<< ´\t´ << e->department<< ´\n´;
/ / ...
if(e->type== Employee: :M) {
const Manager* p= static_cast<const Manager*>(e) ;
cout<< " level" << p->level<< ´\n´;
/ / ...
}
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
310 Derived Classes Chapter 12
Finding all such tests on the type field buried in a large function that handles many derived classes
can be difficult. Even when they have been found, understanding what is going on can be difficult.
Furthermore, any addition of a new kind of Employeeinvolves a change to all the key functions in
the system – the ones containing the tests on the type field. The programmer must consider every
function that could conceivably need a test on the type field after a change. This implies the need
to access critical source code and the resulting necessary overhead of testing the affected code. The
use of an explicit type conversion is a strong hint that improvement is possible.
In other words, use of a type field is an error-prone technique that leads to maintenance problems. The problems increase in severity as the size of the program increases because the use of a
type field causes a violation of the ideals of modularity and data hiding. Each function using a type
field must know about the representation and other details of the implementation of every class
derived from the one containing the type field.
It also seems that the existence of any common data accessible from every derived class, such
as a type field, tempts people to add more such data. The common base thus becomes the repository of all kinds of ‘‘useful information.’’ This, in turn, gets the implementation of the base and
derived classes intertwined in ways that are most undesirable. For clean design and simpler maintenance, we want to keep separate issues separate and avoid mutual dependencies.
12.2.6 Virtual Functions [derived.virtual]
Virtual functions overcome the problems with the type-field solution by allowing the programmer
to declare functions in a base class that can be redefined in each derived class. The compiler and
loader will guarantee the correct correspondence between objects and the functions applied to them.
For example:
class Employee{
string first_name, family_name;
short department;
/ / ...
public:
Employee(const string& name, int dept) ;
virtual void print() const;
/ / ...
};
The keyword virtualindicates that print() can act as an interface to the print() function defined
in this class and the print() functions defined in classes derived from it. Where such print()
functions are defined in derived classes, the compiler ensures that the right print() for the given
Employeeobject is invoked in each case.
To allow a virtual function declaration to act as an interface to functions defined in derived
classes, the argument types specified for a function in a derived class cannot differ from the argument types declared in the base, and only very slight changes are allowed for the return type
(§15.6.2). A virtual member function is sometimes called a method.
A virtual function must be defined for the class in which it is first declared (unless it is declared
to be a pure virtual function; see §12.3). For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 12.2.6 Virtual Functions 311
void Employee: :print() const
{
cout<< family_name<< ´\t´ << department<< ´\n´;
/ / ...
}
A virtual function can be used even if no class is derived from its class, and a derived class that
does not need its own version of a virtual function need not provide one. When deriving a class,
simply provide an appropriate function, if it is needed. For example:
class Manager: public Employee{
set<Employee*> group;
short level;
/ / ...
public:
Manager(const string& name, int dept, int lvl) ;
void print() const;
/ / ...
};
void Manager: :print() const
{
Employee: :print() ;
cout<< "\tlevel" << level<< ´\n´;
/ / ...
}
A function from a derived class with the same name and the same set of argument types as a virtual
function in a base is said to override the base class version of the virtual function. Except where
we explicitly say which version of a virtual function is called (as in the call Employee: :print()),
the overriding function is chosen as the most appropriate for the object for which it is called.
The global function print_employee() (§12.2.5) is now unnecessary because the print()
member functions have taken its place. A list of Employees can be printed like this:
void print_list(set<Employee*>& s)
{
for(set<Employee*>: :const_iterator p= s.begin() ; p!=s.end() ; ++p)/ / see §2.7.2
(*p)->print() ;
}
or even
void print_list(set<Employee*>& s)
{
for_each(s.begin() ,s.end() ,mem_fun(&Employee: :print)) ; / / see §3.8.5
}
Each Employeewill be written out according to its type. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
312 Derived Classes Chapter 12
int main()
{
Employee e("Brown",1234) ;
Manager m("Smith",1234,2) ;
set<Employee*> empl;
empl.push_front(&e) ; / / see §2.5.4
empl.push_front(&m) ;
print_list(empl) ;
}
produced:
Smith 1234
level 2
Brown 1234
Note that this will work even if Employee: :print_list() was written and compiled before the specific derived class Managerwas even conceived of! This is a key aspect of classes. When used
properly, it becomes the cornerstone of object-oriented designs and provides a degree of stability to
an evolving program.
Getting ‘‘the right’’ behavior from Employee’s functions independently of exactly what kind of
Employeeis actually used is called polymorphism. A type with virtual functions is called a
polymorphic type. To get polymorphic behavior in C++, the member functions called must be virtualand objects must be manipulated through pointers or references. When manipulating an object
directly (rather than through a pointer or reference), its exact type is known by the compilation so
that run-time polymorphism is not needed.
Clearly, to implement polymorphism, the compiler must store some kind of type information in
each object of class Employeeand use it to call the right version of the virtual function print(). In
a typical implementation, the space taken is just enough to hold a pointer (§2.5.5). This space is
taken only in objects of a class with virtual functions – not in every object, or even in every object
of a derived class. You pay this overhead only for classes for which you declare virtual functions.
Had you chosen to use the alternative type-field solution, a comparable amount of space would
have been needed for the type field.
Calling a function using the scope resolution operator : : as is done in Manager: :print()
ensures that the virtual mechanism is not used. Otherwise, Manager: :print() would suffer an
infinite recursion. The use of a qualified name has another desirable effect. That is, if a virtual
function is also inline(as is not uncommon), then inline substitution can be used for calls specified
using : :. This provides the programmer with an efficient way to handle some important special
cases in which one virtual function calls another for the same object. The Manager: :print()
function is an example of this. Because the type of the object is determined in the call of
Manager: :print(), it need not be dynamically determined again for the resulting call of
Employee: :print().
It is worth remembering that the traditional and obvious implementation of a virtual function
call is simply an indirect function call (§2.5.5), so efficiency concerns should not deter anyone from
using a virtual function where an ordinary function call would be acceptably efficient.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 12.3 Abstract Classes 313
12.3 Abstract Classes [derived.abstract]
Many classes resemble class Employeein that they are useful both as themselves and also as bases
for derived classes. For such classes, the techniques described in the previous section suffice.
However, not all classes follow that pattern. Some classes, such as class Shape, represent abstract
concepts for which objects cannot exist. A Shapemakes sense only as the base of some class
derived from it. This can be seen from the fact that it is not possible to provide sensible definitions
for its virtual functions:
class Shape{
public:
virtual void rotate(int) { error("Shape: :rotate") ; } / / inelegant
virtual void draw() { error("Shape: :draw") ; }
/ / ...
};
Trying to make a shape of this unspecified kind is silly but legal:
Shape s; / / silly: ‘‘shapeless shape’’
It is silly because every operation on swill result in an error.
A better alternative is to declare the virtual functions of class Shapeto be pure virtual functions.
A virtual function is ‘‘made pure’’ by the initializer = 0:
class Shape{ / / abstract class
public:
virtual void rotate(int) = 0; / / pure virtual function
virtual void draw() = 0; / / pure virtual function
virtual bool is_closed() = 0; / / pure virtual function
/ / ...
};
A class with one or more pure virtual functions is an abstract class, and no objects of that abstract
class can be created:
Shape s; / / error: variable of abstract class Shape
An abstract class can be used only as an interface and as a base for other classes. For example:
class Point{ /* ... */ };
class Circle: public Shape{
public:
void rotate(int) { } / / override Shape::rotate
void draw() ; / / override Shape::draw
bool is_closed() { return true; } / / override Shape::is_closed
Circle(Point p, int r) ;
private:
Point center;
int radius;
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
314 Derived Classes Chapter 12
A pure virtual function that is not defined in a derived class remains a pure virtual function, so the
derived class is also an abstract class. This allows us to build implementations in stages:
class Polygon: public Shape{ / / abstract class
public:
bool is_closed() { return true; } / / override Shape::is_closed
/ / ... draw and rotate not overridden ...
};
Polygon b; / / error: declaration of object of abstract class Polygon
class Irregular_polygon: public Polygon{
list<Point> lp;
public:
void draw() ; / / override Shape::draw
void rotate(int) ; / / override Shape::rotate
/ / ...
};
Irregular_polygon poly(some_points) ; / / fine (assume suitable constructor)
An important use of abstract classes is to provide an interface without exposing any implementation
details. For example, an operating system might hide the details of its device drivers behind an
abstract class:
class Character_device{
public:
virtual int open(int opt) = 0;
virtual int close(int opt) = 0;
virtual int read(char* p, int n) = 0;
virtual int write(const char* p, int n) = 0;
virtual int ioctl(int...) = 0;
virtual~Character_device() { } / / virtual destructor
};
We can then specify drivers as classes derived from Character_device, and manipulate a variety of
drivers through that interface. The importance of virtual destructors is explained in §12.4.2.
With the introduction of abstract classes, we have the basic facilities for writing a complete program in a modular fashion using classes as building blocks.
12.4 Design of Class Hierarchies [derived.design]
Consider a simple design problem: provide a way for a program to get an integer value from a user
interface. This can be done in a bewildering number of ways. To insulate our program from this
variety, and also to get a chance to explore the possible design choices, let us start by defining our
program’s model of this simple input operation. We will leave until later the details of implementing it using a real user-interface system.
The idea is to have a class Ival_boxthat knows what range of input values it will accept. A
program can ask an Ival_boxfor its value and ask it to prompt the user if necessary. In addition, a
program can ask an Ival_boxif a user changed the value since the program last looked at it.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 12.4 Design of Class Hierarchies 315
Because there are many ways of implementing this basic idea, we must assume that there will
be many different kinds of Ival_boxes, such as sliders, plain boxes in which a user can type a number, dials, and voice interaction.
The general approach is to build a ‘‘virtual user-interface system’’ for the application to use.
This system provides some of the services provided by existing user-interface systems. It can be
implemented on a wide variety of systems to ensure the portability of application code. Naturally,
there are other ways of insulating an application from a user-interface system. I chose this
approach because it is general, because it allows me to demonstrate a variety of techniques and
design tradeoffs, because those techniques are also the ones used to build ‘‘real’’ user-interface systems, and – most important – because these techniques are applicable to problems far beyond the
narrow domain of interface systems.
12.4.1 A Traditional Class Hierarchy [derived.traditional]
Our first solution is a traditional class hierarchy as is commonly found in Simula, Smalltalk, and
older C++ programs.
Class Ival_boxdefines the basic interface to all Ival_boxes and specifies a default implementation that more specific kinds of Ival_boxes can override with their own versions. In addition, we
declare the data needed to implement the basic notion:
class Ival_box{
protected:
int val;
int low, high;
bool changed;
public:
Ival_box(int ll, int hh) { changed= false; val= low= ll; high= hh; }
virtual int get_value() { changed= false; return val; }
virtual void set_value(int i) { changed= true; val= i; } / / for user
virtual void reset_value(int i) { changed= false; val= i; } / / for application
virtual void prompt() { }
virtual bool was_changed() const{ return changed; }
};
The default implementation of the functions is pretty sloppy and is provided here primarily to illustrate the intended semantics. A realistic class would, for example, provide some range checking.
A programmer might use these ‘‘ivalclasses’’ like this:
void interact(Ival_box* pb)
{
pb->prompt() ; / / alert user
/ / ...
int i= pb->get_value() ;
if(pb->was_changed()) {
/ / new value; do something
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
316 Derived Classes Chapter 12
else{
/ / old value was fine; do something else
}
/ / ...
}
void some_fct()
{
Ival_box* p1= new Ival_slider(0,5) ; / / Ival_slider derived from Ival_box
interact(p1) ;
Ival_box* p2= new Ival_dial(1,12) ;
interact(p2) ;
}
Most application code is written in terms of (pointers to) plain Ival_boxes the way interact() is.
That way, the application doesn’t have to know about the potentially large number of variants of
the Ival_boxconcept. The knowledge of such specialized classes is isolated in the relatively few
functions that create such objects. This isolates users from changes in the implementations of the
derived classes. Most code can be oblivious to the fact that there are different kinds of Ival_boxes.
To simplify the discussion, I do not address issues of how a program waits for input. Maybe the
program really does wait for the user in get_value(), maybe the program associates the Ival_box
with an event and prepares to respond to a callback, or maybe the program spawns a thread for the
Ival_boxand later inquires about the state of that thread. Such decisions are crucial in the design
of user-interface systems. However, discussing them here in any realistic detail would simply distract from the presentation of programming techniques and language facilities. The design techniques described here and the language facilities that support them are not specific to user interfaces. They apply to a far greater range of problems.
The different kinds of Ival_boxes are defined as classes derived from Ival_box. For example:
class Ival_slider: public Ival_box{
/ / graphics stuff to define what the slider looks like, etc.
public:
Ival_slider(int, int) ;
int get_value() ;
void prompt() ;
};
The data members of Ival_boxwere declared protectedto allow access from derived classes.
Thus, Ival_slider: :get_value() can deposit a value in Ival_box: :val. A protectedmember is
accessible from a class’ own members and from members of derived classes, but not to general
users (see §15.3).
In addition to Ival_slider, we would define other variants of the Ival_boxconcept. These could
include Ival_dial, which lets you select a value by turning a knob; flashing_ival_slider, which
flashes when you ask it to prompt(); and popup_ival_slider, which responds to prompt() by
appearing in some prominent place, thus making it hard for the user to ignore.
From where would we get the graphics stuff? Most user-interface systems provide a class
defining the basic properties of being an entity on the screen. So, if we use the system from ‘‘Big
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 12.4.1 A Traditional Class Hierarchy 317
Bucks Inc.,’’ we would have to make each of our Ival_slider, Ival_dial, etc., classes a kind of
BBwindow. This would most simply be achieved by rewriting our Ival_boxso that it derives from
BBwindow. In that way, all our classes inherit all the properties of a BBwindow. For example,
every Ival_boxcan be placed on the screen, obey the graphical style rules, be resized, be dragged
around, etc., according to the standard set by the BBwindowsystem. Our class hierarchy would
look like this:
class Ival_box: public BBwindow{ /* ... */ }; / / rewritten to use BBwindow
class Ival_slider: public Ival_box{ /* ... */ };
class Ival_dial: public Ival_box{ /* ... */ };
class Flashing_ival_slider: public Ival_slider{ /* ... */ };
class Popup_ival_slider: public Ival_slider{ /* ... */ };
or graphically:
BBwindow
Ival_box
Ival_slider Ival_dial
Popup_ival_sliderFlashing_ival_slider
.
12.4.1.1 Critique [derived.critique]
This design works well in many ways, and for many problems this kind of hierarchy is a good solution. However, there are some awkward details that could lead us to look for alternative designs.
We retrofitted BBwindowas the base of Ival_box. This is not quite right. The use of BBwindowisn’t part of our basic notion of an Ival_box; it is an implementation detail. Deriving Ival_box
from BBwindowelevated an implementation detail to a first-level design decision. That can be
right. For example, using the environment defined by ‘‘Big Bucks Inc.’’ may be a key decision of
how our organization conducts its business. However, what if we also wanted to have implementations of our Ival_boxes for systems from ‘‘Imperial Bananas,’’ ‘‘Liberated Software,’’ and ‘‘Compiler Whizzes?’’ We would have to maintain four distinct versions of our program:
class Ival_box: public BBwindow{ /* ... */ }; / / BB version
class Ival_box: public CWwindow{ /* ... */ }; / / CW version
class Ival_box: public IBwindow{ /* ... */ }; / / IB version
class Ival_box: public LSwindow{ /* ... */ }; / / LS version
Having many versions could result in a version-control nightmare.
Another problem is that every derived class shares the basic data declared in Ival_box. That
data is, of course, an implementation detail that also crept into our Ival_boxinterface. From a
practical point of view, it is also the wrong data in many cases. For example, an Ival_slider
doesn’t need the value stored specifically. It can easily be calculated from the position of the slider
when someone executes get_value(). In general, keeping two related, but different, sets of data is
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
318 Derived Classes Chapter 12
asking for trouble. Sooner or later someone will get them out of sync. Also, experience shows that
novice programmers tend to mess with protected data in ways that are unnecessary and that cause
maintenance problems. Data is better kept private so that writers of derived classes cannot mess
with them. Better still, data should be in the derived classes, where it can be defined to match
requirements exactly and cannot complicate the life of unrelated derived classes. In almost all
cases, a protected interface should contain only functions, types, and constants.
Deriving from BBwindowgives the benefit of making the facilities provided by BBwindow
available to users of Ival_box. Unfortunately, it also means that changes to class BBwindowmay
force users to recompile or even rewrite their code to recover from such changes. In particular, the
way most C++ implementations work implies that a change in the size of a base class requires a
recompilation of all derived classes.
Finally, our program may have to run in a mixed environment in which windows of different
user-interface systems coexist. This could happen either because two systems somehow share a
screen or because our program needs to communicate with users on different systems. Having our
user-interface systems ‘‘wired in’’ as the one and only base of our one and only Ival_boxinterface
just isn’t flexible enough to handle those situations.
12.4.2 Abstract Classes [derived.interface]
So, let’s start again and build a new class hierarchy that solves the problems presented in the critique of the traditional hierarchy:
[1] The user-interface system should be an implementation detail that is hidden from users who
don’t want to know about it.
[2] The Ival_boxclass should contain no data.
[3] No recompilation of code using the Ival_boxfamily of classes should be required after a
change of the user-interface system.
[4] Ival_boxes for different interface systems should be able to coexist in our program.
Several alternative approaches can be taken to achieve this. Here, I present one that maps cleanly
into the C++ language.
First, I specify class Ival_boxas a pure interface:
class Ival_box{
public:
virtual int get_value() = 0;
virtual void set_value(int i) = 0;
virtual void reset_value(int i) = 0;
virtual void prompt() = 0;
virtual bool was_changed() const= 0;
virtual~Ival_box() { }
};
This is much cleaner than the original declaration of Ival_box. The data is gone and so are the simplistic implementations of the member functions. Gone, too, is the constructor, since there is no
data for it to initialize. Instead, I added a virtual destructor to ensure proper cleanup of the data that
will be defined in the derived classes.
The definition of Ival_slidermight look like this:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 12.4.2 Abstract Classes 319
class Ival_slider: public Ival_box, protected BBwindow{
public:
Ival_slider(int,int) ;
~Ival_slider() ;
int get_value() ;
void set_value(int i) ;
/ / ...
protected:
/ / functions overriding BBwindow virtual functions
/ / e.g. BBwindow::draw(), BBwindow::mouse1hit()
private:
/ / data needed for slider
};
The derived class Ival_sliderinherits from an abstract class (Ival_box) that requires it to implement the base class’ pure virtual functions. It also inherits from BBwindowthat provides it with
the means of doing so. Since Ival_boxprovides the interface for the derived class, it is derived
using public. Since BBwindowis only an implementation aid, it is derived using protected
(§15.3.2). This implies that a programmer using Ival_slidercannot directly use facilities defined
by BBwindow. The interface provided by Ival_slideris the one inherited by Ival_box, plus what
Ival_sliderexplicitly declares. I used protectedderivation instead of the more restrictive (and usually safer) privatederivation to make BBwindowavailable to classes derived from Ival_slider.
Deriving directly from more than one class is usually called multiple inheritance (§15.2). Note
that Ival_slidermust override functions from both Ival_boxand BBwindow. Therefore, it must be
derived directly or indirectly from both. As shown in §12.4.1.1, deriving Ival_sliderindirectly
from BBwindowby making BBwindowa base of Ival_boxis possible, but doing so has undesirable
side effects. Similarly, making the ‘‘implementation class’’ BBwindowa member of Ival_boxis
not a solution because a class cannot override virtual functions of its members (§24.3.4). Representing the window by a BBwindow* member in Ival_boxleads to a completely different design
with a separate set of tradeoffs (§12.7[14], §25.7).
Interestingly, this declaration of Ival_sliderallows application code to be written exactly as
before. All we have done is to restructure the implementation details in a more logical way.
Many classes require some form of cleanup for an object before it goes away. Since the abstract
class Ival_boxcannot know if a derived class requires such cleanup, it must assume that it does
require some. We ensure proper cleanup by defining a virtual destructor Ival_box: :~Ival_box()
in the base and overriding it suitably in derived classes. For example:
void f(Ival_box* p)
{
/ / ...
delete p;
}
The deleteoperator explicitly destroys the object pointed to by p. We have no way of knowing
exactly to which class the object pointed to by pbelongs, but thanks to Ival_box’s virtual
destructor, proper cleanup as (optionally) defined by that class’ destructor will be called.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
320 Derived Classes Chapter 12
The Ival_boxhierarchy can now be defined like this:
class Ival_box{ /* ... */ };
class Ival_slider: public Ival_box, protected BBwindow{ /* ... */ };
class Ival_dial: public Ival_box, protected BBwindow{ /* ... */ };
class Flashing_ival_slider: public Ival_slider{ /* ... */ };
class Popup_ival_slider: public Ival_slider{ /* ... */ };
or graphically using obvious abbreviations:
BBwindow B Ival_boxBBwindow
Ival_slider Ival_dial
Popup_sliderFlashing_slider
. .
I used a dashed line to represent protected inheritance. As far as general users are concerned, doing
that is simply an implementation detail.
12.4.3 Alternative Implementations [derived.alt]
This design is cleaner and more easily maintainable than the traditional one – and no less efficient.
However, it still fails to solve the version control problem:
class Ival_box{ /* ... */ }; / / common
class Ival_slider: public Ival_box, protected BBwindow{ /* ... */ }; / / for BB
class Ival_slider: public Ival_box, protected CWwindow{ /* ... */ }; / / for CW
/ / ...
In addition, there is no way of having an Ival_sliderfor BBwindows coexist with an Ival_slider
for CWwindows, even if the two user-interface systems could themselves coexist.
The obvious solution is to define several different Ival_sliderclasses with separate names:
class Ival_box{ /* ... */ };
class BB_ival_slider: public Ival_box, protected BBwindow{ /* ... */ };
class CW_ival_slider: public Ival_box, protected CWwindow{ /* ... */ };
/ / ...
or graphically:
BBwindow C Ival_box CWwindow
BB_ival_slider CW_ival_slider. .
To further insulate our application-oriented Ival_boxclasses from implementation details, we can
derive an abstract Ival_sliderclass from Ival_boxand then derive the system-specific Ival_sliders
from that:
class Ival_box{ /* ... */ };
class Ival_slider: public Ival_box{ /* ... */ };
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 12.4.3 Alternative Implementations 321
class BB_ival_slider: public Ival_slider, protected BBwindow{ /* ... */ };
class CW_ival_slider: public Ival_slider, protected CWwindow{ /* ... */ };
/ / ...
or graphically:
Ival_box
BBwindow C Ival_sliderCWwindow
BB_ival_slider CW_ival_slider
.
Usually, we can do better yet by utilizing more-specific classes in the implementation hierarchy.
For example, if the ‘‘Big Bucks Inc.’’ system has a slider class, we can derive our Ival_slider
directly from the BBslider:
class BB_ival_slider: public Ival_slider, protected BBslider{ /* ... */ };
class CW_ival_slider: public Ival_slider, protected CWslider{ /* ... */ };
or graphically:
Ival_box
BBslider C Ival_sliderCWslider
BB_ival_slider CW_ival_slider
. BBwindow CWwindow.
This improvement becomes significant where – as is not uncommon – our abstractions are not too
different from the ones provided by the system used for implementation. In that case, programming is reduced to mapping between similar concepts. Derivation from general base classes, such
as BBwindow, is then done only rarely.
The complete hierarchy will consist of our original application-oriented conceptual hierarchy of
interfaces expressed as derived classes:
class Ival_box{ /* ... */ };
class Ival_slider: public Ival_box{ /* ... */ };
class Ival_dial: public Ival_box{ /* ... */ };
class Flashing_ival_slider: public Ival_slider{ /* ... */ };
class Popup_ival_slider: public Ival_slider{ /* ... */ };
followed by the implementations of this hierarchy for various graphical user-interface systems,
expressed as derived classes:
class BB_ival_slider: public Ival_slider, protected BBslider{ /* ... */ };
class BB_flashing_ival_slider: public Flashing_ival_slider,
protected BBwindow_with_bells_and_whistles{ /* ... */ };
class BB_popup_ival_slider: public Popup_ival_slider, protected BBslider{ /* ... */ };
class CW_ival_slider: public Ival_slider, protected CWslider{ /* ... */ };
/ / ...
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
322 Derived Classes Chapter 12
Using obvious abbreviations, this hierarchy can be represented graphically like this:
Ival_box
Ival_slider Ival_dial
ipopupiflash
CWslCWsl CWsl
BBislider C BBipop B CWipop CWifl BBiflCWislider
BBslider BBslider BBb&w
.
The original Ival_boxclass hierarchy appears unchanged surrounded by implementation classes.
12.4.3.1 Critique [derived.critique2]
The abstract class design is flexible and almost as simple to deal with as the equivalent design that
relies on a common base defining the user-interface system. In the latter design, the windows class
is the root of a tree. In the former, the original application class hierarchy appears unchanged as the
root of classes that supply its implementations. From the application’s point of view, these designs
are equivalent in the strong sense that almost all code works unchanged and in the same way in the
two cases. In either case, you can look at the Ival_boxfamily of classes without bothering with the
window-related implementation details most of the time. For example, we would not need to
rewrite interact() from §12.4.1 if we switched from the one class hierarchy to the other.
In either case, the implementation of each Ival_boxclass must be rewritten when the public
interface of the user-interface system changes. However, in the abstract class design, almost all
user code is protected against changes to the implementation hierarchy and requires no recompilation after such a change. This is especially important when the supplier of the implementation hierarchy issues a new ‘‘almost compatible’’ release. In addition, users of the abstract class hierarchy
are in less danger of being locked into a proprietary implementation than are users of a classical
hierarchy. Users of the Ival_boxabstract class application hierarchy cannot accidentally use facilities from the implementation because only facilities explicitly specified in the Ival_boxhierarchy
are accessible; nothing is implicitly inherited from an implementation-specific base class.
12.4.4 Localizing Object Creation [derived.local]
Most of an application can be written using the Ival_boxinterface. Further, should the derived
interfaces evolve to provide more facilities than plain Ival_box, then most of an application can be
written using the Ival_box, Ival_slider, etc., interfaces. However, the creation of objects must be
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 12.4.4 Localizing Object Creation 323
done using implementation-specific names such as CW_ival_dialand BB_flashing_ival_slider.
We would like to minimize the number of places where such specific names occur, and object creation is hard to localize unless it is done systematically.
As usual, the solution is to introduce an indirection. This can be done in many ways. A simple
one is to introduce an abstract class to represent the set of creation operations:
class Ival_maker{
public:
virtual Ival_dial* dial(int, int) =0; / / make dial
virtual Popup_ival_slider* popup_slider(int, int) =0; / / make popup slider
/ / ...
};
For each interface from the Ival_boxfamily of classes that a user should know about, class
Ival_makerprovides a function that makes an object. Such a class is sometimes called a factory,
and its functions are (somewhat misleadingly) sometimes called virtual constructors (§15.6.2).
We now represent each user-interface system by a class derived from Ival_maker:
class BB_maker: public Ival_maker{ / / make BB versions
public:
Ival_dial* dial(int, int) ;
Popup_ival_slider* popup_slider(int, int) ;
/ / ...
};
class LS_maker: public Ival_maker{ / / make LS versions
public:
Ival_dial* dial(int, int) ;
Popup_ival_slider* popup_slider(int, int) ;
/ / ...
};
Each function creates an object of the desired interface and implementation type. For example:
Ival_dial* BB_maker: :dial(int a, int b)
{
return new BB_ival_dial(a,b) ;
}
Ival_dial* LS_maker: :dial(int a, int b)
{
return new LS_ival_dial(a,b) ;
}
Given a pointer to a Ival_maker, a user can now create objects without having to know exactly
which user-interface system is used. For example:
void user(Ival_maker* pim)
{
Ival_box* pb= pim->dial(0,99) ; / / create appropriate dial
/ / ...
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
324 Derived Classes Chapter 12
BB_maker BB_impl; / / for BB users
LS_maker LS_impl; / / for LS users
void driver()
{
user(&BB_impl) ; / / use BB
user(&LS_impl) ; / / use LS
}
12.5 Class Hierarchies and Abstract Classes [derived.hier]
An abstract class is an interface. A class hierarchy is a means of building classes incrementally.
Naturally, every class provides an interface to users and some abstract classes provide significant
functionality to build from, but ‘‘interface’’ and ‘‘building block’’ are the primary roles of abstract
classes and class hierarchies.
A classical hierarchy is a hierarchy in which the individual classes both provide useful functionality for users and act as building blocks for the implementation of more advanced or specialized
classes. Such hierarchies are ideal for supporting programming by incremental refinement. They
provide the maximum support for the implementation of new classes as long as the new class
relates strongly to the existing hierarchy.
Classical hierarchies do tend to couple implementation concerns rather strongly with the interfaces provided to users. Abstract classes can help here. Hierarchies of abstract classes provide a
clean and powerful way of expressing concepts without encumbering them with implementation
concerns or significant run-time overheads. After all, a virtual function call is cheap and independent of the kind of abstraction barrier it crosses. It costs no more to call a member of an abstract
class than to call any other virtualfunction.
The logical conclusion of this line of thought is a system represented to users as a hierarchy of
abstract classes and implemented by a classical hierarchy.
12.6 Advice [derived.advice]
[1] Avoid type fields; §12.2.5.
[2] Use pointers and references to avoid slicing; §12.2.3.
[3] Use abstract classes to focus design on the provision of clean interfaces; §12.3.
[4] Use abstract classes to minimize interfaces; §12.4.2.
[5] Use abstract classes to keep implementation details out of interfaces; §12.4.2.
[6] Use virtual functions to allow new implementations to be added without affecting user code;
§12.4.1.
[7] Use abstract classes to minimize recompilation of user code; §12.4.2.
[8] Use abstract classes to allow alternative implementations to coexist; §12.4.3.
[9] A class with a virtual function should have a virtual destructor; §12.4.2.
[10] An abstract class typically doesn’t need a constructor; §12.4.2.
[11] Keep the representations of distinct concepts distinct; §12.4.1.1.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 12.7 Exercises 325
12.7 Exercises [derived.exercises]
1. (∗1) Define
class base{
public:
virtual void iam() { cout<< "base\n"; }
};
Derive two classes from base, and for each define iam() to write out the name of the class.
Create objects of these classes and call iam() for them. Assign pointers to objects of the
derived classes to base* pointers and call iam() through those pointers.
2. (∗3.5) Implement a simple graphics system using whatever graphics facilities are available on
your system (if you don’t have a good graphics system or have no experience with one, you
might consider a simple ‘‘huge bit ASCII implementation’’ where a point is a character position
and you write by placing a suitable character, such as * in a position): Window(n,m) creates
an area of size ntimes mon the screen. Points on the screen are addressed using (x,y) coordinates (Cartesian). A Window whas a current position w.current(). Initially, currentis
Point(0,0). The current position can be set by w.current(p) where pis a Point. A Pointis
specified by a coordinate pair: Point(x,y). A Lineis specified by a pair of Points:
Line(w.current() ,p2) ; class Shapeis the common interface to Dots, Lines, Rectangles,
Circles, etc. A Pointis not a Shape. A Dot, Dot(p) can be used to represent a Point pon the
screen. A Shapeis invisible unless draw()n. For example:
w.draw(Circle(w.current() ,10)). Every Shapehas 9 contact points: e(east), w(west), n
(north), s(south), ne, nw, se, sw, and c(center). For example, Line(x.c() ,y.nw()) creates
a line from x’s center to y’s top left corner. After draw()ing a Shapethe current position is the
Shape’s se(). A Rectangleis specified by its bottom left and top right corner:
Rectangle(w.current() ,Point(10,10)). As a simple test, display a simple ‘‘child’s drawing of a house’’ with a roof, two windows, and a door.
3. (∗2) Important aspects of a Shapeappear on the screen as a set of line segments. Implement
operations to vary the appearance of these segments: s.thickness(n) sets the line thickness to
0, 1, 2, or 3, where 2is the default and 0means invisible. In addition, a line segment can be
solid, dashed, or dotted. This is set by the function Shape: :outline().
4. (∗2.5) Provide a function Line: :arrowhead() that adds arrow heads to an end of a line. A
line has two ends and an arrowhead can point in two directions relative to the line, so the argument or arguments to arrowhead() must be able to express at least four alternatives.
5. (∗3.5) Make sure that points and line segments that fall outside the Windowdo not appear on
the screen. This is often called ‘‘clipping.’’ As an exercise only, do not rely on the implementation graphics system for this.
6. (∗2.5) Add a Texttype to the graphics system. A Textis a rectangular Shapedisplaying characters. By default, a character takes up one coordinate unit along each coordinate axis.
7. (∗2) Define a function that draws a line connecting two shapes by finding the two closest ‘‘contact points’’ and connecting them.
8. (∗3) Add a notion of color to the simple graphics system. Three things can be colored: the
background, the inside of a closed shape, and the outlines of shapes.
9. (∗2) Consider:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
326 Derived Classes Chapter 12
class Char_vec{
int sz;
char element[1] ;
public:
static Char_vec* new_char_vec(int s) ;
char& operator[](int i) { return element[i] ; }
/ / ...
};
Define new_char_vec() to allocate contiguous memory for a Char_vecobject so that the elements can be indexed through elementas shown. Under what circumstances does this trick
cause serious problems?
10. (∗2.5) Given classes Circle, Square, and Trianglederived from a class Shape, define a function intersect() that takes two Shape* arguments and calls suitable functions to determine if
the two shapes overlap. It will be necessary to add suitable (virtual) functions to the classes to
achieve this. Don’t bother to write the code that checks for overlap; just make sure the right
functions are called. This is commonly referred to as double dispatchor a multi-method.
11. (∗5) Design and implement a library for writing event-driven simulations. Hint: <task.h>.
However, that is an old program, and you can do better. There should be a class task. An
object of class taskshould be able to save its state and to have that state restored (you might
define task: :save() and task: :restore()) so that it can operate as a coroutine. Specific tasks
can be defined as objects of classes derived from class task. The program to be executed by a
task might be specified as a virtual function. It should be possible to pass arguments to a new
task as arguments to its constructor(s). There should be a scheduler implementing a concept of
virtual time. Provide a function task: :delay(long) that ‘‘consumes’’ virtual time. Whether
the scheduler is part of class taskor separate will be one of the major design decisions. The
tasks will need to communicate. Design a class queuefor that. Devise a way for a task to wait
for input from several queues. Handle run-time errors in a uniform way. How would you
debug programs written using such a library?
12. (∗2) Define interfaces for Warrior, Monster, and Object(that is a thing you can pick up, drop,
use, etc.) classes for an adventure-style game.
13. (∗1.5) Why is there both a Pointand a Dotclass in §12.7[2]? Under which circumstances
would it be a good idea to augment the Shapeclasses with concrete versions of key classes such
as Line.
14. (∗3) Outline a different implementation strategy for the Ival_boxexample (§12.4) based on the
idea that every class seen by an application is an interface containing a single pointer to the
implementation. Thus, each "interface class" will be a handle to an "implementation class," and
there will be an interface hierarchy and an implementation hierarchy. Write code fragments that
are detailed enough to illustrate possible problems with type conversion. Consider ease of use,
ease of programming, ease of reusing implementations and interfaces when adding a new concept to the hierarchy, ease of making changes to interfaces and implementations, and need for
recompilation after change in the implementation.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
13 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
Templates
Your quote here.
– B. Stroustrup
Templates — a string template — instantiation — template parameters — type checking
— function templates — template argument deduction — specifying template arguments
— function template overloading — policy as template arguments — default template
arguments — specialization — derivation and templates — member templates — conversions — source code organization — advice — exercises.
13.1 Introduction [temp.intro]
Independent concepts should be independently represented and should be combined only when
needed. Where this principle is violated, you either bundle unrelated concepts together or create
unnecessary dependencies. Either way, you get a less flexible set of components out of which to
compose systems. Templates provide a simple way to represent a wide range of general concepts
and simple ways to combine them. The resulting classes and functions can match hand-written,
more-specialized code in run-time and space efficiency.
Templates provide direct support for generic programming (§2.7), that is, programming using
types as parameters. The C++ template mechanism allows a type to be a parameter in the definition
of a class or a function. A template depends only on the properties that it actually uses from its
parameter types and does not require different types used as arguments to be explicitly related. In
particular, the argument types used for a template need not be from a single inheritance hierarchy.
Here, templates are introduced with the primary focus on techniques needed for the design,
implementation, and use of the standard library. The standard library requires a greater degree of
generality, flexibility, and efficiency than does most software. Consequently, techniques that can
be used in the design and implementation of the standard library are effective and efficient in the
design of solutions to a wide variety of problems. These techniques enable an implementer to hide
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
328 Templates Chapter 13
sophisticated implementations behind simple interfaces and to expose complexity to the user only
when the user has a specific need for it. For example, sort(v) can be the interface to a variety of
sort algorithms for elements of a variety of types held in a variety of containers. The sort function
that is most appropriate for the particular vwill be automatically chosen.
Every major standard library abstraction is represented as a template (for example, string,
ostream, complex, list, and map) and so are the key operations (for example, stringcompare, the
output operator <<, complexaddition, getting the next element from a list, and sort()). This
makes the library chapters (Part 3) of this book a rich source of examples of templates and programming techniques relying on them. Consequently, this chapter concentrates on smaller examples illustrating technical aspects of templates and fundamental techniques for using them:
§13.2: The basic mechanisms for defining and using class templates
§13.3: Function templates, function overloading, and type deduction
§13.4: Template parameters used to specify policies for generic algorithms
§13.5: Multiple definitions providing alternative implementations for a template
§13.6: Derivation and templates (run-time and compile-time polymorphism)
§13.7: Source code organization
Templates were introduced in §2.7.1 and §3.8. Detailed rules for template name resolution, template syntax, etc., can be found in §C.13.
13.2 A Simple String Template [temp.string]
Consider a string of characters. A string is a class that holds characters and provides operations
such as subscripting, concatenation, and comparison that we usually associate with the notion of a
‘‘string.’’ We would like to provide that behavior for many different kinds of characters. For
example, strings of signed characters, of unsigned characters, of Chinese characters, of Greek characters, etc., are useful in various contexts. Thus, we want to represent the notion of ‘‘string’’ with
minimal dependence on a specific kind of character. The definition of a string relies on the fact that
a character can be copied, and little else. Thus, we can make a more general string type by taking
the string of charfrom §11.12 and making the character type a parameter:
template<class C> class String{
struct Srep;
Srep*rep;
public:
String() ;
String(const C*) ;
String(const String&) ;
C read(int i) const;
/ / ...
};
The template<class C> prefix specifies that a template is being declared and that a type argument
Cwill be used in the declaration. After its introduction, Cis used exactly like other type names.
The scope of Cextends to the end of the declaration prefixed by template<class C>. Note that
template<class C> says that Cis a type name; it need not be the name of a class.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 13.2 A Simple String Template 329
The name of a class template followed by a type bracketed by < > is the name of a class (as
defined by the template) and can be used exactly like other class names. For example:
String<char> cs;
String<unsigned char> us;
String<wchar_t> ws;
class Jchar{
/ / Japanese character
};
String<Jchar> js;
Except for the special syntax of its name, String<char> works exactly as if it had been defined
using the definition of class Stringin §11.12. Making Stringa template allows us to provide the
facilities we had for Stringof charfor Strings of any kind of character. For example, if we use the
standard library mapand the Stringtemplate, the word-counting example from §11.8 becomes:
int main() / / count the occurrences of each word on input
{
String<char> buf;
map<String<char>,int> m;
while(cin>>buf) m[buf]++;
/ / write out result
}
The version for our Japanese-character type Jcharwould be:
int main() / / count the occurrences of each word on input
{
String<Jchar> buf;
map<String<Jchar>,int> m;
while(cin>>buf) m[buf]++;
/ / write out result
}
The standard library provides the template class basic_stringthat is similar to the templatized
String(§11.12, §20.3). In the standard library, stringis defined as a synonym for
basic_string<char>:
typedef basic_string<char> string;
This allows us to write the word-counting program like this:
int main() / / count the occurrences of each word on input
{
string buf;
map<string,int> m;
while(cin>>buf) m[buf]++;
/ / write out result
}
In general, typedefs are useful for shortening the long names of classes generated from templates.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
330 Templates Chapter 13
Also, we often prefer not to know the details of how a type is defined, and a typedefallows us to
hide the fact that a type is generated from a template.
13.2.1 Defining a Template [temp.string.details]
A class generated from a class template is a perfectly ordinary class. Thus, use of a template does
not imply any run-time mechanisms beyond what is used for an equivalent ‘‘hand-written’’ class.
Nor does it necessarily imply any reduction in the amount of code generated.
It is usually a good idea to debug a particular class, such as String, before turning it into a template such as String<C>. By doing so, we handle many design problems and most of the code
errors in the context of a concrete example. This kind of debugging is familiar to all programmers,
and most people cope better with a concrete example than with an abstract concept. Later, we can
deal with any problems that might arise from generalization without being distracted by more conventional errors. Similarly, when trying to understand a template, it is often useful to imagine its
behavior for a particular type argument such as charbefore trying to comprehend the template in
its full generality.
Members of a template class are declared and defined exactly as they would have been for a
non-template class. A template member need not be defined within the template class itself. In
that case, its definition must be provided somewhere else, as for non-template class members
(§C.13.7). Members of a template class are themselves templates parameterized by the parameters
of their template class. When such a member is defined outside its class, it must explicitly be
declared a template. For example:
template<class C> struct String<C>: :Srep{
C* s; / / pointer to elements
int sz; / / number of elements
int n; / / reference count
/ / ...
};
template<class C> C String<C>: :read(int i) const{ return rep->s[i] ; }
template<class C> String<C>: :String()
{
p= new Srep(0,C()) ;
}
Template parameters, such as C, are parameters rather than names of types defined externally to the
template. However, that doesn’t affect the way we write the template code using them. Within the
scope of String<C>, qualification with <C> is redundant for the name of the template itself, so
String<C>: :Stringis the name for the constructor. If you prefer, you can be explicit:
template<class C> String<C>: :String<C>()
{
p= new Srep(0,C()) ;
}
Just as there can be only one function defining a class member function in a program, there can be
only one function template defining a class template member function in a program. However,
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 13.2.1 Defining a Template 331
overloading is a possibility for functions only (§13.3.2), while specialization (§13.5) enables us to
provide alternative implementations for a template.
It is not possible to overload a class template name, so if a class template is declared in a scope,
no other entity can be declared there with the same name (see also §13.5). For example:
template<class T> class String{ /* ... */ };
class String{ /* ... */ }; / / error: double definition
A type used as a template argument must provide the interface expected by the template. For
example, a type used as an argument to Stringmust provide the usual copy operations (§10.4.4.1,
§20.2.1). Note that there is no requirement that different arguments for the same template parameter should be related by inheritance.
13.2.2 Template Instantiation [temp.string.inst]
The process of generating a class declaration from a template class and a template argument is often
called template instantiation (§C.13.7). Similarly, a function is generated (‘‘instantiated’’) from a
template function plus a template argument. A version of a template for a particular template argument is called a specialization.
In general, it is the implementation’s job – not the programmer’s – to ensure that versions of a
template function are generated for each set of template arguments used (§C.13.7). For example:
String<char> cs;
void f()
{
String<Jchar> js;
cs= "It´s the implementation´s job to figure out what code needs to be generated";
}
For this, the implementation generates declarations for String<char> and String<Jchar>, for their
corresponding Sreptypes, for their destructors and default constructors, and for the assignment
String<char>: :operator=(char*). Other member functions are not used and should not be generated. The generated classes are perfectly ordinary classes that obey all the usual rules for classes.
Similarly, generated functions are ordinary functions that obey all the usual rules for functions.
Obviously, templates provide a powerful way of generating code from relatively short definitions. Consequently, a certain amount of caution is in order to avoid flooding memory with almost
identical function definitions (§13.5).
13.2.3 Template Parameters [temp.param]
A template can take type parameters, parameters of ordinary types such as ints, and template
parameters (§C.13.3). Naturally, a template can take several parameters. For example:
template<class T, T def_val> class Cont{ /* ... */ };
As shown, a template parameter can be used in the definition of subsequent template parameters.
Integer arguments come in handy for supplying sizes and limits. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
332 Templates Chapter 13
template<class T, int i> class Buffer{
T v[i] ;
int sz;
public:
Buffer() : sz(i) {}
/ / ...
};
Buffer<char,127> cbuf;
Buffer<Record,8> rbuf;
Simple and constrained containers such as Buffercan be important where run-time efficiency and
compactness are paramount (thus preventing the use of a more general stringor vector). Passing a
size as a template argument allows Buffer’s implementer to avoid free store use. Another example
is the Rangetype in §25.6.1.
A template argument can be a constant expression (§C.5), the address of an object or function
with external linkage (§9.2), or a non-overloaded pointer to member (§15.5). A pointer used as a
template argument must be of the form &of, where ofis the name of an object or a function, or of
the form f, where fis the name of a function. A pointer to member must be of the form &X: :of,
where ofis the name of an member. In particular, a string literal is not acceptable as a template
argument.
An integer template argument must be a constant:
void f(int i)
{
Buffer<int,i> bx; / / error: constant expression expected
}
Conversely, a non-type template parameter is a constant within the template so that an attempt to
change the value of a parameter is an error.
13.2.4 Type Equivalence [temp.equiv]
Given a template, we can generate types by supplying template arguments. For example:
String<char> s1;
String<unsigned char> s2;
String<int> s3;
typedef unsigned char Uchar;
String<Uchar> s4;
String<char> s5;
Buffer<String<char>,10> b1;
Buffer<char,10> b2;
Buffer<char,20-10> b3;
When using the same set of template arguments for a template, we always refer to the same generated type. However, what does ‘‘the same’’ mean in this context? As usual, typedefs do not introduce new types, so String<Uchar> is the same type as String<unsigned char>. Conversely,
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 13.2.4 Type Equivalence 333
because charand unsigned charare different types (§4.3), String<char> and String<unsigned
char> are different types.
The compiler can evaluate constant expressions (§C.5), so Buffer<char,20-10> is recognized
to be the same type as Buffer<char,10>.
13.2.5 Type Checking [temp.check]
A template is defined and then later used in combination with a set of template arguments. When
the template is defined, the definition is checked for syntax errors and possibly also for other errors
that can be detected in isolation from a particular set of template arguments. For example:
template<class T> class List{
struct Link{
Link* pre;
Link* suc;
T val;
Link(Link* p, Link* s,const T& v) :pre(p) , suc(s) , val(v) { }
} / / syntax error: missing semicolon
Link* head;
public:
List() : head(7) { } / / error: pointer initialized with int
List(const T& t) : head(new Link(0,o,t)) { } / / error: undefined identifier ‘o’
/ / ...
void print_all() { for(Link* p= head; p; p=p->suc) cout<< p->val<< ´\n´; }
};
A compiler can catch simple semantic errors at the point of definition or later at the point of use.
Users generally prefer early detection, but not all ‘‘simple’’ errors are easy to detect. Here, I made
three ‘‘mistakes.’’ Independently of what the template parameter is, a pointer T* cannot be initialized by the integer 7. Similarly, the identifier o(a mistyped 0, of course) cannot be an argument to
List<T>: :Link’s constructor because there is no such name in scope.
A name used in a template definition must either be in scope or in some reasonably obvious
way depend on a template parameter (§C.13.8.1). The most common and obvious way of depending on a template parameter Tis to use a member of a Tor to take an argument of type T. In
List<T>: :print_all(), cout<<p->valis a slightly more subtle example.
Errors that relate to the use of template parameters cannot be detected until the template is used.
For example:
class Rec{ /* ... */ };
void f(List<int>& li, List<Rec>& lr)
{
li.print_all() ;
lr.print_all() ;
}
The li.print_all() checks out fine, but lr.print_all() gives a type error because there is no <<
output operator defined for Rec. The earliest that errors relating to a template parameter can be
detected is at the first point of use of the template for a particular template argument. That point is
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
334 Templates Chapter 13
usually called the first point of instantiation, or simply the point of instantiation (see §C.13.7). The
implementation is allowed to postpone this checking until the program is linked. If we had only a
declaration of print_all() available in this translation unit, rather than its definition, the implementation might have had to delay type checking (see §13.7). Independently of when checking is done,
the same set of rules is checked. Again, users prefer early checking. It is possible to express constraints on template arguments in terms of member functions (see §13.9[16]).
13.3 Function Templates [temp.fct]
For most people, the first and most obvious use of templates is to define and use container classes
such as basic_string(§20.3), vector(§16.3), list(§17.2.2), and map(§17.4.1). Soon after, the
need for template functions arises. Sorting an array is a simple example:
template<class T> void sort(vector<T>&) ; / / declaration
void f(vector<int>& vi, vector<string>& vs)
{
sort(vi) ; / / sort(vector<int>&);
sort(vs) ; / / sort(vector<string>&);
}
When a template function is called, the types of the function arguments determine which version of
the template is used; that is, the template arguments are deduced from the function arguments
(§13.3.1).
Naturally, the template function must be defined somewhere (§C.13.7):
template<class T> void sort(vector<T>& v) / / definition
/ / Shell sort (Knuth, Vol. 3, pg. 84).
{
const size_t n= v.size() ;
for(int gap=n/2; 0<gap; gap/=2)
for(int i=gap; i<n; i++)
for(int j=i-gap; 0<=j; j-=gap)
if(v[j+gap]<v[j]) { / / swap v[j] and v[j+gap]
T temp= v[j] ;
v[j] = v[j+gap] ;
v[j+gap] = temp;
}
}
Please compare this definition to the sort() defined in (§7.7). This templatized version is cleaner
and shorter because it can rely on more information about the type of the elements it sorts. Most
likely, it is also faster because it doesn’t rely on a pointer to function for the comparison. This
implies that no indirect function calls are needed and that inlining of a simple < is easy.
A further simplification is to use the standard library template swap() (§18.6.8) to reduce the
action to its natural form:
if(v[j+gap]<v[j]) swap(v[j] ,v[j+gap]) ;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 13.3 Function Templates 335
This does not introduce any new overheads.
In this example, operator < is used for comparison. However, not every type has a < operator.
This limits the use of this version of sort(), but the limitation is easily avoided (see §13.4).
13.3.1 Function Template Arguments [temp.deduce]
Function templates are essential for writing generic algorithms to be applied to a wide variety of
container types (§2.7.2, §3.8, Chapter 18). The ability to deduce the template arguments for a call
from the function arguments is crucial.
A compiler can deduce type and non-type arguments from a call, provided the function argument list uniquely identifies the set of template arguments (§C.13.4). For example:
template<class T, int i> T lookup(Buffer<T,i>& b, const char* p) ;
class Record{
const char[12] ;
/ / ...
};
Record f(Buffer<Record,128>& buf, const char* p)
{
return lookup(buf,p) ; / / use the lookup() where T is Record and i is 128
}
Here, Tis deduced to be Recordand iis deduced to be 128.
Note that class template parameters are never deduced. The reason is that the flexibility provided by several constructors for a class would make such deduction impossible in many cases and
obscure in many more. Specialization provides a mechanism for implicitly choosing between different implementations of a class (§13.5). If we need to create an object of a deduced type, we can
often do that by calling a function to do the creation; see make_pair() in §17.4.1.2.
If a template argument cannot be deduced from the template function arguments (§C.13.4), we
must specify it explicitly. This is done in the same way template arguments are explicitly specified
for a template class. For example:
template<class T> class vector{ /* ... */ };
template<class T> T* create() ; / / make a T and return a pointer to it
void f()
{
vector<int> v; / / class, template argument ‘int’
int* p= create<int>() ; / / function, template argument ‘int’
}
One common use of explicit specification is to provide a return type for a template function:
template<class T, class U> T implicit_cast(U u) { return u; }
void g(int i)
{
implicit_cast(i) ; / / error: can’t deduce T
implicit_cast<double>(i) ; / / T is double; U is int
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
336 Templates Chapter 13
implicit_cast<char,double>(i) ; / / T is char; U is double
implicit_cast<char*,int>(i) ; / / T is char*; U is int; error: cannot convert int to char*
}
As with default function arguments (§7.5), only trailing arguments can be left out of a list of
explicit template arguments.
Explicit specification of template arguments allows the definition of families of conversion
functions and object creation functions (§13.3.2, §C.13.1, §C.13.5). An explicit version of the
implicit conversions (§C.6), such as implicit_cast(), is frequently useful. The syntax for
dynamic_cast, static_cast, etc., (§6.2.7, §15.4.1) matches the explicitly qualified template function
syntax. However, the built-in type conversion operators supply operations that cannot be expressed
by other language features.
13.3.2 Function Template Overloading [temp.over]
One can declare several function templates with the same name and even declare a combination of
function templates and ordinary functions with the same name. When an overloaded function is
called, overload resolution is necessary to find the right function or template function to invoke.
For example:
template<class T> T sqrt(T) ;
template<class T> complex<T> sqrt(complex<T>) ;
double sqrt(double) ;
void f(complex<double> z)
{
sqrt(2) ; / / sqrt<int>(int)
sqrt(2.0) ; / / sqrt(double)
sqrt(z) ; / / sqrt<double>(complex<double>)
}
In the same way that a template function is a generalization of the notion of a function, the rules for
resolution in the presence of function templates are generalizations of the function overload resolution rules. Basically, for each template we find the specialization that is best for the set of function
arguments. Then, we apply the usual function overload resolution rules to these specializations and
all ordinary functions:
[1] Find the set of function template specializations (§13.2.2) that will take part in overload resolution. Do this by considering each function template and deciding which template arguments, if any, would be used if no other function templates or functions of the same name
were in scope. For the call sqrt(z), this makes sqrt<double>(complex<double>) and
sqrt< complex<double> >(complex<double>) candidates.
[2] If two template functions can be called and one is more specialized than the other (§13.5.1),
consider only the most specialized template function in the following steps. For the call
sqrt(z), this means that sqrt<double>(complex<double>) is preferred over sqrt<
complex<double> >(complex<double>): any call that matches sqrt<T>(complex<T>)
also matches sqrt<T>(T).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 13.3.2 Function Template Overloading 337
[3] Do overload resolution for this set of functions, plus any ordinary functions as for ordinary
functions (§7.4). If a template function argument has been determined by template argument deduction (§13.3.1), that argument cannot also have promotions, standard conversions,
or user-defined conversions applied. For sqrt(2) , sqrt<int>(int) is an exact match, so it
is preferred over sqrt(double).
[4] If a function and a specialization are equally good matches, the function is preferred. Consequently, sqrt(double) is preferred over sqrt<double>(double) for sqrt(2.0).
[5] If no match is found, the call is an error. If we end up with two or more equally good
matches, the call is ambiguous and is an error.
For example:
template<class T> T max(T,T) ;
const int s= 7;
void k()
{
max(1,2) ; / / max<int>(1,2)
max(´a´,´b´) ; / / max<char>(’a’,’b’)
max(2.7,4.9) ; / / max<double>(2.7,4.9)
max(s,7) ; / / max<int>(int(s),7) (trivial conversion used)
max(´a´,1) ; / / error: ambiguous (no standard conversion)
max(2.7,4) ; / / error: ambiguous (no standard conversion)
}
We could resolve the two ambiguities either by explicit qualification:
void f()
{
max<int>(´a´,1) ; / / max<int>(int(’a’),1)
max<double>(2.7,4) ; / / max<double>(2.7,double(4))
}
or by adding suitable declarations:
inline int max(int i, int j) { return max<int>(i,j) ; }
inline double max(int i, double d) { return max<double>(i,d) ; }
inline double max(double d, int i) { return max<double>(d,i) ; }
inline double max(double d1, double d2) { return max<double>(d1,d2) ; }
void g()
{
max(´a´,1) ; / / max(int(’a’),1)
max(2.7,4) ; / / max(2.7,double(4))
}
For ordinary functions, ordinary overloading rules (§7.4) apply, and the use of inlineensures that
no extra overhead is imposed.
The definition of max() is trivial, so we could have written it explicitly. However, using a specialization of the template is an easy and general way of defining such resolution functions.
The overload resolution rules ensure that template functions interact properly with inheritance:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
338 Templates Chapter 13
template<class T> class B{ /* ... */ };
template<class T> class D: public B<T> { /* ... */ };
template<class T> void f(B<T>*) ;
void g(B<int>* pb, D<int>* pd)
{
f(pb) ; / / f<int>(pb)
f(pd) ; / / f<int>(static_cast<B<int>*>(pd)); standard conversion D<int>* to B<int>* used
}
In this example, the template function f() accepts a B<T>* for any type T. We have an argument
of type D<int>*, so the compiler easily deduces that by choosing Tto be int, the call can be
uniquely resolved to a call of f(B<int>*).
A function argument that is not involved in the deduction of a template parameter is treated
exactly as an argument of a non-template function. In particular, the usual conversion rules hold.
Consider:
template<class C> int get_nth(C& p, int n) ; / / get n-th element
This function presumably returns the value of the n-th element of a container of type C. Because C
has to be deduced from an actual argument of get_nth() in a call, conversions are not applicable to
the first argument. However, the second argument is perfectly ordinary, so the full range of possible conversions is considered. For example:
class Index{
public:
operator int() ;
/ / ...
};
void f(vector<int>& v, short s, Index i)
{
int i1= get_nth(v,2) ; / / exact match
int i2= get_nth(v,s) ; / / standard conversion: short to int
int i3= get_nth(v,i) ; / / user-defined conversion: Index to int
}
13.4 Using Template Arguments to Specify Policy [temp.policy]
Consider how to sort strings. Three concepts are involved: the string, the element type, and the criteria used by the sort algorithm for comparing string elements.
We can’t hardwire the sorting criteria into the container because the container can’t (in general)
impose its needs on the element types. We can’t hardwire the sorting criteria into the element type
because there are many different ways of sorting elements.
Consequently, the sorting criteria are built neither into the container nor into the element type.
Instead, the criteria must be supplied when a specific operation needs to be performed. For example, if I have strings of characters representing names of Swedes, what collating criteria would I
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 13.4 Using Template Arguments to Specify Policy 339
like to use for a comparison? Two different collating sequences (numerical orderings of the characters) are commonly used for sorting Swedish names. Naturally, neither a general string type nor a
general sort algorithm should know about the conventions for sorting names in Sweden. Therefore,
any general solution requires that the sorting algorithm be expressed in general terms that can be
defined not just for a specific type but also for a specific use of a specific type. For example, let us
generalize the standard C library function strcmp() for Strings of any type T(§13.2):
template<class T, class C>
int compare(const String<T>& str1, const String<T>& str2)
{
for(int i=0; i<str1.length() && i< str2.length() ; i++)
if(!C: :eq(str1[i] ,str2[i])) return C: :lt(str1[i] ,str2[i]) ? -1: 1;
return str1.length()-str2.length() ;
}
If someone wants compare() to ignore case, to reflect locale, etc., that can be done by defining
suitable C: :eq() and C: :lt(). This allows any (comparison, sorting, etc.) algorithm that can be
described in terms of the operations supplied by the ‘‘C-operations’’ and the container to be
expressed. For example:
template<class T> class Cmp{ / / normal, default compare
public:
static int eq(T a, T b) { return a==b; }
static int lt(T a, T b) { return a<b; }
};
class Literate{ / / compare Swedish names according to literary conventions
public:
static int eq(char a, char b) { return a==b; }
static int lt(char,char) ; / / a table lookup based on character value (§13.9[14])
};
We can now choose the rules for comparison by explicit specification of the template arguments:
void f(String<char> swede1, String<char> swede2)
{
compare< char,Cmp<char> >(swede1,swede2) ;
compare< char,Literate>(swede1,swede2) ;
}
Passing the comparison operations as a template parameter has two significant benefits compared to
alternatives such as passing pointers to functions. Several operations can be passed as a single
argument with no run-time cost. In addition, the comparison operators eq() and lt() are trivial to
inline, whereas inlining a call through a pointer to function requires exceptional attention from a
compiler.
Naturally, comparison operations can be provided for user-defined types as well as built-in
types. This is essential to allow general algorithms to be applied to types with nontrivial comparison criteria (see §18.4).
Each class generated from a class template gets a copy of each staticmember of the class template (see §C.13.1).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
340 Templates Chapter 13
13.4.1 Default Template Parameters [temp.default]
Explicitly specifying the comparison criteria for each call is tedious. Fortunately, it is easy to pick
a default so that only uncommon comparison criteria have to be explicitly specified. This can be
implemented through overloading:
template<class T, class C>
int compare(const String<T>& str1, const String<T>& str2) ; / / compare using C
template<class T>
int compare(const String<T>& str1, const String<T>& str2) ; / / compare using Cmp<T>
Alternatively, we can supply the normal convention as a default template argument:
template<class T, class C= Cmp<T> >
int compare(const String<T>& str1, const String<T>& str2)
{
for(int i=0; i<str1.length() && i< str2.length() ; i++)
if(!C: :eq(str1[i] ,str2[i])) return C: :lt(str1[i] ,str2[i]) ? -1: 1;
return str1.length()-str2.length() ;
}
Given that, we can write:
void f(String<char> swede1, String<char> swede2)
{
compare(swede1,swede2) ; / / use Cmp<char>
compare<char,Literate>(swede1,swede2) ; / / use Literate
}
A less esoteric example (for non-Swedes) is comparing with and without taking case into account:
class No_case{ /* ... */ };
void f(String<char> s1, String<char> s2)
{
compare(s1,s2) ; / / case sensitive
compare<char,No_case>(s1,s2) ; / / not sensitive to case
}
The technique of supplying a policy through a template argument and then defaulting that argument
to supply the most common policy is widely used in the standard library (e.g., §18.4). Curiously
enough, it is not used for basic_string(§13.2, Chapter 20) comparisons. Template parameters
used to express policies are often called ‘‘traits.’’ For example, the standard library string relies on
char_traits(§20.2.1), the standard algorithms on iterator traits (§19.2.2), and the standard library
containers on allocators(§19.4).
The semantic checking of a default argument for a template parameter is done if and (only)
when that default argument is actually used. In particular, as long as we refrain from using the
default template argument Cmp<T> we can compare() strings of a type Xfor which Cmp<X>
wouldn’t compile (say, because < wasn’t defined for an X). This point is crucial in the design of
the standard containers, which rely on a template argument to specify default values (§16.3.4).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 13.5 Specialization 341
13.5 Specialization [temp.special]
By default, a template gives a single definition to be used for every template argument (or combination of template arguments) that a user can think of. This doesn’t always make sense for someone
writing a template. I might want to say, ‘‘if the template argument is a pointer, use this implementation; if it is not, use that implementation’’ or ‘‘give an error unless the template argument is a
pointer derived from class My_base.’’ Many such design concerns can be addressed by providing
alternative definitions of the template and having the compiler choose between them based on the
template arguments provided where they are used. Such alternative definitions of a template are
called user-defined specializations, or simply, user specializations.
Consider likely uses of a Vectortemplate:
template<class T> class Vector{ / / general vector type
T* v;
int sz;
public:
Vector() ;
Vector(int) ;
T& elem(int i) { return v[i] ; }
T& operator[](int i) ;
void swap(Vector&) ;
/ / ...
};
Vector<int> vi;
Vector<Shape*> vps;
Vector<string> vs;
Vector<char*> vpc;
Vector<Node*> vpn;
Most Vectors will be Vectors of some pointer type. There are several reasons for this, but the primary reason is that to preserve run-time polymorphic behavior, we must use pointers (§2.5.4,
§12.2.6). That is, anyone who practices object-oriented programming and also uses type-safe containers (such as the standard library containers) will end up with a lot of containers of pointers.
The default behavior of most C++ implementations is to replicate the code for template functions. This is good for run-time performance, but unless care is taken it leads to code bloat in critical cases such as the Vectorexample.
Fortunately, there is an obvious solution. Containers of pointers can share a single implementation. This can be expressed through specialization. First, we define a version (a specialization) of
Vectorfor pointers to void:
template<> class Vector<void*> {
void** p;
/ / ...
void*& operator[](int i) ;
};
This specialization can then be used as the common implementation for all Vectors of pointers.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
342 Templates Chapter 13
The template<> prefix says that this is a specialization that can be specified without a template
parameter. The template arguments for which the specialization is to be used are specified in <>
brackets after the name. That is, the <void*> says that this definition is to be used as the implementation of every Vectorfor which Tis void* .
The Vector<void*> is a complete specialization. That is, there is no template parameter to
specify or deduce when we use the specialization; Vector<void*> is used for Vectors declared like
this:
Vector<void*> vpv;
To define a specialization that is used for every Vectorof pointers and only for Vectors of pointers,
we need a partial specialization:
template<class T> class Vector<T*> : private Vector<void*> {
public:
typedef Vector<void*> Base;
Vector() : Base() {}
explicit Vector(int i) : Base(i) {}
T*& elem(int i) { return static_cast<T*&>(Base: :elem(i)) ; }
T*& operator[](int i) { return static_cast<T*&>(Base: :operator[](i)) ; }
/ / ...
};
The specialization pattern <T*> after the name says that this specialization is to be used for every
pointer type; that is, this definition is to be used for every Vectorwith a template argument that can
be expressed as T*. For example:
Vector<Shape*> vps; / / <T*> is <Shape*> so T is Shape
Vector<int**> vppi; / / <T*> is <int**> so T is int*
Note that when a partial specialization is used, a template parameter is deduced from the specialization pattern; the template parameter is not simply the actual template argument. In particular, for
Vector<Shape*>, Tis Shapeand not Shape*.
Given this partial specialization of Vector, we have a shared implementation for all Vectors of
pointers. The Vector<T*> class is simply an interface to void* implemented exclusively through
derivation and inline expansion.
It is important that this refinement of the implementation of Vectoris achieved without affecting the interface presented to users. Specialization is a way of specifying alternative implementations for different uses of a common interface. Naturally, we could have given the general Vector
and the Vectorof pointers different names. However, when I tried that, many people who should
have known better forgot to use the pointer classes and found their code much larger than expected.
In this case, it is much better to hide the crucial implementation details behind a common interface.
This technique proved successful in curbing code bloat in real use. People who do not use a
technique like this (in C++ or in other languages with similar facilities for type parameterization)
have found that replicated code can cost megabytes of code space even in moderately-sized programs. By eliminating the time needed to compile those additional versions of the vector operations, this technique can also cut compile and link times dramatically. Using a single specialization
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 13.5 Specialization 343
to implement all lists of pointers is an example of the general technique of minimizing code bloat
by maximizing the amount of shared code.
The general template must be declared before any specialization. For example:
template<class T> class List<T*> { /* ... */ };
template<class T> class List{ /* ... */ }; / / error: general template after specialization
The critical information supplied by the general template is the set of template parameters that the
user must supply to use it or any of its specializations. Consequently, a declaration of the general
case is sufficient to allow the declaration or definition of a specialization:
template<class T> class List;
template<class T> class List<T*> { /* ... */ };
If used, the general template needs to be defined somewhere (§13.7).
If a user specializes a template somewhere, that specialization must be in scope for every use of
the template with the type for which it was specialized. For example:
template<class T> class List{ /* ... */ };
List<int*> li;
template<class T> class List<T*> { /* ... */ }; / / error
Here, Listwas specialized for int* after List<int*> had been used.
All specializations of a template must be declared in the same namespace as the template itself.
If used, a specialization that is explicitly declared (as opposed to generated from a more general
template) must also be explicitly defined somewhere (§13.7). In other words, explicitly specializing a template implies that no definition is generated for that specialization.
13.5.1 Order of Specializations [temp.special.order]
One specialization is more specialized than another if every argument list that matches its specialization pattern also matches the other, but not vice versa. For example:
template<class T> class Vector; / / general
template<class T> class Vector<T*>; / / specialized for any pointer
template<> class Vector<void*>; / / specialized for void*
Every type can be used as a template argument for the most general Vector, but only pointers can
be used for Vector<T*> and only void*s can be used for Vector<void*>.
The most specialized version will be preferred over the others in declarations of objects, pointers, etc., (§13.5) and in overload resolution (§13.3.2).
A specialization pattern can be specified in terms of types composed using the constructs
allowed for template parameter deduction (§13.3.1).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
344 Templates Chapter 13
13.5.2 Template Function Specialization [temp.special.fct]
Naturally, specialization is also useful for template functions. Consider the Shell sort from §7.7
and §13.3. It compares elements using < and swaps elements using detailed code. A better definition would be:
template<class T> bool less(T a, T b) { return a<b; }
template<class T> void sort(Vector<T>& v)
{
const size_t n= v.size() ;
for(int gap=n/2; 0<gap; gap/=2)
for(int i=gap; i<n; i++)
for(int j=i-gap; 0<=j; j-=gap)
if(less(v[j+gap] ,v[j])) swap(v[j] ,v[j+gap]) ;
}
This does not improve the algorithm itself, but it allows improvements to its implementation. As
written, sort() will not sort a Vector<char*> correctly because < will compare the two char*s.
That is, it will compare the addresses of the first charin each string. Instead, we would like it to
compare the characters pointed to. A simple specialization of less() for const char* will take care
of that:
template<> bool less<const char*>(const char* a, const char* b)
{
return strcmp(a,b)<0;
}
As for classes (§13.5), the template<> prefix says that this is a specialization that can be specified
without a template parameter. The <const char*> after the template function name means that this
specialization is to be used in cases where the template argument is const char*. Because the template argument can be deduced from the function argument list, we need not specify it explicitly.
So, we could simplify the definition of the specialization:
template<> bool less<>(const char* a, const char* b)
{
return strcmp(a,b)<0;
}
Given the template<> prefix, the second empty <> is redundant, so we would typically simply
write:
template<> bool less(const char* a, const char* b)
{
return strcmp(a,b)<0;
}
I prefer this shorter form of declaration.
Consider the obvious definition of swap():
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 13.5.2 Template Function Specialization 345
template<class T> void swap(T& x, T& y)
{
T t= x; / / copy x to temporary
x= y; / / copy y to x
y= t; / / copy temporary to y
}
This is rather inefficient when invoked for Vectors of Vectors; it swaps Vectors by copying all elements. This problem can also be solved by appropriate specialization. A Vectorobject will itself
hold only sufficient data to give indirect access to the elements (like string; §11.12, §13.2). Thus,
a swap can be done by swapping those representations. To be able to manipulate that representation, I provided Vectorwith a member function swap() (§13.5):
template<class T> void Vector<T>: :swap(Vector& a) / / swap representations
{
swap(v,a.v) ;
swap(sz,a.sz) ;
}
This member swap() can now be used to define a specialization of the general swap():
template<class T> void swap(Vector<T>& a, Vector<T>& b)
{
a.swap(b) ;
}
These specializations of less() and swap() are used in the standard library (§16.3.9, §20.3.16).
In addition, they are examples of widely applicable techniques. Specialization is useful when there
is a more efficient alternative to a general algorithm for a set of template arguments (here,
swap()). In addition, specialization comes in handy when an irregularity of an argument type
causes the general algorithm to give an undesired result (here, less()). These ‘‘irregular types’’
are often the built-in pointer and array types.
13.6 Derivation and Templates [temp.derive]
Templates and derivation are mechanisms for building new types out of existing ones, and generally for writing useful code that exploits various forms of commonality. As shown in §3.7.1,
§3.8.5, and §13.5, combinations of the two mechanisms are the basis for many useful techniques.
Deriving a template class from a non-template class is a way of providing a common implementation for a set of templates. The list from §13.5 is a good example of this:
template<class T> class list<T*> : private list<void*> { /* ... */ };
Another way of looking at such examples is that a template is used to provide an elegant and typesafe interface to an otherwise unsafe and inconvenient-to-use facility.
Naturally, it is often useful to derive one template class from another. One use of a base class is
as a building block in the implementation of further classes. If the data or operations in such a base
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
346 Templates Chapter 13
class depend on a template parameter of a derived class, the base itself must be parameterized; Vec
from §3.7.1 is an example of this:
template<class T> class vector{ /* ... */ };
template<class T> class Vec: public vector<T> { /* ... */ };
The overload resolution rules for template functions ensure that functions work ‘‘correctly’’ for
such derived types (§13.3.2).
Having the same template parameter for the base and derived class is the most common case,
but it is not a requirement. Interesting, although less frequently used, techniques rely on passing
the derived type itself to the base class. For example:
template<class C> class Basic_ops{ / / basic operators on containers
bool operator==(const C&) const; / / compare all elements
bool operator!=(const C&) const;
/ / ...
};
template<class T> class Math_container: public Basic_ops< Math_container<T> > {
public:
size_t size() const;
T& operator[](size_t) ;
/ / ...
};
This allows the definition of the basic operations on containers to be separate from the definition of
the containers themselves and defined once only. However, the definition of operations such as ==
and != must be expressed in terms of both the container and its elements, so the base class needs to
be passed to the container template.
Assuming that a Math_containeris similar to a traditional vector, the definitions of a
Basic_opsmember would look something like this:
template<class C> bool Basic_ops<C>: :operator==(const C& a) const
{
if(size() != a.size()) return false;
for(int i= 0; i<size() ; ++i)
if((*this)[i] != a[i]) return false;
return true;
}
An alternative technique for keeping the containers and operations separate would be to combine
them from template arguments rather than use derivation:
template<class T, class C> class Mcontainer{
C elements;
public:
/ / ...
T& operator[](size_t i) { return elements[i] ; }
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 13.6 Derivation and Templates 347
friend bool operator==(const Mcontainer&, const Mcontainer&) ; / / compare elements
friend bool operator!=(const Mcontainer&, const Mcontainer&) ;
/ / ...
};
template<class T> class My_array{ /* ... */ };
Mcontainer< double,My_array<double> > mc;
A class generated from a class template is a perfectly ordinary class. Consequently, it can have
friendfunctions (§C.13.2). In this case, I used friends to achieve the conventional symmetric argument style for == and != (§11.3.2). One might also consider passing a template rather than a container as the Cargument in such cases (§13.2.3).
13.6.1 Parameterization and Inheritance [temp.inherit]
A template parameterizes the definition of a type or a function with another type. Code implementing the template is identical for all parameter types, as is most code using the template. An abstract
class defines an interface. Much code for different implementations of the abstract class can be
shared in class hierarchies, and most code using the abstract class doesn’t depend on its implementation. From a design perspective, the two approaches are so close that they deserve a common
name. Since both allow an algorithm to be expressed once and applied to a variety of types, people
sometimes refer to both as polymorphic. To distinguish them, what virtual functions provide is
called run-time polymorphism, and what templates offer is called compile-time polymorphism or
parametric polymorphism.
So when do we choose to use a template and when do we rely on an abstract class? In either
case, we manipulate objects that share a common set of operations. If no hierarchical relationship
is required between these objects, they are best used as template arguments. If the actual types of
these objects cannot be known at compile-time, they are best represented as classes derived from a
common abstract class. If run-time efficiency is at a premium, that is, if inlining of operations is
essential, a template should be used. This issue is discussed in greater detail in §24.4.1.
13.6.2 Member Templates [temp.member]
A class or a class template can have members that are themselves templates. For example:
template<class Scalar> class complex{
Scalar re, im;
public:
template<class T>
complex(const complex<T>& c) : re(c.re) , im(c.im) { }
/ / ...
};
complex<float> cf(0,0) ;
complex<double> cd= cf; / / ok: uses float to double conversion
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
348 Templates Chapter 13
class Quad{
/ / no conversion to int
};
complex<Quad> cq;
complex<int> ci= cq; / / error: no Quad to int conversion
In other words, you can construct a complex<T1> from a complex<T2> if and only if you can initialize a T1by a T2. That seems reasonable.
Unfortunately, C++ accepts some unreasonable conversions between built-in types, such as
from doubleto int. Truncation problems could be caught at run time using a checked conversion in
the style of implicit_cast(§13.3.1) and checked(§C.6.2.6):
template<class Scalar> class complex{
Scalar re, im;
public:
complex() : re(0) , im(0) { }
complex(const complex<Scalar>& c) : re(c.re) , im(c.im) { }
template<class T2> complex(const complex<T2>& c)
: re(checked_cast<Scalar>(c.real())) , im(checked_cast<Scalar>(c.imag())) { }
/ / ...
};
For completeness, I added a default constructor and a copy constructor. Curiously enough, a template constructor is never used to generate a copy constructor, so without the explicitly declared
copy constructor, a default copy constructor would have been generated. In that case, that generated copy constructor would have been identical to the one I explicitly specified.
A member template cannot be virtual. For example:
class Shape{
/ / ...
template<class T> virtual bool intersect(const T&) const=0; / / error: virtual template
};
This must be illegal. If it were allowed, the traditional virtual function table technique for implementing virtual functions (§2.5.5) could not be used. The linker would have to add a new entry to
the virtual table for class Shapeeach time someone called intersect() with a new argument type.
13.6.3 Inheritance Relationships [temp.rel.inheritance]
A class template is usefully understood as a specification of how particular types are to be created.
In other words, the template implementation is a mechanism that generates types when needed
based on the user’s specification. Consequently, a class template is sometimes called a type
generator.
As far as the C++ language rules are concerned, there is no relationship between two classes
generated from a single class template. For example:
class Shape{ /* ... */ };
class Circle: public Shape{ /* ... */ };
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 13.6.3 Inheritance Relationships 349
Given these declarations, people sometimes try to treat a set<Circle*> as a set<Shape*>. This is
a serious logical error based on a flawed argument: ‘‘A Circleis a Shape, so a set of Circlesis also
a set of Shapes; therefore, I should be able to use a set of Circlesas a set of Shapes.’’ The ‘‘therefore’’ part of this argument doesn’t hold. The reason is that a set of Circles guarantees that the
member of the set are Circles; a set of Shapes does not provide that guarantee. For example:
class Triangle: public Shape{ /* ... */ };
void f(set<Shape*>& s)
{
/ / ...
s.insert(new Triangle()) ;
/ / ...
}
void g(set<Circle*>& s)
{
f(s) ; / / error, type mismatch: s is a set<Circle*>, not a set<Shape*>
}
This won’t compile because there is no built-in conversion from set<Circle*>& to set<Shape*>&.
Nor should there be. The guarantee that the members of a set<Circle*> are Circles allows us to
safely and efficiently apply Circle-specific operations, such as determining the radius, to members
of the set. If we allowed a set<Circle*> to be treated as a set<Shape*>, we could no longer maintain that guarantee. For example, f() inserts a Triangle* into its set<Shape*> argument. If the
set<Shape*> could have been a set<Circle*>, the fundamental guarantee that a set<Circle*>
contains Circle*s only would have been violated.
13.6.3.1 Template Conversions [temp.mem.temp]
The example in the previous section demonstrates that there cannot be any default relationship
between classes generated from the same templates. However, for some templates we would like to
express such a relationship. For example, when we define a pointer template, we would like to
reflect inheritance relationships among the objects pointed to. Member templates (§13.6.2) allow
us to specify many such relationships where desired. Consider:
template<class T> class Ptr{ / / pointer to T
T* p;
public:
Ptr(T*) ;
template<class T2> operator Ptr<T2> () ; / / convert Ptr<T> to Ptr<T2>
/ / ...
};
We would like to define the conversion operators to provide the inheritance relationships we are
accustomed to for built-in pointers for these user-defined Ptrs. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
350 Templates Chapter 13
void f(Ptr<Circle> pc)
{
Ptr<Shape> ps= pc; / / should work
Ptr<Circle> pc2= ps; / / should give error
}
We want to allow the first initialization if and only if Shapereally is a direct or indirect public base
class of Circle. In general, we need to define the conversion operator so that the Ptr<T> to
Ptr<T2> conversion is accepted if and only if a T* can be assigned to a T2*. That can be done
like this:
template<class T>
template<class T2>
Ptr<T>: :operator Ptr<T2> () { return Ptr<T2>(p) ; }
The return statement will compile if and only if p(which is a T*) can be an argument to the
Ptr<T2>(T2*) constructor. Therefore, if T* can be implicitly converted into a T2*, the Ptr<T>
to Ptr<T2> conversion will work. For example
void f(Ptr<Circle> pc)
{
Ptr<Shape> ps= pc; / / ok: can convert Circle* to Shape*
Ptr<Circle> pc2= ps; / / error: cannot convert Shape* to Circle*
}
Be careful to define logically meaningful conversions only.
Note that the template parameter lists of a template and its template member cannot be combined. For example:
template<class T, class T2> / / error
Ptr<T>: :operator Ptr<T2> () { return Ptr<T2>(p) ; }
13.7 Source Code Organization [temp.source]
There are two obvious ways of organizing code using templates:
[1] Include template definitions before their use in a translation unit.
[2] Include template declarations (only) before their use in a translation unit, and compile their
definitions separately.
In addition, template functions are sometimes first declared, then used, and finally defined in a single translation unit.
To see the differences between the two main approaches, consider a simple template:
#include<iostream>
template<class T> void out(const T& t) { std: :cerr<< t; }
We could call this out.cand #includeit wherever out() was needed. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 13.7 Source Code Organization 351
/ / user1.c:
#include"out.c"
/ / use out()
/ / user2.c:
#include"out.c"
/ / use out()
That is, the definition of out() and all declarations it depends on are #included in several different
compilation units. It is up to the compiler to generate code when needed (only) and to optimize the
process of reading redundant definitions. This strategy treats template functions the same way as
inline functions.
One obvious problem with this is that everything on which the definition of out() depends is
added to each file using out(), thus increasing the amount of information that the compiler must
process. Another problem is that users may accidentally come to depend on declarations included
only for the benefit of the definition of out(). This danger can be minimized by using namespaces, by avoiding macros, and generally by reducing the amount of information included.
The separate compilation strategy is the logical conclusion of this line of thinking: if the template definition isn’t included in the user code, none of its dependencies can affect that code. Thus
we split the original out.cinto two files:
/ / out.h:
template<class T> void out(const T& t) ;
/ / out.c:
#include<iostream>
#include"out.h"
export template<class T> void out(const T& t) { std: :cerr<< t; }
The file out.cnow holds all of the information needed to define out(), and out.hholds only what
is needed to call it. A user #includes only the declaration (the interface):
/ / user1.c:
#include"out.h"
/ / use out()
/ / user2.c:
#include"out.h"
/ / use out()
This strategy treats template functions the same way it does non-inline functions. The definition (in
out.c) is compiled separately, and it is up to the implementation to find the definition of out()
when needed. This strategy also puts a burden on the implementation. Instead of having to filter
out redundant copies of a template definition, the implementation must find the unique definition
when needed.
Note that to be accessible from other compilation units, a template definition must be explicitly
declared export(§9.2.3). This can be done by adding exportto the definition or to a preceding
declaration. Otherwise, the definition must be in scope wherever the template is used.
Which strategy or combination of strategies is best depends on the compilation and linkage
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
352 Templates Chapter 13
system used, the kind of application you are building, and the external constraints on the way you
build systems. Generally, inline functions and other small functions that primarily call other template functions are candidates for inclusion into every compilation unit in which they are used. On
an implementation with average support from the linker for template instantiation, doing this can
speed up compilation and improve error messages.
Including a definition makes it vulnerable to having its meaning affected by macros and declarations in the context into which it is included. Consequently, larger template functions and template functions with nontrivial context dependencies are better compiled separately. Also, if the
definition of a template requires a large number of declarations, these declarations can have undesirable side effects if they are included into the context in which the template is used.
I consider the approach of separately compiling template definitions and including declarations
only in user code ideal. However, the application of ideals must be tempered by practical constraints, and separate compilation of templates is expensive on some implementations.
Whichever strategy is used, non-inline staticmembers (§C.13.1) must have a unique definition
in some compilation unit. This implies that such members are best not used for templates that are
otherwise included in many translation units.
One ideal is for code to work the same whether it is compiled as a single unit or separated into
several separately translated units. That ideal should be approached by restricting a template
definition’s dependency on its environment rather than by trying to carry as much as possible of its
definition context with it into the instantiation process.
13.8 Advice [temp.advice]
[1] Use templates to express algorithms that apply to many argument types; §13.3.
[2] Use templates to express containers; §13.2.
[3] Provide specializations for containers of pointers to minimize code size; §13.5.
[4] Always declare the general form of a template before specializations; §13.5.
[5] Declare a specialization before its use; §13.5.
[6] Minimize a template definition’s dependence on its instantiation contexts; §13.2.5, §C.13.8.
[7] Define every specialization you declare; §13.5.
[8] Consider if a template needs specializations for C-style strings and arrays; §13.5.2.
[9] Parameterize with a policy object; §13.4.
[10] Use specialization and overloading to provide a single interface to implementations of the
same concept for different types; §13.5.
[11] Provide a simple interface for simple cases and use overloading and default arguments to
express less common cases; §13.5, §13.4.
[12] Debug concrete examples before generalizing to a template; §13.2.1.
[13] Remember to exporttemplate definitions that need to be accessible from other translation
units; §13.7.
[14] Separately compile large templates and templates with nontrivial context dependencies; §13.7.
[15] Use templates to express conversions but define those conversions very carefully; §13.6.3.1.
[16] Where necessary, constrain template arguments using a constraint() member function;
§13.9[16].
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 13.8 Advice 353
[17] Use explicit instantiation to minimize compile time and link time; §C.13.10.
[18] Prefer a template over derived classes when run-time efficiency is at a premium; §13.6.1.
[19] Prefer derived classes over a template if adding new variants without recompilation is important; §13.6.1.
[20] Prefer a template over derived classes when no common base can be defined; §13.6.1.
[21] Prefer a template over derived classes when built-in types and structures with compatibility
constraints are important; §13.6.1.
13.9 Exercises [temp.exercises]
1. (∗2) Fix the errors in the definition of Listfrom §13.2.5 and write out C++ code equivalent to
what the compiler must generate for the definition of Listand the function f(). Run a small
test case using your hand-generated code and the code generated by the compiler from the template version. If possible on your system given your knowledge, compare the generated code.
2. (∗3) Write a singly-linked list class template that accepts elements of any type derived from a
class Linkthat holds the information necessary to link elements. This is called an intrusive list.
Using this list, write a singly-linked list that accepts elements of any type (a non-intrusive list).
Compare the performance of the two list classes and discuss the tradeoffs between them.
3. (∗2.5) Write intrusive and non-intrusive doubly-linked lists. What operations should be provided in addition to the ones you found necessary to supply for a singly-linked list?
4. (∗2) Complete the Stringtemplate from §13.2 based on the Stringclass from §11.12.
5. (∗2) Define a sort() that takes its comparison criterion as a template argument. Define a class
Recordwith two data members countand price. Sort a vector<Record> on each data member.
6. (∗2) Implement a qsort() template.
7. (∗2) Write a program that reads (key,value) pairs and prints out the sum of the values corresponding to each distinct key. Specify what is required for a type to be a keyand a value.
8. (∗2.5) Implement a simple Mapclass based on the Assocclass from §11.8. Make sure Map
works correctly using both C-style strings and strings as keys. Make sure Mapworks correctly
for types with and without default constructors. Provide a way of iterating over the elements of
a Map.
9. (∗3) Compare the performance of the word count program from §11.8 against a program not
using an associative array. Use the same style of I/O in both cases.
10. (∗3) Re-implement Mapfrom §13.9[8] using a more suitable data structure (e.g., a red-black
tree or a Splay tree).
11. (∗2.5) Use Mapto implement a topological sort function. Topological sort is described in
[Knuth,1968] vol. 1 (second edition), pg 262.
12. (∗1.5) Make the sum program from §13.9[7] work correctly for names containing spaces; for
example, ‘‘thumb tack.’’
13. (∗2) Write readline() templates for different kinds of lines. For example (item,count,price).
14. (∗2) Use the technique outlined for Literatein §13.4 to sort strings in reverse lexicographical
order. Make sure the technique works both for C++ implementations where charis signedand
for C++ implementations where it is unsigned. Use a variant of that technique to provide a sort
that is not case-sensitive.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
354 Templates Chapter 13
15. (∗1.5) Construct an example that demonstrates at least three differences between a function template and a macro (not counting the differences in definition syntax).
16. (∗2) Devise a scheme that ensures that the compiler tests general constraints on the template
arguments for every template for which an object is constructed. It is not sufficient just to test
constraints of the form ‘‘the argument Tmust be a class derived from My_base.’’
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
14 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
Exception Handling
Don´t interrupt me
while I´m interrupting.
– Winston S. Churchill
Error handling — grouping of exceptions — catching exceptions — catch all — rethrow — resource management — auto_ptr— exceptions and new— resource exhaustion — exceptions in constructors — exceptions in destructors — exceptions that are not
errors — exception specifications — unexpected exceptions — uncaught exceptions —
exceptions and efficiency — error-handling alternatives — standard exceptions —
advice — exercises.
14.1 Error Handling [except.error]
As pointed out in §8.3, the author of a library can detect run-time errors but does not in general
have any idea what to do about them. The user of a library may know how to cope with such errors
but cannot detect them – or else they would have been handled in the user’s code and not left for
the library to find. The notion of an exception is provided to help deal with such problems. The
fundamental idea is that a function that finds a problem it cannot cope with throws an exception,
hoping that its (direct or indirect) caller can handle the problem. A function that wants to handle
that kind of problem can indicate that it is willing to catch that exception (§2.4.2, §8.3).
This style of error handling compares favorably with more traditional techniques. Consider the
alternatives. Upon detecting a problem that cannot be handled locally, the program could:
[1] terminate the program,
[2] return a value representing ‘‘error,’’
[3] return a legal value and leave the program in an illegal state, or
[4] call a function supplied to be called in case of ‘‘error.’’
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
356 Exception Handling Chapter 14
Case [1], ‘‘terminate the program,’’ is what happens by default when an exception isn’t caught.
For most errors, we can and must do better. In particular, a library that doesn’t know about the purpose and general strategy of the program in which it is embedded cannot simply exit() or
abort(). A library that unconditionally terminates cannot be used in a program that cannot afford
to crash. One way of viewing exceptions is as a way of giving control to a caller when no meaningful action can be taken locally.
Case [2], ‘‘return an error value,’’ isn’t always feasible because there is often no acceptable
‘‘error value.’’ For example, if a function returns an int, every intmight be a plausible result.
Even where this approach is feasible, it is often inconvenient because every call must be checked
for the error value. This can easily double the size of a program (§14.8). Consequently, this
approach is rarely used systematically enough to detect all errors.
Case [3], ‘‘return a legal value and leave the program in an illegal state,’’ has the problem that
the calling function may not notice that the program has been put in an illegal state. For example,
many standard C library functions set the global variable errnoto indicate an error (§20.4.1,
§22.3). However, programs typically fail to test errnoconsistently enough to avoid consequential
errors caused by values returned from failed calls. Furthermore, the use of global variables for
recording error conditions doesn’t work well in the presence of concurrency.
Exception handling is not meant to handle problems for which case [4], ‘‘call an error-handler
function,’’ is relevant. However, in the absence of exceptions, an error-handler function has
exactly the three other cases as alternatives for how it handles the error. For a further discussion of
error-handling functions and exceptions, see §14.4.5.
The exception-handling mechanism provides an alternative to the traditional techniques when
they are insufficient, inelegant, and error-prone. It provides a way of explicitly separating errorhandling code from ‘‘ordinary’’ code, thus making the program more readable and more amenable
to tools. The exception-handling mechanism provides a more regular style of error handling, thus
simplifying cooperation between separately written program fragments.
One aspect of the exception-handling scheme that will appear novel to C and Pascal programmers is that the default response to an error (especially to an error in a library) is to terminate the
program. The traditional response has been to muddle through and hope for the best. Thus, exception handling makes programs more ‘‘brittle’’ in the sense that more care and effort must be taken
to get a program to run acceptably. This seems preferable, though, to getting wrong results later in
the development process – or after the development process is considered complete and the program is handed over to innocent users. Where termination is unacceptable, we can catch all exceptions (§14.3.2) or catch all exceptions of a specific kind (§14.6.2). Thus, an exception terminates a
program only if a programmer allows it to terminate. This is preferable to the unconditional termination that happens when a traditional incomplete recovery leads to a catastrophic error.
Sometimes people have tried to alleviate the unattractive aspects of ‘‘muddling through’’ by
writing out error messages, putting up dialog boxes asking the user for help, etc. Such approaches
are primarily useful in debugging situations in which the user is a programmer familiar with the
structure of the program. In the hands of nondevelopers, a library that asks the (possibly absent)
user/operator for help is unacceptable. Also, in many cases error messages have no place to go
(say, if the program runs in an environment in which cerrdoesn’t connect to anything a user
notices); they would be incomprehensible to an end user anyway. At a minimum, the error message might be in the wrong natural language (say, in Finnish to a English user). Worse, the error
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.1 Error Handling 357
message would typically refer to library concepts completely unknown to a user (say, ‘‘bad argument to atan2,’’ caused by bad input to a graphics system). A good library doesn’t ‘‘blabber’’ in
this way. Exceptions provide a way for code that detects a problem from which it cannot recover to
pass the problem on to some part of the system that might be able to recover. Only a part of the
system that has some idea of the context in which the program runs has any chance of composing a
meaningful error message.
The exception-handling mechanism can be seen as a run-time analog to the compile-time type
checking and ambiguity control mechanisms. It makes the design process more important and can
increase the work needed to get an initial and buggy version of a program running. However, the
result is code that has a much better chance to run as expected, to run as an acceptable part of a
larger program, to be comprehensible to other programmers, and to be amenable to manipulation by
tools. Similarly, exception handling provides specific language features to support ‘‘good style’’ in
the same way other C++ features support ‘‘good style’’ that can be practiced only informally and
incompletely in languages such as C and Pascal.
It should be recognized that error handling will remain a difficult task and that the exceptionhandling mechanism – although more formalized than the techniques it replaces – is still relatively
unstructured compared with language features involving only local control flow. The C++
exception-handling mechanism provides the programmer with a way of handling errors where they
are most naturally handled, given the structure of a system. Exceptions make the complexity of
error handling visible. However, exceptions are not the cause of that complexity. Be careful not to
blame the messenger for bad news.
This may be a good time to review §8.3, where the basic syntax, semantics, and style-of-use
aspects of exception handling are presented.
14.1.1 Alternative Views on Exceptions [except.views]
‘‘Exception’’ is one of those words that means different things to different people. The C++
exception-handling mechanism is designed to support handling of errors and other exceptional conditions (hence the name). In particular, it is intended to support error handling in programs composed of independently developed components.
The mechanism is designed to handle only synchronous exceptions, such as array range checks
and I/O errors. Asynchronous events, such as keyboard interrupts and certain arithmetic errors, are
not necessarily exceptional and are not handled directly by this mechanism. Asynchronous events
require mechanisms fundamentally different from exceptions (as defined here) to handle them
cleanly and efficiently. Many systems offer mechanisms, such as signals, to deal with asynchrony,
but because these tend to be system-dependent, they are not described here.
The exception-handling mechanism is a nonlocal control structure based on stack unwinding
(§14.4) that can be seen as an alternative return mechanism. There are therefore legitimate uses of
exceptions that have nothing to do with errors (§14.5). However, the primary aim of the
exception-handling mechanism and the focus of this chapter is error handling and the support of
fault tolerance.
Standard C++ doesn’t have the notion of a thread or a process. Consequently, exceptional circumstances relating to concurrency are not discussed here. The concurrency facilities available on
your system are described in its documentation. Here, I’ll just note that the C++ exceptionThe C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
358 Exception Handling Chapter 14
handling mechanism was designed to be effective in a concurrent program as long as the programmer (or system) enforces basic concurrency rules, such as properly locking a shared data structure
while using it.
The C++ exception-handling mechanisms are provided to report and handle errors and exceptional events. However, the programmer must decide what it means to be exceptional in a given
program. This is not always easy (§14.5). Can an event that happens most times a program is run
be considered exceptional? Can an event that is planned for and handled be considered an error?
The answer to both questions is yes. ‘‘Exceptional’’ does not mean ‘‘almost never happens’’ or
‘‘disastrous.’’ It is better to think of an exception as meaning ‘‘some part of the system couldn’t do
what it was asked to do.’’ Usually, we can then try something else. Exception throws should be
infrequent compared to function calls or the structure of the system has been obscured. However,
we should expect most large programs to throwand catchat least some exceptions in the course of
a normal and successful run.
14.2 Grouping of Exceptions [except.grouping]
An exception is an object of some class representing an exceptional occurrence. Code that detects
an error (often a library) throws an object (§8.3). A piece of code expresses desire to handle an
exception by a catchclause. The effect of a throwis to unwind the stack until a suitable catchis
found (in a function that directly or indirectly invoked the function that threw the exception).
Often, exceptions fall naturally into families. This implies that inheritance can be useful to
structure exceptions and to help exception handling. For example, the exceptions for a mathematical library might be organized like this:
class Matherr{ };
class Overflow: public Matherr{ };
class Underflow: public Matherr{ };
class Zerodivide: public Matherr{ };
/ / ...
This allows us to handle any Matherrwithout caring precisely which kind it is. For example:
void f()
{
try{
/ / ...
}
catch(Overflow) {
/ / handle Overflow or anything derived from Overflow
}
catch(Matherr) {
/ / handle any Matherr that is not Overflow
}
}
Here, an Overflowis handled specifically. All other Matherrexceptions will be handled by the
general case.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.2 Grouping of Exceptions 359
Organizing exceptions into hierarchies can be important for robustness of code. For example,
consider how you would handle all exceptions from a library of mathematical functions without
such a grouping mechanism. This would have to be done by exhaustively listing the exceptions:
void g()
{
try{
/ / ...
}
catch(Overflow) { /* ... */ }
catch(Underflow) { /* ... */ }
catch(Zerodivide) { /* ... */ }
}
This is not only tedious, but a programmer can easily forget to add an exception to the list. Consider what would be needed if we didn’t group math exceptions. When we added a new exception
to the math library, every piece of code that tried to handle every math exception would have to be
modified. In general, such universal update is not feasible after the initial release of the library.
Often, there is no way of finding every relevant piece of code. Even when there is, we cannot in
general assume that every piece of source code is available or that we would be willing to make
changes if it were. These recompilation and maintenance problems would lead to a policy that no
new exceptions can be added to a library after its first release; that would be unacceptable for
almost all libraries. This reasoning leads exceptions to be defined as per-library or per-subsystem
class hierarchies (§14.6.2).
Please note that neither the built-in mathematical operations nor the basic math library (shared
with C) reports arithmetic errors as exceptions. One reason for this is that detection of some arithmetic errors, such as divide-by-zero, are asynchronous on many pipelined machine architectures.
The Matherrhierarchy described here is only an illustration. The standard library exceptions are
described in §14.10.
14.2.1 Derived Exceptions [except.derived]
The use of class hierarchies for exception handling naturally leads to handlers that are interested
only in a subset of the information carried by exceptions. In other words, an exception is typically
caught by a handler for its base class rather than by a handler for its exact class. The semantics for
catching and naming an exception are identical to those of a function accepting an argument. That
is, the formal argument is initialized with the argument value (§7.2). This implies that the exception thrown is ‘‘sliced’’ to the exception caught (§12.2.3). For example:
class Matherr{
/ / ...
virtual void debug_print() const{ cerr<< "Math error"; }
};
class Int_overflow: public Matherr{
const char* op;
int a1, a2;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
360 Exception Handling Chapter 14
public:
Int_overflow(const char* p, int a, int b) { op= p; a1= a; a2= b; }
virtual void debug_print() const{ cerr<< op<< ´(´ << a1<< ´,´ << a2<< ´)´; }
/ / ...
};
void f()
{
try{
g() ;
}
catch(Matherr m) {
/ / ...
}
}
When the Matherrhandler is entered, mis a Matherrobject – even if the call to g() threw
Int_overflow. This implies that the extra information found in an Int_overflowis inaccessible.
As always, pointers or references can be used to avoid losing information permanently. For
example, we might write:
int add(int x, int y)
{
if((x>0&& y>0&& x>INT_MAX-y) || (x<0&& y<0&& x<INT_MIN-y))
throw Int_overflow("+",x,y) ;
return x+y; / / x+y will not overflow
}
void f()
{
try{
int i1= add(1,2) ;
int i2= add(INT_MAX,-2) ;
int i3= add(INT_MAX,2) ; / / here we go!
}
catch(Matherr& m) {
/ / ...
m.debug_print() ;
}
}
The last call of add() triggers an exception that causes Int_overflow: :debug_print() to be
invoked. Had the exception been caught by value rather than by reference,
Matherr: :debug_print() would have been invoked instead.
14.2.2 Composite Exceptions [except.composite]
Not every grouping of exceptions is a tree structure. Often, an exception belongs to two groups.
For example:
class Netfile_err: public Network_err, public File_system_err{ /* ... */ };
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.2.2 Composite Exceptions 361
Such a Netfile_errcan be caught by functions dealing with network exceptions:
void f()
{
try{
/ / something
}
catch(Network_err& e) {
/ / ...
}
}
and also by functions dealing with file system exceptions:
void g()
{
try{
/ / something else
}
catch(File_system_err& e) {
/ / ...
}
}
This nonhierarchical organization of error handling is important where services, such as networking, are transparent to users. In this case, the writer of g() might not even be aware that a network
is involved (see also §14.6).
14.3 Catching Exceptions [except.catch]
Consider:
void f()
{
try{
throw E() ;
}
catch(H) {
/ / when do we get here?
}
}
The handler is invoked:
[1] If His the same type as E.
[2] If His an unambiguous public base of E.
[3] If Hand Eare pointer types and [1] or [2] holds for the types to which they refer.
[4] If His a reference and [1] or [2] holds for the type to which Hrefers.
In addition, we can add constto the type used to catch an exception in the same way that we can
add it to a function parameter. This doesn’t change the set of exceptions we can catch; it only
restricts us from modifying the exception caught.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
362 Exception Handling Chapter 14
In principle, an exception is copied when it is thrown, so the handler gets hold of a copy of the
original exception. In fact, an exception may be copied several times before it is caught. Consequently, we cannot throw an exception that cannot be copied. The implementation may apply a
wide variety of strategies for storing and transmitting exceptions. It is guaranteed, however, that
there is sufficient memory to allow newto throw the standard out-of-memory exception, bad_alloc
(§14.4.5).
14.3.1 Re-Throw [except.rethrow]
Having caught an exception, it is common for a handler to decide that it can’t completely handle
the error. In that case, the handler typically does what can be done locally and then throws the
exception again. Thus, an error can be handled where it is most appropriate. This is the case even
when the information needed to best handle the error is not available in a single place, so that the
recovery action is best distributed over several handlers. For example:
void h()
{
try{
/ / code that might throw Math errors
}
catch(Matherr) {
if(can_handle_it_completely) {
/ / handle the Matherr
return;
}
else{
/ / do what can be done here
throw; / / re-throw the exception
}
}
}
A re-throw is indicated by a throwwithout an operand. If a re-throw is attempted when there is no
exception to re-throw, terminate() (§14.7) will be called. A compiler can detect and warn about
some, but not all, such cases.
The exception re-thrown is the original exception caught and not just the part of it that was
accessible as a Matherr. In other words, had an Int_overflowbeen thrown, a caller of h() could
still catch an Int_overflowthat h() had caught as a Matherrand decided to re-throw.
14.3.2 Catch Every Exception [except.every]
A degenerate version of this catch-and-rethrow technique can be important. As for functions, the
ellipsis ... indicates ‘‘any argument’’ (§7.6), so catch(...) means ‘‘catch any exception.’’
For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.3.2 Catch Every Exception 363
void m()
{
try{
/ / something
}
catch(...) { / / handle every exception
/ / cleanup
throw;
}
}
That is, if any exception occurs as the result of executing the main part of m(), the cleanup action
in the handler is invoked. Once the local cleanup is done, the exception that caused the cleanup is
re-thrown to trigger further error handling. See §14.6.3.2 for a technique to gain information about
an exception caught by a ... handler.
One important aspect of error handling in general and exception handling in particular is to
maintain invariants assumed by the program (§24.3.7.1). For example, if m() is supposed to leave
certain pointers in the state in which it found them, then we can write code in the handler to give
them acceptable values. Thus, a ‘‘catch every exception’’ handler can be used to maintain arbitrary
invariants. However, for many important cases such a handler is not the most elegant solution to
this problem (see §14.4).
14.3.2.1 Order of Handlers [except.order]
Because a derived exception can be caught by handlers for more than one exception type, the order
in which the handlers are written in a trystatement is significant. The handlers are tried in order.
For example:
void f()
{
try{
/ / ...
}
catch(std: :ios_base: :failure) {
/ / handle any stream io error (§14.10)
}
catch(std: :exception& e) {
/ / handle any standard library exception (§14.10)
}
catch(...) {
/ / handle any other exception (§14.3.2)
}
}
Because the compiler knows the class hierarchy, it can catch many logical mistakes. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
364 Exception Handling Chapter 14
void g()
{
try{
/ / ...
}
catch(...) {
/ / handle every exception (§14.3.2)
}
catch(std: :exception& e) {
/ / handle any standard library exception (§14.10)
}
catch(std: :bad_cast) {
/ / handle dynamic_cast failure (§15.4.2)
}
}
Here, the exceptionwill never be considered. Even if we removed the ‘‘catch-all’’ handler,
bad_castwouldn’t be considered because it is derived from exception.
14.4 Resource Management [except.resource]
When a function acquires a resource – that is, it opens a file, allocates some memory from the free
store, sets an access control lock, etc., – it is often essential for the future running of the system that
the resource be properly released. Often that ‘‘proper release’’ is achieved by having the function
that acquired it release it before returning to its caller. For example:
void use_file(const char* fn)
{
FILE* f= fopen(fn,"w") ;
/ / use f
fclose(f) ;
}
This looks plausible until you realize that if something goes wrong after the call of fopen() and
before the call of fclose(), an exception may cause use_file() to be exited without fclose()
being called. Exactly the same problem can occur in languages that do not support exception handling. For example, the standard C library function longjmp() can cause the same problem. Even
an ordinary return-statement could exit use_filewithout closing f.
A first attempt to make use_file() to be fault-tolerant looks like this:
void use_file(const char* fn)
{
FILE* f= fopen(fn,"r") ;
try{
/ / use f
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.4 Resource Management 365
catch(...) {
fclose(f) ;
throw;
}
fclose(f) ;
}
The code using the file is enclosed in a tryblock that catches every exception, closes the file, and
re-throws the exception.
The problem with this solution is that it is verbose, tedious, and potentially expensive. Furthermore, any verbose and tedious solution is error-prone because programmers get bored. Fortunately,
there is a more elegant solution. The general form of the problem looks like this:
void acquire()
{
/ / acquire resource 1
/ / ...
/ / acquire resource n
/ / use resources
/ / release resource n
/ / ...
/ / release resource 1
}
It is typically important that resources are released in the reverse order of their acquisition. This
strongly resembles the behavior of local objects created by constructors and destroyed by
destructors. Thus, we can handle such resource acquisition and release problems by a suitable use
of objects of classes with constructors and destructors. For example, we can define a class File_ptr
that acts like a FILE*:
class File_ptr{
FILE* p;
public:
File_ptr(const char* n, const char* a) { p= fopen(n,a) ; }
File_ptr(FILE* pp) { p= pp; }
~File_ptr() { fclose(p) ; }
operator FILE*() { return p; }
};
We can construct a File_ptrgiven either a FILE* or the arguments required for fopen(). In either
case, a File_ptrwill be destroyed at the end of its scope and its destructor will close the file. Our
program now shrinks to this minimum:
void use_file(const char* fn)
{
File_ptr f(fn,"r") ;
/ / use f
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
366 Exception Handling Chapter 14
The destructor will be called independently of whether the function is exited normally or exited
because an exception is thrown. That is, the exception-handling mechanisms enable us to remove
the error-handling code from the main algorithm. The resulting code is simpler and less errorprone than its traditional counterpart.
The process of searching ‘‘up through the stack’’ to find a handler for an exception is commonly called ‘‘stack unwinding.’’ As the call stack is unwound, the destructors for constructed
local objects are invoked.
14.4.1 Using Constructors and Destructors [except.using]
The technique for managing resources using local objects is usually referred to as ‘‘resource acquisition is initialization.’’ This is a general technique that relies on the properties of constructors and
destructors and their interaction with exception handling.
An object is not considered constructed until its constructor has completed. Then and only then
will stack unwinding call the destructor for the object. An object composed of sub-objects is constructed to the extent that its sub-objects have been constructed. An array is constructed to the
extent that its elements have been constructed (and only fully constructed elements are destroyed
during unwinding).
A constructor tries to ensure that its object is completely and correctly constructed. When that
cannot be achieved, a well-written constructor restores – as far as possible – the state of the system
to what it was before creation. Ideally, naively written constructors always achieve one of these
alternatives and don’t leave their objects in some ‘‘half-constructed’’ state. This can be achieved
by applying the ‘‘resource acquisition is initialization’’ technique to the members.
Consider a class Xfor which a constructor needs to acquire two resources: a file xand a lock y.
This acquisition might fail and throw an exception. Class X’s constructor must never return having
acquired the file but not the lock. Furthermore, this should be achieved without imposing a burden
of complexity on the programmer. We use objects of two classes, File_ptrand Lock_ptr, to represent the acquired resources. The acquisition of a resource is represented by the initialization of the
local object that represents the resource:
class X{
File_ptr aa;
Lock_ptr bb;
public:
X(const char* x, const char* y)
: aa(x,"rw") , / / acquire ‘x’
bb(y) / / acquire ‘y’
{}
/ / ...
};
Now, as in the local object case, the implementation can take care of all of the bookkeeping. The
user doesn’t have to keep track at all. For example, if an exception occurs after aahas been constructed but before bbhas been, then the destructor for aabut not for bbwill be invoked.
This implies that where this simple model for acquisition of resources is adhered to, the author
of the constructor need not write explicit exception-handling code.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.4.1 Using Constructors and Destructors 367
The most common resource acquired in an ad-hoc manner is memory. For example:
class Y{
int* p;
void init() ;
public:
Y(int s) { p= new int[s] ; init() ; }
~Y() { delete[] p; }
/ / ...
};
This practice is common and can lead to ‘‘memory leaks.’’ If an exception is thrown by init(),
then the store acquired will not be freed; the destructor will not be called because the object wasn’t
completely constructed. A safe variant is:
class Z{
vector<int> p;
void init() ;
public:
Z(int s) : p(s) { init() ; }
/ / ...
};
The memory used by pis now managed by vector. If init() throws an exception, the memory
acquired will be freed when the destructor for pis (implicitly) invoked.
14.4.2 Auto_ptr [except.autoptr]
The standard library provides the template class auto_ptr, which supports the ‘‘resource acquisition
is initialization’’ technique. Basically, an auto_ptris initialized by a pointer and can be dereferenced in the way that a pointer can. Also, the object pointed to will be implicitly deleted at the end
of the auto_ptr’s scope. For example:
void f(Point p1, Point p2, auto_ptr<Circle> pc, Shape* pb) / / remember to delete pb on exit
{
auto_ptr<Shape> p(new Rectangle(p1,p2)) ; / / p points to a rectangle
auto_ptr<Shape> pbox(pb) ;
p->rotate(45) ; / / use auto_ptr<Shape> exactly as a Shape*
/ / ...
if(in_a_mess) throw Mess() ;
/ / ...
}
Here the Rectangle, the Shapepointed to by pb, and the Circlepointed to by pcare deleted
whether or not an exception is thrown.
To achieve this ownership semantics (also called destructive copy semantics), auto_ptrs have a
copy semantics that differs radically from that of ordinary pointers: When one auto_ptris copied
into another, the source no longer points to anything. Because copying an auto_ptrmodifies it, a
const auto_ptrcannot be copied.
The auto_ptrtemplate is declared in <memory>. It can be described by an implementation:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
368 Exception Handling Chapter 14
template<class X> class std: :auto_ptr{
template<class Y> struct auto_ptr_ref{ /* ... */ }; / / helper class
X* ptr;
public:
typedef X element_type;
explicit auto_ptr(X* p=0) throw() { ptr=0; }
auto_ptr(auto_ptr& a) throw() { ptr=a.ptr; a.ptr=0; } / / note: not const auto_ptr&
template<class Y> auto_ptr(auto_ptr<Y>& a) throw() { ptr=a.ptr; a.ptr=0; }
auto_ptr& operator=(auto_ptr& a) throw() { ptr=a.ptr; a.ptr=0; }
template<class Y> auto_ptr& operator=(auto_ptr<Y>& a) throw() { ptr=a.ptr; a.ptr=0; }
~auto_ptr() throw() { delete ptr; }
X& operator*() const throw() { return*ptr; }
X* operator->() const throw() { return ptr; }
X* get() const throw() { return ptr; } / / extract pointer
X* release() throw() { X* t= ptr; ptr=0; return t; } / / relinquish ownership
void reset(X* p=0) throw() { if(p!=ptr) { delete ptr; ptr=p; } }
auto_ptr(auto_ptr_ref<X>) throw() ; / / copy from auto_ptr_ref
template<class Y> operator auto_ptr_ref<Y>() throw() ; / / copy from auto_ptr_ref
template<class Y> operator auto_ptr<Y>() throw() ; / / destructive copy from auto_ptr
};
The purpose of auto_ptr_refis to implement the destructive copy semantics for ordinary auto_ptrs
while making it impossible to copy a const auto_ptr. The template constructor and template
assignment ensures that an auto_ptr<D> can be implicitly converted to a auto_ptr<B> if a D* can
be converted to a B*. For example:
void g(Circle* pc)
{
auto_ptr<Circle> p2= pc; / / now p2 is responsible for deletion
auto_ptr<Circle> p3= p2; / / now p3 is responsible for deletion (and p2 isn’t)
p2->m= 7; / / programmer error: p2.get()==0
Shape* ps= p3.get() ; / / extract the pointer from an auto_ptr
auto_ptr<Shape> aps= p3; / / transfer of ownership and convert type
auto_ptr<Circle> p4= p; / / programmer error: now p4 is also responsible for deletion
}
The effect of having more than one auto_ptrown an object is undefined; most likely the object will
be deleted twice (with bad effects).
Note that auto_ptr’s destructive copy semantics means that it does not meet the requirements
for elements of a standard container or for standard algorithms such as sort(). For example:
void h(vector< auto_ptr<Shape*> >& v) / / dangerous: use of auto_ptr in container
{
sort(v.begin() ,v.end()) ; / / Don’t do this: The sort will probably mess up v
}
Clearly, auto_ptrisn’t a general smart pointer. However, it provides the service for which it was
designed – exception safety for automatic pointers – with essentially no overhead.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.4.3 Caveat 369
14.4.3 Caveat [except.caveat]
Not all programs need to be resilient against all forms of failure, and not all resources are critical
enough to warrant the effort to protect them using ‘‘resource acquisition is initialization,’’
auto_ptr, and catch(...). For example, for many programs that simply read an input and run to
completion, the most suitable response to a serious run-time error is to abort the process (after producing a suitable diagnostic). That is, let the system release all acquired resources and let the user
re-run the program with a more suitable input. The strategy discussed here is intended for applications for which such a simplistic response to a run-time error is unacceptable. In particular, a
library designer usually cannot make assumptions about the fault tolerance requirements of a program using the library and is thus forced to avoid all unconditional run-time failures and to release
all resources before a library function returns to the calling program. The ‘‘resource acquisition is
initialization’’ strategy, together with the use of exceptions to signal failure, is suitable for many
such libraries.
14.4.4 Exceptions and New [except.new]
Consider:
void f(Arena& a, X* buffer)
{
X* p1= new X;
X* p2= new X[10] ;
X* p3= new(buffer[10]) X; / / place X in buffer (no deallocation needed)
X* p4= new(buffer[11]) X[10] ;
X* p5= new(a) X; / / allocation from Arena a (deallocate from a)
X* p6= new(a) X[10] ;
}
What happens if X´sconstructor throws an exception? Is the memory allocated by the operator
new() freed? For the ordinary case, the answer is yes, so the initializations of p1and p2don’t
cause memory leaks.
When the placement syntax (§10.4.11) is used, the answer cannot be that simple. Some uses of
that syntax allocate memory, which then ought to be released; however, some don’t. Furthermore,
the point of using the placement syntax is to achieve nonstandard allocation, so nonstandard freeing
is typically required. Consequently, the action taken depends on the allocator used. If an allocator
Z: :operator new() is used, Z: :operator delete() is invoked if it exists; otherwise, no
deallocation is attempted. Arrays are handled equivalently (§15.6.1). This strategy correctly handles the standard library placement newoperator (§10.4.11), as well as any case in which the programmer has provided a matching pair of allocation and deallocation functions.
14.4.5 Resource Exhaustion [except.exhaust]
A recurring programming problem is what to do when an attempt to acquire a resource fails. For
example, previously we blithely opened files (using fopen()) and requested memory from the free
store (using operator new) without worrying about what happened if the file wasn’t there or if we
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
370 Exception Handling Chapter 14
had run out of free store. When confronted with such problems, programmers come up with two
styles of solutions:
Resumption: Ask some caller to fix the problem and carry on.
Termination: Abandon the computation and return to some caller.
In the former case, a caller must be prepared to help out with resource acquisition problems in
unknown pieces of code. In the latter, a caller must be prepared to cope with failure of the attempt
to acquire the resource. The latter is in most cases far simpler and allows a system to maintain a
better separation of levels of abstraction. Note that it is not the program that terminates when one
uses the termination strategy; only an individual computation terminates. ‘‘Termination’’ is the traditional term for a strategy that returns from a ‘‘failed’’ computation to an error handler associated
with a caller (which may re-try the failed computation), rather than trying to repair a bad situation
and resume from the point at which the problem was detected.
In C++, the resumption model is supported by the function-call mechanism and the termination
model is supported by the exception-handling mechanism. Both can be illustrated by a simple
implementation and use of the standard library operator new():
void* operator new(size_t size)
{
for(;;) {
if(void* p= malloc(size)) return p; / / try to find memory
if(_new_handler== 0) throw bad_alloc() ; / / no handler: give up
_new_handler() ; / / ask for help
}
}
Here, I use the standard C library malloc() to do the real search for memory; other implementations of operator new() may choose other ways. If memory is found, operator new() can return
a pointer to it. Otherwise, operator new() calls the _new_handler. If the _new_handlercan find
more memory for malloc() to allocate, all is fine. If it can’t, the handler cannot return to operator
new() without causing an infinite loop. The _new_handler() might then choose to throw an
exception, thus leaving the mess for some caller to handle:
void my_new_handler()
{
int no_of_bytes_found= find_some_memory() ;
if(no_of_bytes_found< min_allocation) throw bad_alloc() ; / / give up
}
Somewhere, there ought to be a try_block with a suitable handler:
try{
/ / ...
}
catch(bad_alloc) {
/ / somehow respond to memory exhaustion
}
The _new_handlerused in the implementation of operator new() is a pointer to a function maintained by the standard function set_new_handler(). If I want my_new_handler() to be used as
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.4.5 Resource Exhaustion 371
the _new_handler, I say:
set_new_handler(&my_new_handler) ;
If I also want to catch bad_alloc, I might say:
void f()
{
void(*oldnh)() = set_new_handler(&my_new_handler) ;
try{
/ / ...
}
catch(bad_alloc) {
/ / ...
}
catch(...) {
set_new_handler(oldnh) ; / / re-set handler
throw; / / re-throw
}
set_new_handler(oldnh) ; / / re-set handler
}
Even better, avoid the catch(...) handler by applying the ‘‘resource acquisition is initialization’’ technique described in §14.4 to the _new_handler(§14.12[1]).
With the _new_handler, no extra information is passed along from where the error is detected
to the helper function. It is easy to pass more information. However, the more information that is
passed between the code detecting a run-time error and a function helping correct that error, the
more the two pieces of code become dependent on each other. This implies that changes to the one
piece of code require understanding of and maybe even changes to the other. To keep separate
pieces of software separate, it is usually a good idea to minimize such dependencies. The
exception-handling mechanism supports such separation better than do function calls to helper routines provided by a caller.
In general, it is wise to organize resource allocation in layers (levels of abstraction) and avoid
having one layer depend on help from the layer that called it. Experience with larger systems
shows that successful systems evolve in this direction.
Throwing an exception requires an object to throw. A C++ implementation is required to have
enough spare memory to be able to throw bad_allocin case of memory exhaustion. However, it is
possible that throwing some other exception will cause memory exhaustion.
14.4.6 Exceptions in Constructors [except.ctor]
Exceptions provide a solution to the problem of how to report errors from a constructor. Because a
constructor does not return a separate value for a caller to test, the traditional (that is, nonexception-handling) alternatives are:
[1] Return an object in a bad state, and trust the user to test the state.
[2] Set a nonlocal variable (e.g., errno) to indicate that the creation failed, and trust the user to
test that variable.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
372 Exception Handling Chapter 14
[3] Don’t do any initialization in the constructor, and rely on the user to call an initialization
function before the first use.
[4] Mark the object ‘‘uninitialized’’ and have the first member function called for the object do
the real initialization, and that function can then report an error if initialization fails.
Exception handling allows the information that a construction failed to be transmitted out of the
constructor. For example, a simple Vectorclass might protect itself from excessive demands on
memory like this:
class Vector{
public:
class Size{ };
enum{ max= 32000};
Vector: :Vector(int sz)
{
if(sz<0|| max<sz) throw Size() ;
/ / ...
}
/ / ...
};
Code creating Vectors can now catch Vector: :Sizeerrors, and we can try to do something sensible
with them:
Vector* f(int i)
{
try{
Vector* p= new Vector(i) ;
/ / ...
return p;
}
catch(Vector: :Size) {
/ / deal with size error
}
}
As always, the error handler itself can use the standard set of fundamental techniques for error
reporting and recovery. Each time an exception is passed along to a caller, the view of what went
wrong changes. If suitable information is passed along in the exception, the amount of information
available to deal with the problem could increase. In other words, the fundamental aim of the
error-handling techniques is to pass information about an error from the original point of detection
to a point where there is sufficient information available to recover from the problem, and to do so
reliably and conveniently.
The ‘‘resource acquisition is initialization’’ technique is the safest and most elegant way of handling constructors that acquire more than one resource (§14.4). In essence, the technique reduces
the problem of handling many resources to repeated application of the (simple) technique for handling one resource.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.4.6.1 Exceptions and Member Initialization 373
14.4.6.1 Exceptions and Member Initialization [except.member]
What happens if a member initializer (directly or indirectly) throws an exception? By default, the
exception is passed on to whatever invoked the constructor for the member’s class. However, the
constructor itself can catch such exceptions by enclosing the complete function body – including
the member initializer list – in a try-block. For example:
class X{
Vector v;
/ / ...
public:
X(int) ;
/ / ...
};
X: :X(int s)
try
:v(s) / / initialize v by s
{
/ / ...
}
catch(Vector: :Size) { / / exceptions thrown for v are caught here
/ / ...
}
Copy constructors (§10.4.4.1) are special in that they are invoked implicitly and because they often
both acquire and release resources. In particular, the standard library assumes proper – nonexception-throwing – behavior of copy constructors. For these reasons, care should be taken that a
copy constructor throws an exception only in truly disastrous circumstances. Complete recovery
from an exception in a copy constructor is unlikely to be feasible in every context of its use. To be
even potentially safe, a copy constructor must leave behind two objects, each of which fulfills the
invariant of its class (§24.3.7.1).
Naturally, copy assignment operators should be treated with as much care as copy constructors.
14.4.7 Exceptions in Destructors [except.dtor]
From the point of view of exception handling, a destructor can be called in one of two ways:
[1] Normal call: As the result of a normal exit from a scope (§10.4.3), a delete(§10.4.5), etc.
[2] Call during exception handling: During stack unwinding (§14.4), the exception-handling
mechanism exits a scope containing an object with a destructor.
In the latter case, an exception may not escape from the destructor itself. If it does, it is considered
a failure of the exception-handling mechanism and std: :terminate() (§14.7) is called. After all,
there is no general way for the exception-handling mechanism or the destructor to determine
whether it is acceptable to ignore one of the exceptions in favor of handling the other.
If a destructor calls functions that may throw exceptions, it can protect itself. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
374 Exception Handling Chapter 14
X: :~X()
try{
f() ; / / might throw
}
catch(...) {
/ / do something
}
The standard library function uncaught_exception() returns trueif an exception has been thrown
but hasn’t yet been caught. This allows the programmer to specify different actions in a destructor
depending on whether an object is destroyed normally or as part of stack unwinding.
14.5 Exceptions That Are Not Errors [except.not.error]
If an exception is expected and caught so that it has no bad effects on the behavior of the program,
then how can it be an error? Only because the programmer thinks of it as an error and of the
exception-handling mechanisms as tools for handling errors. Alternatively, one might think of the
exception-handling mechanisms as simply another control structure. For example:
void f(Queue<X>& q)
{
try{
for(;;) {
X m= q.get() ; / / throws ‘Empty’ if queue is empty
/ / ...
}
}
catch(Queue<X>: :Empty) {
return;
}
}
This actually has some charm, so it is a case in which it is not entirely clear what should be considered an error and what should not.
Exception handling is a less structured mechanism than local control structures such as ifand
forand is often less efficient when an exception is actually thrown. Therefore, exceptions should
be used only where the more traditional control structures are inelegant or impossible to use. Note
that the standard library offers a queueof arbitrary elements without using exceptions (§17.3.2).
Using exceptions as alternate returns can be an elegant technique for terminating search functions – especially highly recursive search functions such as a lookup in a tree. For example:
void fnd(Tree* p, const string& s)
{
if(s== p->str) throw p; / / found s
if(p->left) fnd(p->left,s) ;
if(p->right) fnd(p->right,s) ;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.5 Exceptions That Are Not Errors 375
Tree* find(Tree* p, const string& s)
{
try{
fnd(p,s) ;
}
catch(Tree* q) { / / q– >str==s
return q;
}
return 0;
}
However, such use of exceptions can easily be overused and lead to obscure code. Whenever reasonable, one should stick to the ‘‘exception handling is error handling’’ view. When this is done,
code is clearly separated into two categories: ordinary code and error-handling code. This makes
code more comprehensible. Unfortunately, the real world isn’t so clear cut. Program organization
will (and to some extent should) reflect that.
Error handling is inherently difficult. Anything that helps preserve a clear model of what is an
error and how it is handled should be treasured.
14.6 Exception Specifications [except.spec]
Throwing or catching an exception affects the way a function relates to other functions. It can
therefore be worthwhile to specify the set of exceptions that might be thrown as part of the function
declaration. For example:
void f(int a) throw(x2, x3) ;
This specifies that f() may throw only exceptions x2, x3, and exceptions derived from these types,
but no others. When a function specifies what exceptions it might throw, it effectively offers a
guarantee to its callers. If during execution that function does something that tries to abrogate the
guarantee, the attempt will be transformed into a call of std: :unexpected(). The default meaning
of unexpected() is std: :terminate(), which in turn normally calls abort(); see §9.4.1.1 for
details.
In effect,
void f() throw(x2, x3)
{
/ / stuff
}
is equivalent to:
void f()
try
{
/ / stuff
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
376 Exception Handling Chapter 14
catch(x2) { throw; } / / re-throw
catch(x3) { throw; } / / re-throw
catch(...) {
std: :unexpected() ; / / unexpected() will not return
}
The most important advantage is that the function declaration belongs to an interface that is visible
to its callers. Function definitions, on the other hand, are not universally available. Even when we
do have access to the source code of all our libraries, we strongly prefer not to have to look at it
very often. In addition, a function with an exception-specification is shorter and clearer than the
equivalent hand-written version.
A function declared without an exception-specification is assumed to throw every exception.
For example:
int f() ; / / can throw any exception
A function that will throw no exceptions can be declared with an empty list:
int g() throw() ; / / no exception thrown
One might think that the default should be that a function throws no exceptions. However, that
would require exception specifications for essentially every function, would be a significant cause
for recompilation, and would inhibit cooperation with software written in other languages. This
would encourage programmers to subvert the exception-handling mechanisms and to write spurious
code to suppress exceptions. It would provide a false sense of security to people who failed to
notice the subversion.
14.6.1 Checking Exception Specifications [except.check.spec]
It is not possible to catch every violation of an interface specification at compile time. However,
much compile-time checking is done. The way to think about exception-specifications is to assume
that a function will throw any exception it can. The rules for compile-time checking exceptionspecifications outlaw easily detected absurdities.
If any declaration of a function has an exception-specification, every declaration of that function
(including the definition) must have an exception-specification with exactly the same set of exception types. For example:
int f() throw(std: :bad_alloc) ;
int f() / / error: exception-specification missing
{
/ / ...
}
Importantly, exception-specifications are not required to be checked exactly across compilation-unit
boundaries. Naturally, an implementation can check. However, for many large and long-lived systems, it is important that the implementation does not – or, if it does, that it carefully gives hard
errors only where violations will not be caught at run time.
The point is to ensure that adding an exception somewhere doesn’t force a complete update of
related exception specifications and a recompilation of all potentially affected code. A system can
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.6.1 Checking Exception Specifications 377
then function in a partially updated state relying on the dynamic (run-time) detection of unexpected
exceptions. This is essential for the maintenance of large systems in which major updates are
expensive and not all source code is accessible.
A virtual function may be overridden only by a function that has an exception-specification at
least as restrictive as its own (explicit or implicit) exception-specification. For example:
class B{
public:
virtual void f() ; / / can throw anything
virtual void g() throw(X,Y) ;
virtual void h() throw(X) ;
};
class D: public B{
public:
void f() throw(X) ; / / ok
void g() throw(X) ; / / ok: D::g() is more restrictive than B::g()
void h() throw(X,Y) ; / / error: D::h() is less restrictive than B::h()
};
This rule is really only common sense. If a derived class threw an exception that the original function didn’t advertise, a caller couldn’t be expected to catch it. On the other hand, an overriding
function that throws fewer exceptions clearly obeys the rule set out by the overridden function’s
exception-specification.
Similarly, you can assign a pointer to function that has a more restrictive exceptionspecification to a pointer to function that has a less restrictive exception-specification, but not vice
versa. For example:
void f() throw(X) ;
void(*pf1)() throw(X,Y) = &f; / / ok
void(*pf2)() throw() = &f; / / error: f() is less restrictive than pf2
In particular, you cannot assign a pointer to a function without an exception-specification to a
pointer to function that has one:
void g() ; / / might throw anything
void(*pf3)() throw(X) = &g; / / error: g() less restrictive than pf3
An exception-specification is not part of the type of a function and a typedefmay not contain one.
For example:
typedef void(*PF)() throw(X) ; / / error
14.6.2 Unexpected Exceptions [except.unexpected]
An exception-specification can lead to calls to unexpected(). Such calls are typically undesirable
except during testing. Such calls can be avoided through careful organization of exceptions and
specification of interfaces. Alternatively, calls to unexpected() can be intercepted and rendered
harmless.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
378 Exception Handling Chapter 14
A well-defined subsystem Y will often have all its exceptions derived from a class Yerr. For
example, given
class Some_Yerr: public Yerr{ /* ... */ };
a function declared
void f() throw(Xerr, Yerr, exception) ;
will pass any Yerron to its caller. In particular, f() would handle a Some_Yerrby passing it on to
its caller. Thus, no Yerrin f() will trigger unexpected().
All exceptions thrown by the standard library are derived from class exception(§14.10).
14.6.3 Mapping Exceptions [except.mapping]
Occasionally, the policy of terminating a program upon encountering an unexpected exception is
too Draconian. In such cases, the behavior of unexpected() must be modified into something
acceptable.
The simplest way of achieving that is to add the standard library exception std: :bad_exception
to an exception-specification. In that case, unexpected() will simply throw bad_exceptioninstead
of invoking a function to try to cope. For example:
class X{ };
class Y{ };
void f() throw(X,std: :bad_exception)
{
/ / ...
throw Y() ; / / throw ‘‘bad’’ exception
}
The exception-specification will catch the unacceptable exception Yand throw an exception of type
bad_exceptioninstead.
There is actually nothing particularly bad about bad_exception; it simply provides a mechanism that is less drastic than calling terminate(). However, it is still rather crude. In particular,
information about which exception caused the problem is lost.
14.6.3.1 User Mapping of Exceptions [except.user.mapping]
Consider a function g() written for a non-networked environment. Assume further that g() has
been declared with an exception-specification so that it will throw only exceptions related to its
‘‘subsystem Y:’’
void g() throw(Yerr) ;
Now assume that we need to call g() in a networked environment.
Naturally, g() will not know about network exceptions and will invoke unexpected() when it
encounters one. To use g() in a distributed environment, we must either provide code that handles
network exceptions or rewrite g(). Assuming a rewrite is infeasible or undesirable, we can handle
the problem by redefining the meaning of unexpected().
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.6.3.1 User Mapping of Exceptions 379
Memory exhaustion is dealt with by the _new_handlerdetermined by set_new_handler().
Similarly, the response to an unexpected exception is determined by an _unexpected_handlerset
by std: :set_unexpected() from <exception>:
typedef void(*unexpected_handler)() ;
unexpected_handler set_unexpected(unexpected_handler) ;
To handle unexpected exceptions well, we first define a class to allow us to use the ‘‘resource
acquisition is initialization’’ technique for unexpected() functions:
class STC{ / / store and reset class
unexpected_handler old;
public:
STC(unexpected_handler f) { old= set_unexpected(f) ; }
~STC() { set_unexpected(old) ; }
};
Then, we define a function with the meaning we want for unexpected() in this case:
class Yunexpected: Yerr{ };
void throwY() throw(Yunexpected) { throw Yunexpected() ; }
Used as an unexpected() function, throwY() maps any unexpected exception into Yunexpected.
Finally, we provide a version of g() to be used in the networked environment:
void networked_g() throw(Yerr)
{
STC xx(&throwY) ; / / now unexpected() throws Yunexpected
g() ;
}
Because Yunexpectedis derived from Yerr, the exception-specification is not violated. Had
throwY() thrown an exception that did violate the exception-specification, terminate() would
have been called.
By saving and restoring the _unexpected_handler, we make it possible for several subsystems
to control the handling of unexpected exceptions without interfering with each other. Basically,
this technique for mapping an unexpected exception into an expected one is a more flexible variant
of what the system offers in the form of bad_exception.
14.6.3.2 Recovering the Type of an Exception [except.recover]
Mapping unexpected exceptions to Yunexpectedwould allow a user of networked_g() to know
that an unexpected exception had been mapped into Yunexpected. However, such a user wouldn’t
know which exception had been mapped. That information was lost in throwY(). A simple technique allows that information to be recorded and passed on:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
380 Exception Handling Chapter 14
class Yunexpected: public Yerr{
public:
Network_exception* pe;
Yunexpected(Network_exception* p) :pe(p) { }
};
void throwY() throw(Yunexpected)
{
try{
throw; / / re-throw to be caught immediately!
}
catch(Network_exception& p) {
throw Yunexpected(&p) ; / / throw mapped exception
}
catch(...) {
throw Yunexpected(0) ;
}
}
Re-throwing an exception and catching it allows us to get a handle on any exception of a type we
can name. The throwY() function is called from unexpected(), which is conceptually called
from a catch(...) handler. There therefore is definitely an exception to re-throw. It is not possible for an unexpected() function to ignore the exception and return. If it tries to, unexpected()
itself will throw a bad_exception(§14.6.3).
14.7 Uncaught Exceptions [except.uncaught]
If an exception is thrown but not caught, the function std: :terminate() will be called. The terminate() function will also be called when the exception-handling mechanism finds the stack corrupted and when a destructor called during stack unwinding caused by an exception tries to exit
using an exception.
An unexpected exception is dealt with by the _unexpected_handlerdetermined by
set_unexpected(). Similarly, the response to an uncaught exception is determined by an
_uncaught_handlerset by std: :set_terminate() from <exception>:
typedef void(*terminate_handler)() ;
terminate_handler set_terminate(terminate_handler) ;
The return value is the previous function given to set_terminate().
The reason for terminate() is that exception handling must occasionally be abandoned for less
subtle error-handling techniques. For example, terminate() could be used to abort a process or
maybe to re-initialize a system. The intent is for terminate() to be a drastic measure to be applied
when the error-recovery strategy implemented by the exception-handling mechanism has failed and
it is time to go to another level of a fault tolerance strategy.
By default, terminate() will call abort() (§9.4.1.1). This default is the correct choice for
most users – especially during debugging.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.7 Uncaught Exceptions 381
An _uncaught_handleris assumed not to return to its caller. If it tries to, terminate() will
call abort().
Note that abort() indicates abnormal exit from the program. The function exit() can be used
to exit a program with a return value that indicates to the surrounding system whether the exit is
normal or abnormal (§9.4.1.1).
It is implementation-defined whether destructors are invoked when a program is terminated
because of an uncaught exception. On some systems, it is essential that the destructors are not
called so that the program can be resumed from the debugger. On other systems, it is architecturally close to impossible not to invoke the destructors while searching for a handler.
If you want to ensure cleanup when an uncaught exception happens, you can add a catch-all
handler (§14.3.2) to main() in addition to handlers for exceptions you really care about. For
example:
int main()
try{
/ / ...
}
catch(std: :range_error)
{
cerr<< "range error: Not again!\n";
}
catch(std: :bad_alloc)
{
cerr<< "new ran out of memory\n";
}
catch(...) {
/ / ...
}
This will catch every exception, except those thrown by construction and destruction of global variables. There is no way of catching exceptions thrown during initialization of global variables. The
only way of gaining control in case of throwfrom an initializer of a nonlocal static object is
set_unexpected() (§14.6.2). This is another reason to avoid global variables whenever possible.
When an exception is caught, the exact point where it was thrown is generally not known. This
represents a loss of information compared to what a debugger might know about the state of a program. In some C++ development environments, for some programs, and for some people, it might
therefore be preferable notto catch exceptions from which the program isn’t designed to recover.
14.8 Exceptions and Efficiency [except.efficiency]
In principle, exception handling can be implemented so that there is no run-time overhead when no
exception is thrown. In addition, this can be done so that throwing an exception isn’t all that
expensive compared to calling a function. Doing so without adding significant memory overhead
while maintaining compatibility with C calling sequences, debugger conventions, etc., is possible,
but hard. However, please remember that the alternatives to exceptions are not free either. It is not
unusual to find traditional systems in which half of the code is devoted to error handling.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
382 Exception Handling Chapter 14
Consider a simple function f() that appears to have nothing to do with exception handling:
void g(int) ;
void f()
{
string s;
/ / ...
g(1) ;
g(2) ;
}
However, g() may throw an exception, so f() must contain code ensuring that sis destroyed correctly in case of an exception. However, had g() not thrown an exception it would have had to
report its error some other way. Consequently, the comparable code using ordinary code to handle
errors instead of exceptions isn’t the plain code above, but something like:
bool g(int) ;
bool f()
{
string s;
/ / ...
if(g(1))
if(g(2))
return true;
else
return false;
else
return false;
}
People don’t usually handle errors this systematically, though, and it is not always critical to do so.
However, when careful and systematic handling of errors is necessary, such housekeeping is best
left to a computer, that is, to the exception-handling mechanisms.
Exception-specifications (§14.6) can be most helpful in improving generated code. Had we
stated that g() didn’t throw an exception:
void g(int) throw() ;
the code generation for f() could have been improved. It is worth observing that no traditional C
function throws an exception, so in most programs every C function can be declared with the empty
throw specification throw(). In particular, an implementation knows that only a few standard C
library functions (such as atexit() and qsort()) can throw exceptions, and it can take advantage of
that fact to generate better code.
Before giving a ‘‘C function’’ an empty exception-specification, throw(), take a minute to
consider if it could possibly throw an exception. For example, it might have been converted to use
the C++ operator new, which can throw bad_alloc, or it might call a C++ library that throws an
exception.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.9 Error-Handling Alternatives 383
14.9 Error-Handling Alternatives [except.alternatives]
The purpose of the exception-handling mechanisms is to provide a means for one part of a program
to inform another part of a program that an ‘‘exceptional circumstance’’ has been detected. The
assumption is that the two parts of the program are written independently and that the part of the
program that handles the exception often can do something sensible about the error.
To use handlers effectively in a program, we need an overall strategy. That is, the various parts
of the program must agree on how exceptions are used and where errors are dealt with. The
exception-handling mechanisms are inherently nonlocal, so adherence to an overall strategy is
essential. This implies that the error-handling strategy is best considered in the earliest phases of a
design. It also implies that the strategy must be simple (relative to the complexity of the total program) and explicit. Something complicated would not be consistently adhered to in an area as
inherently tricky as error recovery.
First of all, the idea that a single mechanism or technique can handle all errors must be dispelled; it would lead to complexity. Successful fault-tolerant systems are multilevel. Each level
copes with as many errors as it can without getting too contorted and leaves the rest to higher levels. The notion of terminate() is intended to support this view by providing an escape if the
exception-handling mechanism itself is corrupted or if it has been incompletely used, thus leaving
exceptions uncaught. Similarly, the notion of unexpected() is intended to provide an escape when
the strategy using exception-specifications to provide firewalls fails.
Not every function should be a firewall. In most systems, it is not feasible to write every function to do sufficient checking to ensure that it either completes successfully or fails in a welldefined manner. The reasons that this will not work varies from program to program and from programmer to programmer. However, for larger programs:
[1] The amount of work needed to ensure this notion of ‘‘reliability’’ is too great to be done
consistently.
[2] The overheads in time and space are too great for the system to run acceptably (there will be
a tendency to check for the same errors, such as invalid arguments, over and over again).
[3] Functions written in other languages won’t obey the rules.
[4] This purely local notion of ‘‘reliability’’ leads to complexities that actually become a burden
to overall system reliability.
However, separating the program into distinct subsystems that either complete successfully or fail
in well-defined ways is essential, feasible, and economical. Thus, a major library, subsystem, or
key function should be designed in this way. Exception specifications are intended for interfaces to
such libraries and subsystems.
Usually, we don’t have the luxury of designing all of the code of a system from scratch. Therefore, to impose a general error-handling strategy on all parts of a program, we must take into
account program fragments implemented using strategies different from ours. To do this we must
address a variety of concerns relating to the way a program fragment manages resources and the
state in which it leaves the system after an error. The aim is to have the program fragment appear
to follow the general error-handling strategy even if it internally follows a different strategy.
Occasionally, it is necessary to convert from one style of error reporting to another. For example, we might check errnoand possibly throw an exception after a call to a C library or, conversely,
catch an exception and set errnobefore returning to a C program from a C++ library:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
384 Exception Handling Chapter 14
void callC() throw(C_blewit)
{
errno= 0;
c_function() ;
if(errno) {
/ / cleanup, if possible and necessary
throw C_blewit(errno) ;
}
}
extern"C" void call_from_C() throw()
{
try{
c_plus_plus_function() ;
}
catch(...) {
/ / cleanup, if possible and necessary
errno= E_CPLPLFCTBLEWIT;
}
}
In such cases, it is important to be systematic enough to ensure that the conversion of error reporting styles is complete.
Error handling should be – as far as possible – hierarchical. If a function detects a run-time
error, it should not ask its caller for help with recovery or resource acquisition. Such requests set
up cycles in the system dependencies. That in turn makes the program hard to understand and
introduces the possibility of infinite loops in the error-handling and recovery code.
Simplifying techniques such as ‘‘resource acquisition is initialization’’ and simplifying assumptions such as ‘‘exceptions represent errors’’ should be used to make the error-handling code more
regular. See also §24.3.7.1 for ideas about how to use invariants and assertions to make the triggering of exceptions more regular.
14.10 Standard Exceptions [except.std]
Here is a table of standard exceptions and the functions, operators, and general facilities that throw
them: _________________________________________________________________
_________________________________________________________________ Standard Exceptions (thrown by the language) _________________________________________________________________
_________________________________________________________________ Name Thrown by Reference Header
bad_alloc new §6.2.6.2, §19.4.5 <new>
bad_cast dynamic_cast §15.4.1.1 <typeinfo>
bad_typeid typeid §15.4.4 <typeinfo>
_________________________________________________________________ bad_exception exception specification §14.6.3 <exception> 














The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.10 Standard Exceptions 385
_ ________________________________________________________________________
_ ________________________________________________________________________ Standard Exceptions (thrown by the standard library) _ ________________________________________________________________________
_ ________________________________________________________________________ Name Thrown by Reference Header
out_of_range at() §3.7.2, §16.3.3, §20.3.3 <stdexcept>
bitset<>::operator[]() §17.5.3 <stdexcept>
invalid_argument bitset constructor §17.5.3.1 <stdexcept>
overflow_error bitset<>::to_ulong() §17.5.3.3 <stdexcept>
_ ________________________________________________________________________ ios_base::failure ios_base::clear() §21.3.6 <ios>

















The library exceptions are part of a class hierarchy rooted in the standard library exception class
exceptionpresented in <exception>:
class exception{
public:
exception() throw() ;
exception(const exception&) throw() ;
exception& operator=(const exception&) throw() ;
virtual~exception() throw() ;
virtual const char* what() const throw() ;
private:
/ / ...
};
The hierarchy looks like this:
exception
logic_error runtime_error
length_error
domain_error
out_of_range
invalid_argument
range_error
overflow_error
underflow_error
bad_alloc
bad_exception
bad_cast
bad_typeid
ios_base::failure
.
This seems rather elaborate for organizing the eight standard exceptions. This hierarchy attempts to
provide a framework for exceptions beyond the ones defined by the standard library. Logic errors
are errors that in principle could be caught either before the program starts executing or by tests of
arguments to functions and constructors. Run-time errors are all other errors. Some people view
this as a useful framework for all errors and exceptions; I don’t.
The standard library exception classes don’t add functions to the set provided by exception;
they simply define the required virtual functions appropriately. Thus, we can write:
void f()
try{
/ / use standard library
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
386 Exception Handling Chapter 14
catch(exception& e) {
cout<< "standard library exception" << e.what() << ´\n´; / / well, maybe
/ / ...
}
catch(...) {
cout<< "other exception\n";
/ / ...
}
The standard exceptions are derived from exception. However, not every exception is, so it would
be a mistake to try to catch every exception by catching exception. Similarly, it would be a mistake to assume that every exception derived from exceptionis a standard library exception: programmers can add their own exceptions to the exceptionhierarchy .
Note that exceptionoperations do not themselves throw exceptions. In particular, this implies
that throwing a standard library exception doesn’t cause a bad_allocexception. The exceptionhandling mechanism keeps a bit of memory to itself for holding exceptions (possibly on the stack).
Naturally, it is possible to write code that eventually consumes all memory in the system, thus forcing a failure.
Here is a function that – if called – tests whether the function call or the exception-handling
mechanism runs out of memory first:
void perverted()
{
try{
throw exception() ; / / recursive exception throw
}
catch(exception& e) {
perverted() ; / / recursive function call
cout<< e.what() ;
}
}
The purpose of the output statement is simply to prevent the compiler from re-using the memory
occupied by the exception named e.
14.11 Advice [except.advice]
[1] Use exceptions for error handling; §14.1, §14.5, §14.9.
[2] Don’t use exceptions where more local control structures will suffice; §14.1.
[3] Use the ‘‘resource allocation is initialization’’ technique to manage resources; §14.4.
[4] Not every program needs to be exception safe; §14.4.3.
[5] Use ‘‘resource allocation is initialization’’ and exception handlers to maintain invariants;
§14.3.2.
[6] Minimize the use of try-blocks. Use ‘‘resource acquisition is initialization’’ instead of explicit
handler code; §14.4.
[7] Not every function needs to handle every possible error; §14.9.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 14.11 Advice 387
[8] Throw an exception to indicate failure in a constructor; §14.4.6.
[9] Avoid throwing exceptions from copy constructors; §14.4.6.1.
[10] Avoid throwing exceptions from destructors; §14.4.7.
[11] Have main() catch and report all exceptions; §14.7.
[12] Keep ordinary code and error-handling code separate; §14.4.5, §14.5.
[13] Be sure that every resource acquired in a constructor is released when throwing an exception
in that constructor; §14.4.
[14] Keep resource management hierarchical; §14.4.
[15] Use exception-specifications for major interfaces; §14.9.
[16] Beware of memory leaks caused by memory allocated by newnot being released in case of an
exception; §14.4.1, §14.4.2, §14.4.4.
[17] Assume that every exception that can be thrown by a function will be thrown; §14.6.
[18] Don’t assume that every exception is derived from class exception; §14.10.
[19] A library shouldn’t unilaterally terminate a program. Instead, throw an exception and let a
caller decide; §14.1.
[20] A library shouldn’t produce diagnostic output aimed at an end user. Instead, throw an exception and let a caller decide; §14.1.
[21] Develop an error-handling strategy early in a design; §14.9.
14.12 Exercises [except.exercises]
1. (∗2) Generalize the STCclass (§14.6.3.1) to a template that can use the ‘‘resource acquisition is
initialization’’ technique to store and reset functions of a variety of types.
2. (∗3) Complete the Ptr_to_Tclass from §11.11 as a template that uses exceptions to signal runtime errors.
3. (∗3) Write a function that searches a binary tree of nodes based on a char* field for a match. If
a node containing hellois found, find("hello") will return a pointer to that node. Use an
exception to indicate ‘‘not found.’’
4. (∗3) Define a class Intthat acts exactly like the built-in type int, except that it throws exceptions
rather than overflowing or underflowing.
5. (∗2.5) Take the basic operations for opening, closing, reading, and writing from the C interface
to your operating system and provide equivalent C++ functions that call the C functions but
throw exceptions in case of errors.
6. (∗2.5) Write a complete Vectortemplate with Rangeand Sizeexceptions.
7. (∗1) Write a loop that computes the sum of a Vectoras defined in §14.12[6] without examining
the size of the Vector. Why is this a bad idea?
8. (∗2.5) Consider using a class Exceptionas the base of all classes used as exceptions. What
should it look like? How should it be used? What good might it do? What disadvantages
might result from a requirement to use such a class?
9. (∗1) Given a
int main() { /* ... */ }
change it so that it catches all exceptions, turns them into error messages, and abort()s. Hint:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
388 Exception Handling Chapter 14
call_from_C() in §14.9 doesn’t quite handle all cases.
10. (∗2) Write a class or template suitable for implementing callbacks.
11. (∗2.5) Write a Lockclass for some system supporting concurrency.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
15 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
Class Hierarchies
Abstraction is selective ignorance.
– Andrew Koenig
Multiple inheritance — ambiguity resolution — inheritance and using-declarations —
replicated base classes — virtual base classes — uses of multiple inheritance — access
control — protected — access to base classes — run-time type information —
dynamic_cast— static and dynamic casts — casting from virtual bases — typeid—
extended type information — uses and misuses of run-time type information — pointers
to members — free store — virtual constructors — advice — exercises.
15.1 Introduction and Overview [hier.intro]
This chapter discusses how derived classes and virtual functions interact with other language facilities such as access control, name lookup, free store management, constructors, pointers, and type
conversions. It has five main parts:
§15.2 Multiple Inheritance
§15.3 Access Control
§15.4 Run-time Type Identification
§15.5 Pointers to Members
§15.6 Free Store Use
In general, a class is constructed from a lattice of base classes. Because most such lattices historically have been trees, a class lattice is often called a class hierarchy. We try to design classes so
that users need not be unduly concerned about the way a class is composed out of other classes. In
particular, the virtual call mechanism ensures that when we call a function f() on an object, the
same function is called whichever class in the hierarchy provided the declaration of f() used for
the call. This chapter focuses on ways to compose class lattices and to control access to parts of
classes and on facilities for navigating class lattices at compile time and run time.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
390 Class Hierarchies Chapter 15
15.2 Multiple Inheritance [hier.mi]
As shown in §2.5.4 and §12.3, a class can have more than one direct base class, that is, more than
one class specified after the : in the class declaration. Consider a simulation in which concurrent
activities are represented by a class Taskand data gathering and display is achieved through a class
Displayed. We can then define a class of simulated entities, class Satellite:
class Satellite: public Task, public Displayed{
/ / ...
};
The use of more than one immediate base class is usually called multiple inheritance. In contrast,
having just one direct base class is called single inheritance.
In addition to whatever operations are defined specifically for a Satellite, the union of operations on Tasks and Displayeds can be applied. For example:
void f(Satellite& s)
{
s.draw() ; / / Displayed::draw()
s.delay(10) ; / / Task::delay()
s.transmit() ; / / Satellite::transmit()
}
Similarly, a Satellitecan be passed to functions that expect a Taskor a Displayed. For example:
void highlight(Displayed*) ;
void suspend(Task*) ;
void g(Satellite* p)
{
highlight(p) ; / / pass a pointer to the Displayed part of the Satellite
suspend(p) ; / / pass a pointer to the Task part of the Satellite
}
The implementation of this clearly involves some (simple) compiler technique to ensure that functions expecting a Tasksee a different part of a Satellitethan do functions expecting a Displayed.
Virtual functions work as usual. For example:
class Task{
/ / ...
virtual void pending() = 0;
};
class Displayed{
/ / ...
virtual void draw() = 0;
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.2 Multiple Inheritance 391
class Satellite: public Task, public Displayed{
/ / ...
void pending() ; / / override Task::pending()
void draw() ; / / override Displayed::draw()
};
This ensures that Satellite: :draw() and Satellite: :pending() will be called for a Satellite
treated as a Displayedand a Task, respectively.
Note that with single inheritance (only), the programmer’s choices for implementing the classes
Displayed, Task, and Satellitewould be limited. A Satellitecould be a Taskor a Displayed, but
not both (unless Taskwas derived from Displayedor vice versa). Either alternative involves a loss
of flexibility.
Why would anyone want a class Satellite? Contrary to some people’s conjectures, the Satellite
example is real. There really was – and maybe there still is – a program constructed along the
lines used to describe multiple inheritance here. It was used to study the design of communication
systems involving satellites, ground stations, etc. Given such a simulation, we can answer questions about traffic flow, determine proper responses to a ground station that is being blocked by a
rainstorm, consider tradeoffs between satellite connections and Earth-bound connections, etc. Such
simulations do involve a variety of display and debugging operations. Also, we do need to store
the state of objects such as Satellites and their subcomponents for analysis, debugging, and error
recovery.
15.2.1 Ambiguity Resolution [hier.ambig]
Two base classes may have member functions with the same name. For example:
class Task{
/ / ...
virtual debug_info* get_debug() ;
};
class Displayed{
/ / ...
virtual debug_info* get_debug() ;
};
When a Satelliteis used, these functions must be disambiguated:
void f(Satellite* sp)
{
debug_info* dip= sp->get_debug() ; / / error: ambiguous
dip= sp->Task: :get_debug() ; / / ok
dip= sp->Displayed: :get_debug() ; / / ok
}
However, explicit disambiguation is messy, so it is usually best to resolve such problems by defining a new function in the derived class:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
392 Class Hierarchies Chapter 15
class Satellite: public Task, public Displayed{
/ / ...
debug_info* get_debug() / / override Task::get_debug() and Displayed::get_debug()
{
debug_info* dip1= Task: :get_debug() ;
debug_info* dip2= Displayed: :get_debug() ;
return dip1->merge(dip2) ;
}
};
This localizes the information about Satellite’s base classes. Because Satellite: :get_debug()
overrides the get_debug() functions from both of its base classes, Satellite: :get_debug() is
called wherever get_debug() is called for a Satelliteobject.
A qualified name Telstar: :drawcan refer to a drawdeclared either in Telstaror in one of its
base classes. For example:
class Telstar: public Satellite{
/ / ...
void draw()
{
draw() ; / / oops!: recursive call
Satellite: :draw() ; / / finds Displayed::draw
Displayed: :draw() ;
Satellite: :Displayed: :draw() ; / / redundant double qualification
}
};
In other words, if a Satellite: :drawdoesn’t resolve to a drawdeclared in Satellite, the compiler
recursively looks in its base classes; that is, it looks for Task: :drawand Displayed: :draw. If
exactly one match is found, that name will be used. Otherwise, Satellite: :drawis either not found
or is ambiguous.
15.2.2 Inheritance and Using-Declarations [hier.using]
Overload resolution is not applied across different class scopes (§7.4). In particular, ambiguities
between functions from different base classes are not resolved based on argument types.
When combining essentially unrelated classes, such as Taskand Displayedin the Satellite
example, similarity in naming typically does not indicate a common purpose. When such name
clashes occur, they often come as quite a surprise to the programmer. For example:
class Task{
/ / ...
void debug(double p) ; / / print info only if priority is lower than p
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.2.2 Inheritance and Using-Declarations 393
class Displayed{
/ / ...
void debug(int v) ; / / the higher the ‘v,’ the more debug information is printed
};
class Satellite: public Task, public Displayed{
/ / ...
};
void g(Satellite* p)
{
p->debug(1) ; / / error: ambiguous. Displayed::debug(int) or Task::debug(double) ?
p->Task: :debug(1) ; / / ok
p->Displayed: :debug(1) ; / / ok
}
What if the use of the same name in different base classes was the result of a deliberate design decision and the user wanted selection based on the argument types? In that case, a using-declaration
(§8.2.2) can bring the functions into a common scope. For example:
class A{
public:
int f(int) ;
char f(char) ;
/ / ...
};
class B{
public:
double f(double) ;
/ / ...
};
class AB: public A, public B{
public:
using A: :f;
using B: :f;
char f(char) ; / / hides A::f(char)
AB f(AB) ;
};
void g(AB& ab)
{
ab.f(1) ; / / A::f(int)
ab.f(´a´) ; / / AB::f(char)
ab.f(2.0) ; / / B::f(double)
ab.f(ab) ; / / AB::f(AB)
}
Using-declarations allow a programmer to compose a set of overloaded functions from base classes
and the derived class. Functions declared in the derived class hide functions that would otherwise
be available from a base. Virtual functions from bases can be overridden as ever (§15.2.3.1).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
394 Class Hierarchies Chapter 15
A using-declaration (§8.2.2) in a class definition must refer to members of a base class. A
using-declaration may not be used for a member of a class from outside that class, its derived
classes, and their member functions. A using-directive (§8.2.3) may not appear in a class definition
and may not be used for a class.
A using-declaration cannot be used to gain access to additional information. It is simply a
mechanism for making accessible information more convenient to use (§15.3.2.2).
15.2.3 Replicated Base Classes [hier.replicated]
With the ability of specifying more than one base class comes the possibility of having a class as a
base twice. For example, had Taskand Displayedeach been derived from a Linkclass, a Satellite
would have two Links:
struct Link{
Link* next;
};
class Task: public Link{
/ / the Link is used to maintain a list of all Tasks (the scheduler list)
/ / ...
};
class Displayed: public Link{
/ / the Link is used to maintain a list of all Displayed objects (the display list)
/ / ...
};
This causes no problems. Two separate Linkobjects are used to represent the links, and the two
lists do not interfere with each other. Naturally, one cannot refer to members of the Linkclass
without risking an ambiguity (§15.2.3.1). A Satelliteobject could be drawn like this:
Link Link
Task Displayed
Satellite
.
Examples of where the common base class shouldn’t be represented by two separate objects can be
handled using a virtual base class (§15.2.4).
Usually, a base class that is replicated the way Linkis here is an implementation detail that
shouldn’t be used from outside its immediate derived class. If such a base must be referred to from
a point where more than one copy of the base is visible, the reference must be explicitly qualified to
resolve the ambiguity. For example:
void mess_with_links(Satellite* p)
{
p->next= 0; / / error: ambiguous (which Link?)
p->Link: :next= 0; / / error: ambiguous (which Link?)
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.2.3 Replicated Base Classes 395
p->Task: :Link: :next= 0; / / ok
p->Displayed: :Link: :next= 0; / / ok
/ / ...
}
This is exactly the mechanism used to resolve ambiguous references to members (§15.2.1).
15.2.3.1 Overriding [hier.override]
A virtual function of a replicated base class can be overridden by a (single) function in a derived
class. For example, one might represent the ability of an object to read itself from a file and write
itself back to a file like this:
class Storable{
public:
virtual const char* get_file() = 0;
virtual void read() = 0;
virtual void write() = 0;
virtual~Storable() { write() ; } / / to be called from overriding destructors (see §15.2.4.1)
};
Naturally, several programmers might rely on this to develop classes that can be used independently or in combination to build more elaborate classes. For example, one way of stopping and
restarting a simulation is to store components of a simulation and then restore them later. That idea
might be implemented like this:
class Transmitter: public Storable{
public:
void write() ;
/ / ...
};
class Receiver: public Storable{
public:
void write() ;
/ / ...
};
class Radio: public Transmitter, public Receiver{
public:
const char* get_file() ;
void read() ;
void write() ;
/ / ...
};
Typically, an overriding function calls its base class versions and then does the work specific to the
derived class:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
396 Class Hierarchies Chapter 15
void Radio: :write()
{
Transmitter: :write() ;
Receiver: :write() ;
/ / write radio-specific information
}
Casting from a replicated base class to a derived class is discussed in §15.4.2. For a technique for
overriding each of the write() functions with separate functions from derived classes, see §25.6.
15.2.4 Virtual Base Classes [hier.vbase]
The Radioexample in the previous subsection works because class Storablecan be safely, conveniently, and efficiently replicated. Often, that is not the case for the kind of class that makes a good
building block for other classes. For example, we might define Storableto hold the name of the
file to be used for storing the object:
class Storable{
public:
Storable(const char* s) ;
virtual void read() = 0;
virtual void write() = 0;
virtual~Storable() ;
private:
const char* store;
Storable(const Storable&) ;
Storable& operator=(const Storable&) ;
};
Given this apparently minor change to Storable, we must must change the design of Radio. All
parts of an object must share a single copy of Storable; otherwise, it becomes unnecessarily hard to
avoid storing multiple copies of the object. One mechanism for specifying such sharing is a virtual
base class. Every virtualbase of a derived class is represented by the same (shared) object. For
example:
class Transmitter: public virtual Storable{
public:
void write() ;
/ / ...
};
class Receiver: public virtual Storable{
public:
void write() ;
/ / ...
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.2.4 Virtual Base Classes 397
class Radio: public Transmitter, public Receiver{
public:
void write() ;
/ / ...
};
Or graphically:
Storable
Receiver Transmitter
Radio
.
Compare this diagram with the drawing of the Satelliteobject in §15.2.3 to see the difference
between ordinary inheritance and virtual inheritance. In an inheritance graph, every base class of a
given name that is specified to be virtual will be represented by a single object of that class. On the
other hand, each base class not specified virtualwill have its own sub-object representing it.
15.2.4.1 Programming Virtual Bases [hier.vbase.prog]
When defining the functions for a class with a virtual base, the programmer in general cannot know
whether the base will be shared with other derived classes. This can be a problem when implementing a service that requires a base class function to be called exactly once. For example, the
language ensures that a constructor of a virtual base is called exactly once. The constructor of a
virtual base is invoked (implicitly or explicitly) from the constructor for the complete object (the
constructor for the most derived class). For example:
class A{ / / no constructor
/ / ...
};
class B{
public:
B() ; / / default constructor
/ / ...
};
class C{
public:
C(int) ; / / no default constructor
};
class D: virtual public A, virtual public B, virtual public C
{
D() { /* ... */ } / / error: no default constructor for C
D(int i) : C(i) { /* ... */ }; / / ok
/ / ...
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
398 Class Hierarchies Chapter 15
The constructor for a virtual base is called before the constructors for its derived classes.
Where needed, the programmer can simulate this scheme by calling a virtual base class function
only from the most derived class. For example, assume we have a basic Windowclass that knows
how to draw its contents:
class Window{
/ / basic stuff
virtual void draw() ;
};
In addition, we have various ways of decorating a window and adding facilities:
class Window_with_border: public virtual Window{
/ / border stuff
void own_draw() ; / / display the border
void draw() ;
};
class Window_with_menu: public virtual Window{
/ / menu stuff
void own_draw() ; / / display the menu
void draw() ;
};
The own_draw() functions need not be virtual because they are meant to be called from within a
virtual draw() function that ‘‘knows’’ the type of the object for which it was called.
From this, we can compose a plausible Clockclass:
class Clock: public Window_with_border, public Window_with_menu{
/ / clock stuff
void own_draw() ; / / display the clock face and hands
void draw() ;
};
Or graphically:
Window
Window_with_border Window_with_menu
Clock
.
The draw() functions can now be written using the own_draw() functions so that a caller of any
draw() gets Window: :draw() invoked exactly once. This is done independently of the kind of
Windowfor which draw() is invoked:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.2.4.1 Programming Virtual Bases 399
void Window_with_border: :draw()
{
Window: :draw() ;
own_draw() ; / / display the border
}
void Window_with_menu: :draw()
{
Window: :draw() ;
own_draw() ; / / display the menu
}
void Clock: :draw()
{
Window: :draw() ;
Window_with_border: :own_draw() ;
Window_with_menu: :own_draw() ;
own_draw() ; / / display the clock face and hands
}
Casting from a virtualbase class to a derived class is discussed in §15.4.2.
15.2.5 Using Multiple Inheritance [hier.using.mi]
The simplest and most obvious use of multiple inheritance is to ‘‘glue’’ two otherwise unrelated
classes together as part of the implementation of a third class. The Satelliteclass built out of the
Taskand Displayedclasses in §15.2 is an example of this. This use of multiple inheritance is
crude, effective, and important, but not very interesting. Basically, it saves the programmer from
writing a lot of forwarding functions. This technique does not affect the overall design of a program significantly and can occasionally clash with the wish to keep implementation details hidden.
However, a technique doesn’t have to be clever to be useful.
Using multiple inheritance to provide implementations for abstract classes is more fundamental
in that it affects the way a program is designed. Class BB_ival_slider(§12.3) is an example:
class BB_ival_slider
: public Ival_slider/ / interface
, protected BBslider/ / implementation
{
/ / implementation of functions required by ‘Ival_slider’ and ‘BBslider’
/ / using the facilities provided by ‘BBslider’
};
In this example, the two base classes play logically distinct roles. One base is a public abstract
class providing the interface and the other is a protected concrete class providing implementation
‘‘details.’’ These roles are reflected in both the style of the classes and in the access control provided. The use of multiple inheritance is close to essential here because the derived class needs to
override virtual functions from both the interface and the implementation.
Multiple inheritance allows sibling classes to share information without introducing a dependence on a unique common base class in a program. This is the case in which the so-called
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
400 Class Hierarchies Chapter 15
diamond-shaped inheritance occurs (for example, the Radio(§15.2.4) and Clock(§15.2.4.1)). A
virtual base class, as opposed to an ordinary base class, is needed if the base class cannot be replicated.
I find that a diamond-shaped inheritance lattice is most manageable if either the virtual base
class or the classes directly derived from it are abstract classes. For example, consider again the
Ival_boxclasses from §12.4. In the end, I made all the Ival_boxclasses abstract to reflect their
role as pure interfaces. Doing that allowed me to place all implementation details in specific implementation classes. Also, all sharing of implementation details was done in the classical hierarchy
of the windows system used for the implementation.
It would make sense for the class implementing a Popup_ival_sliderto share most of the
implementation of the class implementing a plain Ival_slider. After all, these implementation
classes would share everything except the handling of prompts. However, it would then seem natural to avoid replication of Ival_sliderobjects within the resulting slider implementation objects.
Therefore, we could make Ival_slidera virtual base:
class BB_ival_slider: public virtual Ival_slider, protected BBslider{ /* ... */ };
class Popup_ival_slider: public virtual Ival_slider{ /* ... */ };
class BB_popup_ival_slider
: public virtual Popup_ival_slider, protected BB_ival_slider{ /* ... */ };
or graphically:
Ival_slider
Popup_ival_slider BB_ival_slider
BB_popup_ival_slider
BBslider
.
It is easy to imagine further interfaces derived from Popup_ival_sliderand further implementation
classes derived from such classes and BB_popup_slider.
If we take this idea to its logical conclusion, all of the derivations from the abstract classes that
constitute our application’s interfaces would become virtual. This does indeed seem to be the most
logical, general, and flexible approach. The reason I didn’t do that was partly historical and partly
because the most obvious and common techniques for implementing virtual bases impose time and
space overhead that make their extensive use within a class unattractive. Should this overhead
become an issue for an otherwise attractive design, note that an object representing an Ival_slider
usually holds only a virtual table pointer. As noted in §15.2.4, such an abstract class holding no
variable data can be replicated without ill effects. Thus, we can eliminate the virtual base in favor
of ordinary ones:
class BB_ival_slider: public Ival_slider, protected BBslider{ /* ... */ };
class Popup_ival_slider: public Ival_slider{ /* ... */ };
class BB_popup_ival_slider
: public Popup_ival_slider, protected BB_ival_slider{ /* ... */ };
or graphically:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.2.5 Using Multiple Inheritance 401
Ival_sliderIval_slider
Popup_ival_slider BB_ival_slider
BB_popup_ival_slider
BBslider
.
This is most likely a viable optimization to the admittedly cleaner alternative presented previously.
15.2.5.1 Overriding Virtual Base Functions [hier.dominance]
A derived class can override a virtual function of its direct or indirect virtual base class. In particular, two different classes might override different virtual functions from the virtual base. In that
way, several derived classes can contribute implementations to the interface presented by a virtual
base class. For example, the Windowclass might have functions set_color() and prompt(). In
that case, Window_with_bordermight override set_color() as part of controlling the color
scheme and Window_with_menumight override prompt() as part of its control of user interactions:
class Window{
/ / ...
virtual set_color(Color) = 0; / / set background color
virtual void prompt() = 0;
};
class Window_with_border: public virtual Window{
/ / ...
set_color(Color) ; / / control background color
};
class Window_with_menu: public virtual Window{
/ / ...
void prompt() ; / / control user interactions
};
class My_window: public Window_with_menu, public Window_with_border{
/ / ...
};
What if different derived classes override the same function? This is allowed if and only if some
overriding class is derived from every other class that overrides the function. That is, one function
must override all others. For example, My_windowcould override prompt() to improve on what
Window_with_menuprovides:
class My_window: public Window_with_menu, public Window_with_border{
/ / ...
void prompt() ; / / don’t leave user interactions to base
};
or graphically:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
402 Class Hierarchies Chapter 15
Window{ set_color(), prompt() }
Window_with_border{ set_color() } Window_with_menu{ prompt() }
My_window{ prompt() }
If two classes override a base class function, but neither overrides the other, the class hierarchy is
an error. No virtual function table can be constructed because a call to that function on the complete object would have been ambiguous. For example, had Radioin §15.2.4 not declared
write(), the declarations of write() in Receiverand Transmitterwould have caused an error
when defining Radio. As with Radio, such a conflict is resolved by adding an overriding function
to the most derived class.
A class that provides some – but not all – of the implementation for a virtual base class is often
called a ‘‘mixin.’’
15.3 Access Control [hier.access]
A member of a class can be private, protected, or public:
– If it is private, its name can be used only by member functions and friends of the class in
which it is declared.
– If it is protected, its name can be used only by member functions and friends of the class in
which it is declared and by member functions and friends of classes derived from this class
(see §11.5).
– If it is public, its name can be used by any function.
This reflects the view that there are three kinds of functions accessing a class: functions implementing the class (its friends and members), functions implementing a derived class (the derived class’
friends and members), and other functions. This can be presented graphically:
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ..
.
.
.
.
.
.
.
.
.
. .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
.
.
.
.
.
.
.
.
.
public:
protected:
private:
general users
derived class’ member functions and friends
own member functions and friends
The access control is applied uniformly to names. What a name refers to does not affect the control
of its use. This means that we can have private member functions, types, constants, etc., as well as
private data members. For example, an efficient non-intrusive (§16.2.1) list class often requires
data structures to keep track of elements. Such information is best kept private:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.3 Access Control 403
template<class T> class List{
private:
struct Link{ T val; Link* next; };
struct Chunk{
enum{ chunk_size= 15};
Link v[chunk_size] ;
Chunk* next;
};
class Underflow{ };
Chunk* allocated;
Link* free;
Link* get_free() ;
Link* head;
public:
void insert(T) ;
T get() ;
/ / ...
};
template<class T> void List<T>: :insert(T val)
{
Link* lnk= get_free() ;
lnk->val= val;
lnk->next= head;
head= lnk;
}
template<class T> List<T>: :Link* List<T>: :get_free()
{
if(free== 0) {
/ / allocate a new chunk and place its Links on the free list
}
Link* p= free;
free= free->next;
return p;
}
template<class T> T List<T>: :get()
{
if(head== 0) throw Underflow() ;
Link* p= head;
head= p->next;
p->next= free;
free= p;
return p->val;
}
The List<T> scope is entered by saying List<T>: : in a member function definition. Because the
return type of get_free() is mentioned before the name List<T>: :get_free() is mentioned, the
full name List<T>: :Linkmust be used instead of the abbreviation Link<T>.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
404 Class Hierarchies Chapter 15
Nonmember functions (except friends) do not have such access:
void would_be_meddler(List<T>* p)
{
List<T>: :Link* q= 0; / / error: List<T>::Link is private
/ / ...
q= p->free; / / error: List<T>::free is private
/ / ...
if(List<T>: :Chunk: :chunk_size> 31) { / / error: List<T>::Chunk::chunk_size is private
/ / ...
}
}
In a class, a member is by default private; in a struct, a member is by default public (§10.2.8).
15.3.1 Protected Members [hier.protected]
As an example of how to use protectedmembers, consider the Windowexample from §15.2.4.1.
The own_draw() functions were (deliberately) incomplete in the service they provided. They
were designed as building blocks for use by derived classes (only) and are not safe or convenient
for general use. The draw() operations, on the other hand, were designed for general use. This
distinction can be expressed by separating the interface of the Windowclasses in two, the protected
interface and the publicinterface:
class Window_with_border{
public:
virtual void draw() ;
/ / ...
protected:
void own_draw() ;
/ / other tool-building stuff
private:
/ / representation, etc.
};
A derived class can access a base class’ protected members only for objects of its own type:
class Buffer{
protected:
char a[128] ;
/ / ...
};
class Linked_buffer: public Buffer{ /* ... */ };
class Cyclic_buffer: public Buffer{
/ / ...
void f(Linked_buffer* p) {
a[0] = 0; / / ok: access to cyclic_buffer’s own protected member
p->a[0] = 0; / / error: access to protected member of different type
}
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.3.1 Protected Members 405
This prevents subtle errors that would otherwise occur when one derived class corrupts data
belonging to other derived classes.
15.3.1.1 Use of Protected Members [hier.protected.use]
The simple private/public model of data hiding serves the notion of concrete types (§10.3) well.
However, when derived classes are used, there are two kinds of users of a class: derived classes and
‘‘the general public.’’ The members and friends that implement the operations on the class operate
on the class objects on behalf of these users. The private/public model allows the programmer to
distinguish clearly between the implementers and the general public, but it does not provide a way
of catering specifically to derived classes.
Members declared protectedare far more open to abuse than members declared private. In
particular, declaring data members protected is usually a design error. Placing significant amounts
of data in a common class for all derived classes to use leaves that data open to corruption. Worse,
protected data, like public data, cannot easily be restructured because there is no good way of finding every use. Thus, protected data becomes a software maintenance problem.
Fortunately, you don’t have to use protected data; privateis the default in classes and is usually
the better choice. In my experience, there have always been alternatives to placing significant
amounts of information in a common base class for derived classes to use directly.
Note that none of these objections are significant for protected member functions; protectedis a
fine way of specifying operations for use in derived classes. The Ival_sliderin §12.4.2 is an example of this. Had the implementation class been privatein this example, further derivation would
have been infeasible.
Technical examples illustrating access to members can be found in §C.11.1.
15.3.2 Access to Base Classes [hier.base.access]
Like a member, a base class can be declared private, protected, or public. For example:
class X: public B{ /* ... */ };
class Y: protected B{ /* ... */ };
class Z: private B{ /* ... */ };
Public derivation makes the derived class a subtype of its base; this is the most common form of
derivation. Protected and private derivation are used to represent implementation details. Protected
bases are useful in class hierarchies in which further derivation is the norm; the Ival_sliderfrom
§12.4.2 is a good example of that. Private bases are most useful when defining a class by restricting the interface to a base so that stronger guarantees can be provided. For example, Vecadds
range checking to its private base vector(§3.7.1) and the listof pointers template adds type checking to its list<void*> base (§13.5).
The access specifier for a base class can be left out. In that case, the base defaults to a private
base for a classand a public base for a struct. For example:
class XX: B{ /* ... */ }; / / B is a private base
struct YY: B{ /* ... */ }; / / B is a public base
For readability, it is best always to use an explicit access specifier.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
406 Class Hierarchies Chapter 15
The access specifier for a base class controls the access to members of the base class and the
conversion of pointers and references from the derived class type to the base class type. Consider a
class Dderived from a base class B:
– If Bis a privatebase, its public and protected members can be used only by member functions and friends of D. Only friends and members of Dcan convert a D* to a B*.
– If Bis a protectedbase, its public and protected members can be used only by member
functions and friends of Dand by member functions and friends of classes derived from D.
Only friends and members of Dand friends and members of classes derived from Dcan
convert a D* to a B*.
– If Bis a publicbase, its public members can be used by any function. In addition, its protected members can be used by members and friends of Dand members and friends of
classes derived from D. Any function can convert a D* to a B*.
This basically restates the rules for member access (§15.3). We choose access for bases in the same
way as for members. For example, I chose to make BBwindowa protectedbase of Ival_slider
(§12.4.2) because BBwindowwas part of the implementation of Ival_sliderrather than part of its
interface. However, I couldn’t completely hide BBwindowby making it a private base because I
wanted to be able to derive further classes from Ival_slider, and those derived classes would need
access to the implementation.
Technical examples illustrating access to bases can be found in §C.11.2.
15.3.2.1 Multiple Inheritance and Access Control [hier.mi.access]
If a name or a base class can be reached through multiple paths in a multiple inheritance lattice, it is
accessible if it is accessible through any path. For example:
struct B{
int m;
static int sm;
/ / ...
};
class D1: public virtual B{ /* ... */ } ;
class D2: public virtual B{ /* ... */ } ;
class DD: public D1, private D2{ /* ... */ };
DD* pd= new DD;
B* pb= pd; / / ok: accessible through D1
int i1= pd->m; / / ok: accessible through D1
If a single entity is reachable through several paths, we can still refer to it without ambiguity. For
example:
class X1: public B{ /* ... */ } ;
class X2: public B{ /* ... */ } ;
class XX: public X1, public X2{ /* ... */ };
XX* pxx= new XX;
int i1= pxx->m; / / error, ambiguous: XX::X1::B::m or XX::X2::B::m
int i2= pxx->sm; / / ok: there is only one B::sm in an XX
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.3.2.1 Multiple Inheritance and Access Control 407
15.3.2.2 Using-Declarations and Access Control [hier.access.using]
A using-declaration cannot be used to gain access to additional information. It is simply a mechanism for making accessible information more convenient to use. On the other hand, once access is
available, it can be granted to other users. For example:
class B{
private:
int a;
protected:
int b;
public:
int c;
};
class D: public B{
public:
using B: :a; / / error: B::a is private
using B: :b; / / make B::b publically available through D
};
When a using-declaration is combined with private or protected derivation, it can be used to specify interfaces to some, but not all, of the facilities usually offered by a class. For example:
class BB: private B{ / / give access to B::b and B::c, but not B::a
using B: :b;
using B: :c;
};
See also §15.2.2.
15.4 Run-Time Type Information [hier.rtti]
A plausible use of the Ival_boxes defined in §12.4 would be to hand them to a system that controlled a screen and have that system hand objects back to the application program whenever some
activity had occurred. This is how many user-interfaces work. However, a user-interface system
will not know about our Ival_boxes. The system’s interfaces will be specified in terms of the
system’s own classes and objects rather than our application’s classes. This is necessary and
proper. However, it does have the unpleasant effect that we lose information about the type of
objects passed to the system and later returned to us.
Recovering the ‘‘lost’’ type of an object requires us to somehow ask the object to reveal its
type. Any operation on an object requires us to have a pointer or reference of a suitable type for the
object. Consequently, the most obvious and useful operation for inspecting the type of an object at
run time is a type conversion operation that returns a valid pointer if the object is of the expected
type and a null pointer if it isn’t. The dynamic_castoperator does exactly that. For example,
assume that ‘‘the system’’ invokes my_event_handler() with a pointer to a BBwindow, where an
activity has occurred. I then might invoke my application code using Ival_box’s do_something():
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
408 Class Hierarchies Chapter 15
void my_event_handler(BBwindow* pw)
{
if(Ival_box* pb= dynamic_cast<Ival_box*>(pw)) / / does pw point to an Ival_box?
pb->do_something() ;
else{
/ / Oops! unexpected event
}
}
One way of explaining what is going on is that dynamic_casttranslates from the implementationoriented language of the user-interface system to the language of the application. It is important to
note what is not mentioned in this example: the actual type of the object. The object will be a particular kind of Ival_box, say an Ival_slider, implemented by a particular kind of BBwindow, say a
BBslider. It is neither necessary nor desirable to make the actual type of the object explicit in this
interaction between ‘‘the system’’ and the application. An interface exists to represent the essentials of an interaction. In particular, a well-designed interface hides inessential details.
Graphically, the action of
pb= dynamic_cast<Ival_box*>(pw)
can be represented like this:
BBwindow
BBslider
Ival_box
Ival_slider
BB_ival_slider
pw pb
. .
. . . . . . . . . . . . . . . . . . . . . .
The arrows from pwand pbrepresent the pointers into the object passed, whereas the rest of the
arrows represent the inheritance relationships between the different parts of the object passed.
The use of type information at run time is conventionally referred to as ‘‘run-time type information’’ and often abbreviated to RTTI.
Casting from a base class to a derived class is often called a downcast because of the convention
of drawing inheritance trees growing from the root down. Similarly, a cast from a derived class to
a base is called an upcast. A cast that goes from a base to a sibling class, like the cast from BBwindowto Ival_box, is called a crosscast.
15.4.1 Dynamic_cast [hier.dynamic.cast]
The dynamic_castoperator takes two operands, a type bracketed by < and >, and a pointer or reference bracketed by ( and ).
Consider first the pointer case:
dynamic_cast<T*>(p)
If pis of type T* or an accessible base class of T, the result is exactly as if we had simply assigned
pto a T*. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.4.1 Dynamic_cast 409
class BB_ival_slider: public Ival_slider, protected BBslider{
/ / ...
};
void f(BB_ival_slider* p)
{
Ival_slider* pi1= p; / / ok
Ival_slider* pi2= dynamic_cast<Ival_slider*>(p) ; / / ok
BBslider* pbb1= p; / / error: BBslider is a protected base
BBslider* pbb2= dynamic_cast<BBslider*>(p) ; / / ok: pbb2 becomes 0
}
That is the uninteresting case. However, it is reassuring to know that dynamic_castdoesn’t allow
accidental violation of the protection of private and protected base classes.
The purpose of dynamic_castis to deal with the case in which the correctness of the conversion
cannot be determined by the compiler. In that case,
dynamic_cast<T*>(p)
looks at the object pointed to by p(if any). If that object is of class Tor has a unique base class of
type T, then dynamic_castreturns a pointer of type T* to that object; otherwise, 0is returned. If
the value of pis 0, dynamic_cast<T*>(p) returns 0. Note the requirement that the conversion
must be to a uniquely identified object. It is possible to construct examples where the conversion
fails and 0is returned because the object pointed to by phas more than one sub-object representing
bases of type T(see §15.4.2).
A dynamic_castrequires a pointer or a reference to a polymorphic type to do a downcast or a
crosscast. For example:
class My_slider: public Ival_slider{ / / polymorphic base (Ival_slider has virtual functions)
/ / ...
};
class My_date: public Date{ / / base not polymorphic (Date has no virtual functions)
/ / ...
};
void g(Ival_box* pb, Date* pd)
{
My_slider* pd1= dynamic_cast<My_slider*>(pb) ; / / ok
My_date* pd2= dynamic_cast<My_date*>(pd) ; / / error: Date not polymorphic
}
Requiring the pointer’s type to be polymorphic simplifies the implementation of dynamic_cast
because it makes it easy to find a place to hold the necessary information about the object’s type. A
typical implementation will attach a ‘‘type information object’’ to an object by placing a pointer to
the type information in the object’s virtual function table (§2.5.5). For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
410 Class Hierarchies Chapter 15
...
vptr
...
"My_box"
bases. .
"Ival_slider"
. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . .
vtbl:
My_box:
type_info:
type_info:
The dashed arrow represents an offset that allows the start of the complete object to be found given
only a pointer to a polymorphic sub-object. It is clear that dynamic_castcan be efficiently implemented. All that is involved are a few comparisons of type_infoobjects representing base classes;
no expensive lookups or string comparisons are needed.
Restricting dynamic_castto polymorphic types also makes sense from a logical point of view.
This is, if an object has no virtual functions, it cannot safely be manipulated without knowledge of
its exact type. Consequently, care should be taken not to get such an object into a context in which
its type isn’t known. If its type is known, we don’t need to use dynamic_cast.
The target type of dynamic_castneed not be polymorphic. This allows us to wrap a concrete
type in a polymorphic type, say for transmission through an object I/O system (see §25.4.1), and
then ‘‘unwrap’’ the concrete type later. For example:
class Io_obj{ / / base class for object I/O system
virtual Io_obj* clone() = 0;
};
class Io_date: public Date, public Io_obj{ };
void f(Io_obj* pio)
{
Date* pd= dynamic_cast<Date*>(pio) ;
/ / ...
}
A dynamic_castto void* can be used to determine the address of the beginning of an object of
polymorphic type. For example:
void g(Ival_box* pb, Date* pd)
{
void* pd1= dynamic_cast<void*>(pb) ; / / ok
void* pd2= dynamic_cast<void*>(pd) ; / / error: Date not polymorphic
}
This is only useful for interaction with very low-level functions.
15.4.1.1 Dynamic_cast of References [hier.re.cast]
To get polymorphic behavior, an object must be manipulated through a pointer or a reference.
When a dynamic_castis used for a pointer type, a 0indicates failure. That is neither feasible nor
desirable for references.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.4.1.1 Dynamic_cast of References 411
Given a pointer result, we must consider the possibility that the result is 0; that is, that the
pointer doesn’t point to an object. Consequently, the result of a dynamic_castof a pointer should
always be explicitly tested. For a pointer p, dynamic_cast<T*>(p) can be seen as the question,
‘‘Is the object pointed to by pof type T?’’
On the other hand, we may legitimately assume that a reference refers to an object. Consequently, dynamic_cast<T&>(r) of a reference ris not a question but an assertion: ‘‘The object
referred to by ris of type T.’’ The result of a dynamic_castfor a reference is implicitly tested by
the implementation of dynamic_castitself. If the operand of a dynamic_castto a reference isn’t of
the expected type, a bad_castexception is thrown. For example:
void f(Ival_box* p, Ival_box& r)
{
if(Ival_slider* is= dynamic_cast<Ival_slider*>(p)) { / / does p point to an Ival_slider?
/ / use ‘is’
}
else{
/ / *p not a slider
}
Ival_slider& is= dynamic_cast<Ival_slider&>(r) ; / / r references an Ival_slider!
/ / use ‘is’
}
The difference in results of a failed dynamic pointer cast and a failed dynamic reference cast
reflects a fundamental difference between references and pointers. If a user wants to protect against
bad casts to references, a suitable handler must be provided. For example:
void g()
{
try{
f(new BB_ival_slider,*new BB_ival_slider) ; / / arguments passed as Ival_boxs
f(new BBdial,*new BBdial) ; / / arguments passed as Ival_boxs
}
catch(bad_cast) { / / §14.10
/ / ...
}
}
The first call to f() will return normally, while the second will cause a bad_castexception that
will be caught by g().
Explicit tests against 0can be – and therefore occasionally will be – accidentally omitted. If
that worries you, you can write a conversion function that throws an exception instead returning 0
(§15.8[1]) in case of failure.
15.4.2 Navigating Class Hierarchies [hier.navigate]
When only single inheritance is used, a class and its base classes constitute a tree rooted in a single
base class. This is simple but often constraining. When multiple inheritance is used, there is no
single root. This in itself doesn’t complicate matters much. However, if a class appears more than
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
412 Class Hierarchies Chapter 15
once in a hierarchy, we must be a bit careful when we refer to the object or objects that represent
that class.
Naturally, we try to keep hierarchies as simple as our application allows (and no simpler).
However, once a nontrivial hierarchy has been made we soon need to navigate it to find an appropriate class to use as an interface. This need occurs in two variants. That is, sometimes, we want to
explicitly name an object of a base class or a member of a base class; §15.2.3 and §15.2.4.1 are
examples of this. At other times, we want to get a pointer to the object representing a base or
derived class of an object given a pointer to a complete object or some sub-object; §15.4 and
§15.4.1 are examples of this.
Here, we consider how to navigate a class hierarchy using type conversions (casts) to gain a
pointer of the desired type. To illustrate the mechanisms available and the rules that guide them,
consider a lattice containing both a replicated base and a virtual base:
class Component: public virtual Storable{ /* ... */ };
class Receiver: public Component{ /* ... */ };
class Transmitter: public Component{ /* ... */ };
class Radio: public Receiver, public Transmitter{ /* ... */ };
Or graphically:
Storable
Component Component
Receiver Transmitter
Radio
.
Here, a Radioobject has two sub-objects of class Component. Consequently, a dynamic_cast
from Storableto Componentwithin a Radiowill be ambiguous and return a 0. There is simply no
way of knowing which Componentthe programmer wanted:
void h1(Radio& r)
{
Storable* ps= &r;
/ / ...
Component* pc= dynamic_cast<Component*>(ps) ; / / pc = 0
}
This ambiguity is not in general detectable at compile time:
void h2(Storable* ps) / / ps might or might not point to a Component
{
Component* pc= dynamic_cast<Component*>(ps) ;
/ / ...
}
This kind of run-time ambiguity detection is needed only for virtual bases. For ordinary bases,
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.4.2 Navigating Class Hierarchies 413
there is always a unique sub-object of a given cast (or none) when downcasting (that is, towards a
derived class; §15.4). The equivalent ambiguity occurs when upcasting (that is, towards a base;
§15.4) and such ambiguities are caught at compile time.
15.4.2.1 Static and Dynamic Casts [hier.static.cast]
A dynamic_castcan cast from a polymorphic virtual base class to a derived class or a sibling class
(§15.4.1). A static_cast(§6.2.7) does not examine the object it casts from, so it cannot:
void g(Radio& r)
{
Receiver* prec= &r; / / Receiver is ordinary base of Radio
Radio* pr= static_cast<Radio*>(prec) ; / / ok, unchecked
pr= dynamic_cast<Radio*>(prec) ; / / ok, run-time checked
Storable* ps= &r; / / Storable is virtual base of Radio
pr= static_cast<Radio*>(ps) ; / / error: cannot cast from virtual base
pr= dynamic_cast<Radio*>(ps) ; / / ok, run-time checked
}
The dynamic_castrequires a polymorphic operand because there is no information stored in a nonpolymorphic object that can be used to find the objects for which it represents a base. In particular,
an object of a type with layout constraints determined by some other language – such as Fortran or
C – may be used as a virtual base class. For objects of such types, only static type information will
be available. However, the information needed to provide run-time type identification includes the
information needed to implement the dynamic_cast.
Why would anyone want to use a static_castfor class hierarchy navigation? There is a small
run-time cost associated with the use of a dynamic_cast(§15.4.1). More significantly, there are
millions of lines of code that were written before dynamic_castbecame available. This code relies
on alternative ways of making sure that a cast is valid, so the checking done by dynamic_castis
seen as redundant. However, such code is typically written using the C-style cast (§6.2.7); often
obscure errors remain. Where possible, use the safer dynamic_cast.
The compiler cannot assume anything about the memory pointed to by a void*. This implies
that dynamic_cast– which must look into an object to determine its type – cannot cast from a
void*. For that, a static_castis needed. For example:
Radio* f(void* p)
{
Storable* ps= static_cast<Storable*>(p) ; / / trust the programmer
return dynamic_cast<Radio*>(ps) ;
}
Both dynamic_castand static_castrespect constand access controls. For example:
class Users: private set<Person> { /* ... */ };
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
414 Class Hierarchies Chapter 15
void f(Users* pu, const Receiver* pcr)
{
static_cast<set<Person>*>(pu) ; / / error: access violation
dynamic_cast<set<Person>*>(pu) ; / / error: access violation
static_cast<Receiver*>(pcr) ; / / error: can’t cast away const
dynamic_cast<Receiver*>(pcr) ; / / error: can’t cast away const
Receiver* pr= const_cast<Receiver*>(pcr) ; / / ok
/ / ...
}
It is not possible to cast to a private base class, and ‘‘casting away const’’ requires a const_cast
(§6.2.7). Even then, using the result is safe only provided the object wasn’t originally declared
const(§10.2.7.1) .
15.4.3 Class Object Construction and Destruction [hier.class.obj]
A class object is more than simply a region of memory (§4.9.6). A class object is built from ‘‘raw
memory’’ by its constructors and it reverts to ‘‘raw memory’’ as its destructors are executed. Construction is bottom up, destruction is top down, and a class object is an object to the extent that it
has been constructed or destroyed. This is reflected in the rules for RTTI, exception handling
(§14.4.7), and virtual functions.
It is extremely unwise to rely on details of the order of construction and destruction, but that
order can be observed by calling virtual functions, dynamic_cast, or typeid(§15.4.4) at a point
where the object isn’t complete. For example, if the constructor for Componentin the hierarchy
from §15.4.2 calls a virtual function, it will invoke a version defined for Storableor Component,
but not one from Receiver, Transmitter, or Radio. At that point of construction, the object isn’t
yet a Radio; it is merely a partially constructed object. It is best to avoid calling virtual functions
during construction and destruction.
15.4.4 Typeid and Extended Type Information [hier.typeid]
The dynamic_castoperator serves most needs for information about the type of an object at run
time. Importantly, it ensures that code written using it works correctly with classes derived from
those explicitly mentioned by the programmer. Thus, dynamic_castpreserves flexibility and
extensibility in a manner similar to virtual functions.
However, it is occasionally essential to know the exact type of an object. For example, we
might like to know the name of the object’s class or its layout. The typeidoperator serves this purpose by yielding an object representing the type of its operand. Had typeid() been a function, its
declaration would have looked something like this:
class type_info;
const type_info& typeid(type_name) throw(bad_typeid) ; / / pseudo declaration
const type_info& typeid(expression) ; / / pseudo declaration
That is, typeid() returns a reference to a standard library type called type_infodefined in <typeinfo>. Given a type-name as its operand, typeid() returns a reference to a type_infothat represents the type-name. Given an expression as its operand, typeid() returns a reference to a
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.4.4 Typeid and Extended Type Information 415
type_infothat represents the type of the object denoted by the expression. A typeid() is most
commonly used to find the type of an object referred to by a reference or a pointer:
void f(Shape& r, Shape* p)
{
typeid(r) ; / / type of object referred to by r
typeid(*p) ; / / type of object pointed to by p
typeid(p) ; / / type of pointer, that is, Shape* (uncommon, except as a mistake)
}
If the value of a pointer or a reference operand is 0, typeid() throws a bad_typeidexception.
The implementation-independent part of type_infolooks like this:
class type_info{
public:
virtual~type_info() ; / / is polymorphic
bool operator==(const type_info&) const; / / can be compared
bool operator!=(const type_info&) const;
bool before(const type_info&) const; / / ordering
const char* name() const; / / name of type
private:
type_info(const type_info&) ; / / prevent copying
type_info& operator=(const type_info&) ; / / prevent copying
/ / ...
};
The before() function allows type_infos to be sorted. There is no relation between the relationships defined by beforeand inheritance relationships.
It is not guaranteed that there is only one type_infoobject for each type in the system. In fact,
where dynamically linked libraries are used it can be hard for an implementation to avoid duplicate
type_infoobjects. Consequently, we should use == on type_infoobjects to test equality, rather
than == on pointers to such objects.
We sometimes want to know the exact type of an object so as to perform some standard service
on the whole object (and not just on some base of the object). Ideally, such services are presented
as virtual functions so that the exact type needn’t be known. In some cases, no common interface
can be assumed for every object manipulated, so the detour through the exact type becomes necessary (§15.4.4.1). Another, much simpler, use has been to obtain the name of a class for diagnostic
output:
#include<typeinfo>
void g(Component* p)
{
cout<< typeid(*p).name() ;
}
The character representation of a class’ name is implementation-defined. This C-style string
resides in memory owned by the system, so the programmer should not attempt to delete[] it.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
416 Class Hierarchies Chapter 15
15.4.4.1 Extended Type Information [hier.extended]
Typically, finding the exact type of an object is simply the first step to acquiring and using moredetailed information about that type.
Consider how an implementation or a tool could make information about types available to
users at run time. Suppose I have a tool that generates descriptions of object layouts for each class
used. I can put these descriptors into a mapto allow user code to find the layout information:
map<const char*, Layout> layout_table;
void f(B* p)
{
Layout& x= layout_table[typeid(*p).name()] ;
/ / use x
}
Someone else might provide a completely different kind of information:
struct TI_eq{
bool operator()(const type_info* p, const type_info* q) { return*p==*q; }
};
struct TI_hash{
int operator()(const type_info* p) ; / / compute hash value (§17.6.2.2)
};
hash_map<type_info*,Icon,hash_fct,TI_hash,TI_eq> icon_table; / / §17.6
void g(B* p)
{
Icon& i= icon_table[&typeid(*p)] ;
/ / use i
}
This way of associating typeids with information allows several people or tools to associate different information with types totally independently of each other:
"T"
... object
layout
. . . . . . . . . . . . . . . . . . . . . . . . . .
layout_table:
. . ...
&typeid(T)
...
icon
representation
of
type
. . . . . . . . . . . . . . . . . . . . . . .
icon_table:
This is most important because the likelihood is zero that someone can come up with a single set of
information that satisfies every user.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.4.5 Uses and Misuses of RTTI 417
15.4.5 Uses and Misuses of RTTI [hier.misuse]
One should use explicit run-time type information only when necessary. Static (compile-time)
checking is safer, implies less overhead, and – where applicable – leads to better-structured programs. For example, RTTI can be used to write thinly disguised switch-statements:
/ / misuse of run-time type information:
void rotate(const Shape& r)
{
if(typeid(r) == typeid(Circle)) {
/ / do nothing
}
else if(typeid(r) == typeid(Triangle)) {
/ / rotate triangle
}
else if(typeid(r) == typeid(Square)) {
/ / rotate square
}
/ / ...
}
Using dynamic_castrather than typeidwould improve this code only marginally.
Unfortunately, this is not a strawman example; such code really does get written. For many
people trained in languages such as C, Pascal, Modula-2, and Ada, there is an almost irresistible
urge to organize software as a set of switch-statements. This urge should usually be resisted. Use
virtual functions (§2.5.5, §12.2.6) rather than RTTI to handle most cases when run-time discrimination based on type is needed.
Many examples of proper use of RTTI arise when some service code is expressed in terms of
one class and a user wants to add functionality through derivation. The use of Ival_boxin §15.4 is
an example of this. If the user is willing and able to modify the definitions of the library classes,
say BBwindow, then the use of RTTI can be avoided; otherwise, it is needed. Even if the user is
willing to modify the base classes, such modification may cause its own problems. For example, it
may be necessary to introduce dummy implementations of virtual functions in classes for which
those functions are not needed or not meaningful. This problem is discussed in some detail in
§24.4.3. A use of RTTI to implement a simple object I/O system can be found in §25.4.1.
For people with a background in languages that rely heavily on dynamic type checking, such as
Smalltalk or Lisp, it is tempting to use RTTI in conjunction with overly general types. Consider:
/ / misuse of run-time type information:
class Object{ /* ... */ }; / / polymorphic
class Container: public Object{
public:
void put(Object*) ;
Object* get() ;
/ / ...
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
418 Class Hierarchies Chapter 15
class Ship: public Object{ /* ... */ };
Ship* f(Ship* ps, Container* c)
{
c->put(ps) ;
/ / ...
Object* p= c->get() ;
if(Ship* q= dynamic_cast<Ship*>(p)) { / / run-time check
return q;
}
else{
/ / do something else (typically, error handling)
}
}
Here, class Objectis an unnecessary implementation artifact. It is overly general because it does
not correspond to an abstraction in the application domain and forces the application programmer
to use an implementation-level abstraction. Problems of this kind are often better solved by using
container templates that hold only a single kind of pointer:
Ship* f(Ship* ps, list<Ship*>& c)
{
c.push_front(ps) ;
/ / ...
return c.pop_front() ;
}
Combined with the use of virtual functions, this technique handles most cases.
15.5 Pointers to Members [hier.ptom]
Many classes provide simple, very general interfaces intended to be invoked in several different
ways. For example, many ‘‘object-oriented’’ user-interfaces define a set of requests to which every
object represented on the screen should be prepared to respond. In addition, such requests can be
presented directly or indirectly from programs. Consider a simple variant of this idea:
class Std_interface{
public:
virtual void start() = 0;
virtual void suspend() = 0;
virtual void resume() = 0;
virtual void quit() = 0;
virtual void full_size() = 0;
virtual void small() = 0;
virtual~Std_interface() {}
};
The exact meaning of each operation is defined by the object on which it is invoked. Often, there is
a layer of software between the person or program issuing the request and the object receiving it.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.5 Pointers to Members 419
Ideally, such intermediate layers of software should not have to know anything about the individual
operations such as resume() and full_size(). If they did, the intermediate layers would have to
be updated each time the set of operations changed. Consequently, such intermediate layers simply
transmit some data representing the operation to be invoked from the source of the request to its
recipient.
One simple way of doing that is to send a stringrepresenting the operation to be invoked. For
example, to invoke suspend() we could send the string "suspend". However, someone has to create that string and someone has to decode it to determine to which operation it corresponds – if
any. Often, that seems indirect and tedious. Instead, we might simply send an integer representing
the operation. For example, 2might be used to mean suspend(). However, while an integer may
be convenient for machines to deal with, it can get pretty obscure for people. We still have to write
code to determine that 2means suspend() and to invoke suspend().
C++ offers a facility for indirectly referring to a member of a class. A pointer to a member is a
value that identifies a member of a class. You can think of it as the position of the member in an
object of the class, but of course an implementation takes into account the differences between data
members, virtual functions, non-virtual functions, etc.
Consider Std_interface. If I want to invoke suspend() for some object without mentioning
suspend() directly, I need a pointer to member referring to Std_interface: :suspend(). I also
need a pointer or reference to the object I want to suspend. Consider a trivial example:
typedef void(Std_interface: :* Pstd_mem)() ; / / pointer to member type
void f(Std_interface* p)
{
Pstd_mem s= &Std_interface: :suspend;
p->suspend() ; / / direct call
(p->*s)() ; / / call through pointer to member
}
A pointer to member can be obtained by applying the address-of operator & to a fully qualified
class member name, for example, &Std_interface: :suspend. A variable of type ‘‘pointer to member of class X’’ is declared using a declarator of the form X: :*.
The use of typedefto compensate for the lack of readability of the C declarator syntax is typical. However, please note how the X: :* declarator matches the traditional * declarator exactly.
A pointer to member mcan be used in combination with an object. The operators ->* and .*
allow the programmer to express such combinations. For example, p->*mbinds mto the object
pointed to by p, and obj.*mbinds mto the object obj. The result can be used in accordance with
m’s type. It is not possible to store the result of a ->* or a .* operation for later use.
Naturally, if we knew which member we wanted to call we would invoke it directly rather than
mess with pointers to members. Just like ordinary pointers to functions, pointers to member functions are used when we need to refer to a function without having to know its name. However, a
pointer to member isn’t a pointer to a piece of memory the way a pointer to a variable or a pointer
to a function is. It is more like an offset into a structure or an index into an array. When a pointer
to member is combined with a pointer to an object of the right type, it yields something that identifies a particular member of a particular object.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
420 Class Hierarchies Chapter 15
This can be represented graphically like this:
X::start
. . X::suspend
vtbl:
s
. . .
.
.
.
p.
Because a pointer to a virtual member (sin this example) is a kind of offset, it does not depend on
an object’s location in memory. A pointer to a virtual member can therefore safely be passed
between different address spaces as long as the same object layout is used in both. Like pointers to
ordinary functions, pointers to non-virtual member functions cannot be exchanged between address
spaces.
Note that the function invoked through the pointer to function can be virtual. For example,
when we call suspend() through a pointer to function, we get the right suspend() for the object to
which the pointer to function is applied. This is an essential aspect of pointers to functions.
An interpreter might use pointers to members to invoke functions presented as strings:
map<string,Std_interface*> variable;
map<string,Pstd_mem> operation;
void call_member(string var, string oper)
{
(variable[var]->*operation[oper])() ; / / var.oper()
}
A critical use of pointers to member functions is found in mem_fun() (§3.8.5, §18.4).
A static member isn’t associated with a particular object, so a pointer to a static member is simply an ordinary pointer. For example:
class Task{
/ / ...
static void schedule() ;
};
void(*p)() = &Task: :schedule; / / ok
void(Task: :* pm)() = &Task: :schedule; / / error: ordinary pointer assigned
/ / to pointer to member
Pointers to data members are described in §C.12.
15.5.1 Base and Derived Classes [hier.contravariance]
A derived class has at least the members that it inherits from its base classes. Often it has more.
This implies that we can safely assign a pointer to a member of a base class to a pointer to a member of a derived class, but not the other way around. This property is often called contravariance.
For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.5.1 Base and Derived Classes 421
class text: public Std_interface{
public:
void start() ;
void suspend() ;
/ / ...
virtual void print() ;
private:
vector s;
};
void(Std_interface: :* pmi)() = &text: :print; / / error
void(text: :*pmt)() = &Std_interface: :start; / / ok
This contravariance rule appears to be the opposite of the rule that says we can assign a pointer to a
derived class to a pointer to its base class. In fact, both rules exist to preserve the fundamental
guarantee that a pointer may never point to an object that doesn’t at least have the properties that
the pointer promises. In this case, Std_interface: :* can be applied to any Std_interface, and most
such objects presumably are not of type text. Consequently, they do not have the member
text: :printwith which we tried to initialize pmi. By refusing the initialization, the compiler saves
us from a run-time error.
15.6 Free Store [hier.free]
It is possible to take over memory management for a class by defining operator new() and operator delete() (§6.2.6.2). However, replacing the global operator new() and operator delete() is
not for the fainthearted. After all, someone else might rely on some aspect of the default behavior
or might even have supplied other versions of these functions.
A more selective, and often better, approach is to supply these operations for a specific class.
This class might be the base for many derived classes. For example, we might like to have the
Employeeclass from §12.2.6 provide a specialized allocator and deallocator for itself and all of its
derived classes:
class Employee{
/ / ...
public:
/ / ...
void* operator new(size_t) ;
void operator delete(void*, size_t) ;
};
Member operator new()s and operator delete()s are implicitly staticmembers. Consequently,
they don’t have a thispointer and do not modify an object. They provide storage that a constructor
can initialize and a destructor can clean up.
void* Employee: :operator new(size_t s)
{
/ / allocate ‘s’ bytes of memory and return a pointer to it
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
422 Class Hierarchies Chapter 15
void Employee: :operator delete(void* p, size_t s)
{
/ / assume ‘p’ points to ‘s’ bytes of memory allocated by Employee::operator new()
/ / and free that memory for reuse
}
The use of the hitherto mysterious size_targument now becomes obvious. It is the size of the
object actually deleted. Deleting a ‘‘plain’’ Employeegives an argument value of
sizeof(Employee); deleting a Managergives an argument value of sizeof(Manager). This
allows a class-specific allocator to avoid storing size information with each allocation. Naturally, a
class-specific allocator can store such information (like a general-purpose allocator must) and
ignore the size_targument to operator delete(). However, that makes it harder to improve significantly on the speed and memory consumption of a general-purpose allocator.
How does a compiler know how to supply the right size to operator delete()? As long as the
type specified in the deleteoperation matches the actual type of the object, this is easy. However,
that is not always the case:
class Manager: public Employee{
int level;
/ / ...
};
void f()
{
Employee* p= new Manager; / / trouble (the exact type is lost)
delete p;
}
In this case, the compiler will not get the size right. As when an array is deleted, the user must help.
This is done by adding a virtual destructor to the base class, Employee:
class Employee{
public:
void* operator new(size_t) ;
void operator delete(void*, size_t) ;
virtual~Employee() ;
/ / ...
};
Even an empty destructor will do:
Employee: :~Employee() { }
In principle, deallocation is then done from within the destructor (which knows the size). Furthermore, the presence of a destructor in Employeeensures that every class derived from it will be supplied with a destructor (thus getting the size right), even if the derived class doesn’t have a userdefined destructor. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.6 Free Store 423
void f()
{
Employee* p= new Manager;
delete p; / / now fine (Employee is polymorphic)
}
Allocation is done by a (compiler-generated) call:
Employee: :operator new(sizeof(Manager))
and deallocation by a (compiler-generated) call:
Employee: :operator delete(p,sizeof(Manager))
In other words, if you want to supply an allocator/deallocator pair that works correctly for derived
classes, you must either supply a virtual destructor in the base class or refrain from using the size_t
argument in the deallocator. Naturally, the language could have been designed to save you from
such concerns. However, that can be done only by also ‘‘saving’’ you from the benefits of the optimizations possible in the less safe system.
15.6.1 Array Allocation [hier.array]
The operator new() and operator delete() functions allow a user to take over allocation and
deallocation of individual objects; operator new[]() and operator delete[]() serve exactly the
same role for the allocation and deallocation of arrays. For example:
class Employee{
public:
void* operator new[](size_t) ;
void operator delete[](void*, size_t) ;
/ / ...
};
void f(int s)
{
Employee* p= new Employee[s] ;
/ / ...
delete[] p;
}
Here, the memory needed will be obtained by a call,
Employee: :operator new[](sizeof(Employee)*s+delta)
where deltais some minimal implementation-defined overhead, and released by a call:
Employee: :operator delete[](p,s*sizeof(Employee)+delta)
The number of elements (s) is ‘‘remembered’’ by the system.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
424 Class Hierarchies Chapter 15
15.6.2 “Virtual Constructors” [hier.vctor]
After hearing about virtual destructors, the obvious question is, ‘‘Can constructors be virtual?’’
The short answer is no; a slightly longer one is, no, but you can easily get the effect you are looking
for.
To construct an object, a constructor needs the exact type of the object it is to create. Consequently, a constructor cannot be virtual. Furthermore, a constructor is not quite an ordinary function. In particular, it interacts with memory management routines in ways ordinary member functions don’t. Consequently, you cannot have a pointer to a constructor.
Both of these restrictions can be circumvented by defining a function that calls a constructor
and returns a constructed object. This is fortunate because creating a new object without knowing
its exact type is often useful. The Ival_box_maker(§12.4.4) is an example of a class designed
specifically to do that. Here, I present a different variant of that idea, where objects of a class can
provide users with a clone (copy) of themselves or a new object of their type. Consider:
class Expr{
public:
Expr() ; / / default constructor
Expr(const Expr&) ; / / copy constructor
virtual Expr* new_expr() { return new Expr() ; }
virtual Expr* clone() { return new Expr(*this) ; }
/ / ...
};
Because functions such as new_expr() and clone() are virtual and they (indirectly) construct
objects, they are often called ‘‘virtual constructors’’ – by a strange misuse of the English language.
Each simply uses a constructor to create a suitable object.
A derived class can override new_expr() and/or clone() to return an object of its own type:
class Cond: public Expr{
public:
Cond() ;
Cond(const Cond&) ;
Cond* new_expr() { return new Cond() ; }
Cond* clone() { return new Cond(*this) ; }
/ / ...
};
This means that given an object of class Expr, a user can create a new object of ‘‘just the same
type.’’ For example:
void user(Expr* p)
{
Expr* p2= p->new_expr() ;
/ / ...
}
The pointer assigned to p2is of an appropriate, but unknown, type.
The return type of Cond: :new_expr() and Cond: :clone() was Cond* rather than Expr*.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 15.6.2 “Virtual Constructors” 425
This allows a Condto be cloned without loss of type information. For example:
void user2(Cond* pc, Expr* pe)
{
Cond* p2= pc->clone() ;
Cond* p3= pe->clone() ; / / error
/ / ...
}
The type of an overriding function must be the same as the type of the virtual function it overrides,
except that the return type may be relaxed. That is, if the original return type was B*, then the
return type of the overriding function may be D*, provided Bis a public base of D. Similarly, a
return type of B& may be relaxed to D&.
Note that a similar relaxation of the rules for argument types would lead to type violations (see
§15.8 [12]).
15.7 Advice [hier.advice]
[1] Use ordinary multiple inheritance to express a union of features; §15.2, §15.2.5.
[2] Use multiple inheritance to separate implementation details from an interface; §15.2.5.
[3] Use a virtualbase to represent something common to some, but not all, classes in a hierarchy;
§15.2.5.
[4] Avoid explicit type conversion (casts); §15.4.5.
[5] Use dynamic_castwhere class hierarchy navigation is unavoidable; §15.4.1.
[6] Prefer dynamic_castover typeid; §15.4.4.
[7] Prefer privateto protected; §15.3.1.1.
[8] Don’t declare data members protected; §15.3.1.1.
[9] If a class defines operator delete(), it should have a virtual destructor; §15.6.
[10] Don’t call virtual functions during construction or destruction; §15.4.3.
[11] Use explicit qualification for resolution of member names sparingly and preferably use it in
overriding functions; §15.2.1
15.8 Exercises [hier.exercises]
1. (∗1) Write a template ptr_castthat works like dynamic_cast, except that it throws bad_cast
rather than returning 0.
2. (∗2) Write a program that illustrates the sequence of constructor calls at the state of an object
relative to RTTI during construction. Similarly illustrate destruction.
3. (∗3.5) Implement a version of a Reversi/Othello board game. Each player can be either a
human or the computer. Focus on getting the program correct and (then) getting the computer
player ‘‘smart’’ enough to be worth playing against.
4. (∗3) Improve the user interface of the game from §15.8[3].
5. (∗3) Define a graphical object class with a plausible set of operations to serve as a common base
class for a library of graphical objects; look at a graphics library to see what operations were
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
426 Class Hierarchies Chapter 15
supplied there. Define a database object class with a plausible set of operations to serve as a
common base class for objects stored as sequences of fields in a database; look at a database
library to see what operations were supplied there. Define a graphical database object with and
without the use of multiple inheritance and discuss the relative merits of the two solutions.
6. (∗2) Write a version of the clone() operation from §15.6.2 that can place its cloned object in
an Arena(see §10.4.11) passed as an argument. Implement a simple Arenaas a class derived
from Arena.
7. (∗2) Without looking in the book, write down as many C++ keywords you can.
8. (∗2) Write a standards-conforming C++ program containing a sequence of at least ten consecutive keywords not separated by identifiers, operators, punctuation characters, etc.
9. (∗2.5) Draw a plausible memory layout for a Radioas defined in §15.2.3.1. Explain how a virtual function call could be implemented.
10. (∗2) Draw a plausible memory layout for a Radioas defined in §15.2.4. Explain how a virtual
function call could be implemented.
11. (∗3) Consider how dynamic_castmight be implemented. Define and implement a dcasttemplate that behaves like dynamic_castbut relies on functions and data you define only. Make
sure that you can add new classes to the system without having to change the definitions of
dcastor previously-written classes.
12. (∗2) Assume that the type-checking rules for arguments were relaxed in a way similar to the
relaxation for return types so that a function taking a Derived* could overwrite a Base*. Then
write a program that would corrupt an object of class Derivedwithout using a cast. Describe a
safe relaxation of the overriding rules for argument types.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Part III
The Standard Library
This part describes the C++ standard library. It presents the design of the library and
key techniques used in its implementation. The aim is to provide understanding of
how to use the library, to demonstrate generally useful design and programming techniques, and to show how to extend the library in the ways in which it was intended to
be extended.
Chapters
16 Library Organization and Containers
17 Standard Containers
18 Algorithms and Function Objects
19 Iterators and Allocators
20 Strings
21 Streams
22 Numerics
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
428 The Standard Library Part III
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
16 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
Library Organization and Containers
It was new. It was singular.
It was simple. It must succeed!
– H. Nelson
Design criteria for the standard library — library organization — standard headers —
language support — container design — iterators — based containers — STL containers
— vector— iterators — element access — constructors — modifiers — list operations
— size and capacity — vector<bool>— advice — exercises.
16.1 Standard Library Design [org.intro]
What ought to be in the standard C++ library? One ideal is for a programmer to be able to find
every interesting, significant, and reasonably general class, function, template, etc., in a library.
However, the question here is not, ‘‘What ought to be in some library?’’ but ‘‘What ought to be in
the standard library?’’ The answer ‘‘Everything!’’ is a reasonable first approximation to an answer
to the former question but not to the latter. A standard library is something that every implementer
must supply so that every programmer can rely on it.
The C++ standard library:
[1] Provides support for language features, such as memory management (§6.2.6) and runtime type information (§15.4).
[2] Supplies information about implementation-defined aspects of the language, such as the
largest floatvalue (§22.2).
[3] Supplies functions that cannot be implemented optimally in the language itself for every
system, such as sqrt() (§22.3) and memmove() (§19.4.6).
[4] Supplies nonprimitive facilities that a programmer can rely on for portability, such as lists
(§17.2.2), maps (§17.4.1), sort functions (§18.7.1), and I/O streams (Chapter 21).
[5] Provides a framework for extending the facilities it provides, such as conventions and
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
430 Library Organization and Containers Chapter 16
support facilities that allow a user to provide I/O of a user-defined type in the style of I/O
for built-in types.
[6] Provides the common foundation for other libraries.
In addition, a few facilities – such as random-number generators (§22.7) – are provided by the
standard library simply because it is conventional and useful to do so.
The design of the library is primarily determined by the last three roles. These roles are closely
related. For example, portability is commonly an important design criterion for a specialized
library, and common container types such as lists and maps are essential for convenient communication between separately developed libraries.
The last role is especially important from a design perspective because it helps limit the scope
of the standard library and places constraints on its facilities. For example, string and list facilities
are provided in the standard library. If they were not, separately developed libraries could communicate only by using built-in types. However, pattern matching and graphics facilities are not provided. Such facilities are obviously widely useful, but they are rarely directly involved in communication between separately developed libraries.
Unless a facility is somehow needed to support these roles, it can be left to some library outside
the standard. For good and bad, leaving something out of the standard library opens the opportunity for different libraries to offer competing realizations of an idea.
16.1.1 Design Constraints [org.constraints]
The roles of a standard library impose several constraints on its design. The facilities offered by
the C++ standard library are designed to be:
[1] Invaluable and affordable to essentially every student and professional programmer,
including the builders of other libraries.
[2] Used directly or indirectly by every programmer for everything within the scope of the
library.
[3] Efficient enough to provide genuine alternatives to hand-coded functions, classes, and templates in the implementation of further libraries.
[4] Either policy-free or give the user the option to supply policies as arguments.
[5] Primitive in the mathematical sense. That is, a component that serves two weakly related
roles will almost certainly suffer overheads compared to individual components designed
to perform only a single role.
[6] Convenient, efficient, and reasonably safe for common uses.
[7] Complete at what they do. The standard library may leave major functions to other
libraries, but if it takes on a task, it must provide enough functionality so that individual
users or implementers need not replace it to get the basic job done.
[8] Blend well with and augment built-in types and operations.
[9] Type safe by default.
[10] Supportive of commonly accepted programming styles.
[11] Extensible to deal with user-defined types in ways similar to the way built-in types and
standard-library types are handled.
For example, building the comparison criteria into a sort function is unacceptable because the same
data can be sorted according to different criteria. This is why the C standard library qsort() takes
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 16.1.1 Design Constraints 431
a comparison function as an argument rather than relying on something fixed, say, the < operator
(§7.7). On the other hand, the overhead imposed by a function call for each comparison compromises qsort() as a building block for further library building. For almost every data type, it is
easy to do a comparison without imposing the overhead of a function call.
Is that overhead serious? In most cases, probably not. However, the function call overhead can
dominate the execution time for some algorithms and cause users to seek alternatives. The technique of supplying comparison criteria through a template argument described in §13.4 solves that
problem. The example illustrates the tension between efficiency and generality. A standard library
is not just required to perform its tasks. It must also perform them efficiently enough not to tempt
users to supply their own mechanisms. Otherwise, implementers of more advanced features are
forced to bypass the standard library in order to remain competitive. This would add a burden to
the library developer and seriously complicate the lives of users wanting to stay platformindependent or to use several separately developed libraries.
The requirements of ‘‘primitiveness’’ and ‘‘convenience of common uses’’ appear to conflict.
The former requirement precludes exclusively optimizing the standard library for common cases.
However, components serving common, but nonprimitive, needs can be included in the standard
library in addition to the primitive facilities, rather than as replacements. The cult of orthogonality
must not prevent us from making life convenient for the novice and the casual user. Nor should it
cause us to leave the default behavior of a component obscure or dangerous.
16.1.2 Standard Library Organization [org.org]
The facilities of the standard library are defined in the stdnamespace and presented as a set of
headers. The headers identify the major parts of the library. Thus, listing them gives an overview
of the library and provides a guide to the description of the library in this and subsequent chapters.
The rest of this subsection is a list of headers grouped by function, accompanied by brief explanations and annotated by references to where they are discussed. The grouping is chosen to match
the organization of the standard. A reference to the standard (such as §s.18.1) means that the facility is not discussed here.
A standard header with a name starting with the letter cis equivalent to a header in the C standard library. For every header <cX> defining names in the stdnamespace, there is a header <X.h>
defining the same names in the global namespace (see §9.2.2). _ ___________________________________________
_ ___________________________________________ Containers _ ___________________________________________
<vector>one-dimensional array of T§16.3
<list>doubly-linked list of T§17.2.2
<deque>double-ended queue of T§17.2.3
<queue>queue of T§17.3.2
<stack>stack of T§17.3.1
<map>associative array of T§17.4.1
<set>set of T§17.4.3
_ 
___________________________________________ <bitset>array of booleans §17.5.3






















The associative containers multimapand multisetcan be found in <map> and <set>, respectively.
The priority_queueis declared in <queue>.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
432 Library Organization and Containers Chapter 16
_ _____________________________________________________
_ _____________________________________________________ General Utilities _ _____________________________________________________
<utility>operators and pairs §17.1.4, §17.4.1.2
<functional>function objects §18.4
<memory>allocators for containers §19.4.4
_ 

_____________________________________________________ <ctime>C-style date and time §s.20.5












The <memory> header also contains the auto_ptrtemplate that is primarily used to smooth the
interaction between pointers and exceptions (§14.4.2). _ _________________________________________________
_ _________________________________________________ Iterators _ _________________________________________________
_ _________________________________________________ <iterator>iterators and iterator support Chapter 19 




Iterators provide the mechanism to make standard algorithms generic over the standard containers
and similar types (§2.7.2, §19.2.1). _ ___________________________________________
_ ___________________________________________ Algorithms _ ___________________________________________
<algorithm>general algorithms Chapter 18
_ ___________________________________________ <cstdlib>bsearch() qsort() §18.11







A typical general algorithm can be applied to any sequence (§3.8, §18.3) of any type of elements.
The C standard library functions bsearch() and qsort() apply to built-in arrays with elements of
types without user-defined copy constructors and destructors only (§7.7). _ ___________________________________________
_ ___________________________________________ Diagnostics _ ___________________________________________
<exception>exception class §14.10
<stdexcept>standard exceptions §14.10
<cassert>assert macro §24.3.7.2
_ 

___________________________________________
<cerrno>C-style error handling §20.4.1












Assertions relying on exceptions are described in §24.3.7.1. _ ________________________________________________________
_ ________________________________________________________ Strings _ ________________________________________________________
<string>string of TChapter 20
<cctype>character classification §20.4.2
<cwtype>wide-character classification §20.4.2
<cstring>C-style string functions §20.4.1
<cwchar>C-style wide-character string functions §20.4
_ ________________________________________________________ <cstdlib>C-style string functions §20.4.1 
















The <cstring> header declares the strlen(), strcpy(), etc., family of functions. The <cstdlib>
declares atof() and atoi() that convert C-style strings to numeric values.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 16.1.2 Standard Library Organization 433
_ ___________________________________________________________
_ ___________________________________________________________ Input/Output _ ___________________________________________________________
<iosfwd>forward declarations of I/O facilities §21.1
<iostream>standard iostream objects and operations §21.2.1
<ios>iostream bases §21.2.1
<streambuf>stream buffers §21.6
<istream>input stream template §21.3.1
<ostream>output stream template §21.2.1
<iomanip>manipulators §21.4.6.2
<sstream>streams to/from strings §21.5.3
<cstdlib>character classification functions §20.4.2
<fstream>streams to/from files §21.5.1
<cstdio>printf() family of I/O §21.8
_ ___________________________________________________________ <cwchar>printf()-style I/O of wide characters §21.8































Manipulators are objects used to manipulate the state of a stream (e.g., changing the format of
floating-point output) by applying them to the stream (§21.4.6). _ __________________________________________________
_ __________________________________________________ Localization _ __________________________________________________
<locale>represent cultural differences §21.7
_ __________________________________________________
<clocale>represent cultural differences C-style §21.7







A localelocalizes differences such as the output format for dates, the symbol used to represent currency, and string collation criteria that vary among different natural languages and cultures. _ ___________________________________________________________
_ ___________________________________________________________ Language Support _ ___________________________________________________________
<limits>numeric limits §22.2
<climits>C-style numeric scalar-limit macros §22.2.1
<cfloat>C-style numeric floating-point limit macros §22.2.1
<new>dynamic memory management §16.1.3
<typeinfo>run-time type identification support §15.4.1
<exception>exception-handling support §14.10
<cstddef>C library language support §6.2.1
<cstdarg>variable-length function argument lists §7.6
<csetjmp>C-style stack unwinding §s.18.7
<cstdlib>program termination §9.4.1.1
<ctime>system clock §s.18.7
_ ___________________________________________________________ <csignal>C-style signal handling §s.18.7































The <cstddef> header defines the type of values returned by sizeof(), size_t, the type of the result
of pointer subtraction, ptrdiff_t(§6.2.1), and the infamous NULLmacro (§5.1.1).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
434 Library Organization and Containers Chapter 16
_ ________________________________________________
_ ________________________________________________ Numerics _ ________________________________________________
<complex>complex numbers and operations §22.5
<valarray>numeric vectors and operations §22.4
<numeric>generalized numeric operations §22.6
<cmath>standard mathematical functions §22.3
_ ________________________________________________ <cstdlib>C-style random numbers §22.7 














For historical reasons, abs(), fabs(), and div() are found in <cstdlib> rather than in <cmath>
with the rest of the mathematical functions (§22.3).
A user or a library implementer is not allowed to add or subtract declarations from the standard
headers. Nor is it acceptable to try to change the contents of headers by defining macros before
they are included or to try to change the meaning of the declarations in the headers by declarations
in their context (§9.2.3). Any program or implementation that plays such games does not conform
to the standard, and programs that rely on such tricks are not portable. Even if they work today, the
next release of any part of an implementation may break them. Avoid such trickery.
For a standard library facility to be used its header must be included. Writing out the relevant
declarations yourself is not a standards-conforming alternative. The reason is that some implementations optimize compilation based on standard header inclusion and others provide optimized
implementations of standard library facilities triggered by the headers. In general, implementers
use standard headers in ways programmers cannot predict and shouldn’t have to know about.
A programmer can, however, specialize utility templates, such as swap() (§16.3.9), for
nonstandard-library, user-defined types.
16.1.3 Language Support [org.lang]
A small part of the standard library is language support; that is, facilities that must be present for a
program to run because language features depend on them.
The library functions supporting operators newand deleteare discussed in §6.2.6, §10.4.11,
§14.4.4, and §15.6; they are presented in <new>.
Run-time type identification relies on class type_info, which is described in §15.4.4 and presented in <typeinfo>.
The standard exception classes are discussed in §14.10 and presented in <new>, <typeinfo>,
<ios>, <exception>, and <stdexcept>.
Program start and termination are discussed in §3.2, §9.4, and §10.4.9.
16.2 Container Design [org.cont]
A container is an object that holds other objects. Examples are lists, vectors, and associative arrays.
In general, you can add objects to a container and remove objects from it.
Naturally, this idea can be presented to users in many different ways. The C++ standard library
containers were designed to meet two criteria: to provide the maximum freedom in the design of an
individual container, while at the same time allowing containers to present a common interface to
users. This allows optimal efficiency in the implementation of containers and enables users to
write code that is independent of the particular container used.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 16.2 Container Design 435
Container designs typically meet just one or the other of these two design criteria. The container and algorithms part of the standard library (often called the STL) can be seen as a solution to
the problem of simultaneously providing generality and efficiency. The following sections present
the strengths and weaknesses of two traditional styles of containers as a way of approaching the
design of the standard containers.
16.2.1 Specialized Containers and Iterators [org.specialized]
The obvious approach to providing a vector and a list is to define each in the way that makes the
most sense for its intended use:
template<class T> class Vector{ / / optimal
public:
explicit Vector(size_t n) ; / / initialize to hold n objects with value T()
T& operator[](size_t) ; / / subscripting
/ / ...
};
template<class T> class List{ / / optimal
public:
class Link{ /* ... */ };
List() ; / / initially empty
void put(T*) ; / / put before current element
T* get() ; / / get current element
/ / ...
};
Each class provides operations that are close to ideal for their use, and for each class we can choose
a suitable representation without worrying about other kinds of containers. This allows the implementations of operations to be close to optimal. In particular, the most common operations such as
put() for a Listand operator[]() for a Vectorare small and easily inlined.
A common use of most kinds of containers is to iterate through the container looking at the elements one after the other. This is typically done by defining an iterator class appropriate to the
kind of container (see §11.5 and §11.14[7]).
However, a user iterating over a container often doesn’t care whether data is stored in a Listor a
Vector. In that case, the code iterating should not depend on whether a Listor a Vectorwas used.
Ideally, the same piece of code should work in both cases.
A solution is to define an iterator class that provides a get-next-element operation that can be
implemented for any container. For example:
template<class T> class Itor{ / / common interface (abstract class §2.5.4, §12.3)
public:
/ / return 0 to indicate no-more-elements
virtual T* first() = 0; / / pointer to first element
virtual T* next() = 0; / / pointer to next element
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
436 Library Organization and Containers Chapter 16
We can now provide implementations for Vectors and Lists:
template<class T> class Vector_itor: public Itor<T> { / / Vector implementation
Vector<T>& v;
size_t index; / / index of current element
public:
Vector_itor(Vector<T>& vv) :v(vv) , index(0) { }
T* first() { return(v.size()) ? &v[index=0] : 0; }
T* next() { return(++index<v.size()) ? &v[index] : 0; }
};
template<class T> class List_itor: public Itor<T> { / / List implementation
List<T>& lst;
List<T>: :Link p; / / points to current element
public:
List_itor(List<T>&) ;
T* first() ;
T* next() ;
};
Or graphically, using dashed lines to represent ‘‘implemented using:’’
Vector List
Itor
Vector_itor List_itor
.
.
The internal structure of the two iterators is quite different, but that doesn’t matter to users. We can
now write code that iterates over anything for which we can implement an Itor. For example:
int count(Itor<char>& ii, char term)
{
int c= 0;
for(char* p= ii.first() ; p; p=ii.next()) if(*p==term) c++;
return c;
}
There is a snag, however. The operations on an Itoriterator are simple, yet they incur the overhead
of a (virtual) function call. In many situations, this overhead is minor compared to what else is
being done. However, iterating through a simple container is the critical operation in many highperformance systems and a function call is many times more expensive than the integer addition or
pointer dereferencing that implements next() for a vectorand a list. Consequently, this model is
unsuitable, or at least not ideal, for a standard library.
However, this container-and-iterator model has been successfully used in many systems. For
years, it was my favorite for most applications. Its strengths and weaknesses can be summarized
like this:
+ Individual containers are simple and efficient.
+ Little commonality is required of containers. Iterators and wrapper classes (§25.7.1) can be
used to fit independently developed containers into a common framework.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 16.2.1 Specialized Containers and Iterators 437
+ Commonality of use is provided through iterators (rather than through a general container
type; §16.2.2).
+ Different iterators can be defined to serve different needs for the same container.
+ Containers are by default type safe and homogeneous (that is, all elements in a container are
of the same type). A heterogeneous container can be provided as a homogeneous container
of pointers to a common base.
+ The containers are non-intrusive (that is, an object need not have a special base class or link
field to be a member of a container). Non-intrusive containers work well with built-in types
and with structs with externally-imposed layouts.
– Each iterator access incurs the overhead of a virtual function call. The time overhead can be
serious compared to simple inlined access functions.
– A hierarchy of iterator classes tends to get complicated.
– There is nothing in common for every container and nothing in common for every object in
every container. This complicates the provision of universal services such as persistence
and object I/O.
A + indicates an advantage and a - indicates a disadvantage.
I consider the flexibility provided by iterators especially important. A common interface, such
as Itor, can be provided long after the design and implementation of containers (here, Vectorand
List). When we design, we typically first invent something fairly concrete. For example, we
design an array and invent a list. Only later do we discover an abstraction that covers both arrays
and lists in a given context.
As a matter of fact, we can do this ‘‘late abstraction’’ several times. Suppose we want to represent a set. A set is a very different abstraction from Itor, yet we can provide a Setinterface to
Vectorand Listin much the same way that I provided Itoras an interface to Vectorand List:
Vector List
Set Itor
Vector_set L Vector_itor L List_set List_itor
.
.
Thus, late abstraction using abstract classes allows us to provide different implementations of a
concept even when there is no significant similarity between the implementations. For example,
lists and vectors have some obvious commonality, but we could easily implement an Itorfor an
istream.
Logically, the last two points on the list are the main weaknesses of the approach. That is, even
if the function call overhead for iterators and similar interfaces to containers were eliminated (as is
possible in some contexts), this approach would not be ideal for a standard library.
Non-intrusive containers incur a small overhead in time and space for some containers compared with intrusive containers. I have not found this a problem. Should it become a problem, an
iterator such as Itorcan be provided for an intrusive container (§16.5[11]).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
438 Library Organization and Containers Chapter 16
16.2.2 Based Containers [org.based]
One can define an intrusive container without relying on templates or any other way of parameterizing a type declaration. For example:
struct Link{
Link* pre;
Link* suc;
/ / ...
};
class List{
Link* head;
Link* curr; / / current element
public:
Link* get() ; / / remove and return current element
void put(Link*) ; / / insert before current element
/ / ...
};
A Listis now a list of Links, and it can hold objects of any type derived from Link. For example:
class Ship: public Link{ /* ... */ };
void f(List* lst)
{
while(Link* po= lst->get()) {
if(Ship* ps= dynamic_cast<Ship*>(po)) { / / Ship must be polymorphic (§15.4.1)
/ / use ship
}
else{
/ / Oops, do something else
}
}
}
Simula defined its standard containers in this style, so this approach can be considered the original
for languages supporting object-oriented programming. These days, a common class for all objects
is usually called Objector something similar. An Objectclass typically provides other common
services in addition to serving as a link for containers.
Often, but not necessarily, this approach is extended to provide a common container type:
class Container: public Object{
public:
virtual Object* get() ; / / remove and return current element
virtual void put(Object*) ; / / insert before current element
virtual Object*& operator[](size_t) ; / / subscripting
/ / ...
};
Note that the operations provided by Containerare virtual so that individual containers can override them appropriately:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 16.2.2 Based Containers 439
class List: public Container{
public:
Object* get() ;
void put(Object*) ;
/ / ...
};
class Vector: public Container{
public:
Object*& operator[](size_t) ;
/ / ...
};
One problem arises immediately. What operations do we want Containerto provide? We could
provide only the operations that every container can support. However, the intersection of the sets
of operations on all containers is a ridiculously narrow interface. In fact, in many interesting cases
that intersection is empty. So, realistically, we must provide the union of essential operations on
the variety of containers we intend to support. Such a union of interfaces to a set of concepts is
called a fat interface (§24.4.3).
We can either provide default implementations of the functions in the fat interface or force
every derived class to implement every function by making them pure virtual functions. In either
case, we end up with a lot of functions that simply report a run-time error. For example:
class Container: public Object{
public:
struct Bad_op{ / / exception class
const char* p;
Bad_op(const char* pp) :p(pp) { }
};
virtual void put(Object*) { throw Bad_op("put") ; }
virtual Object* get() { throw Bad_op("get") ; }
virtual Object*& operator[](int) { throw Bad_op("[]") ; }
/ / ...
};
If we want to protect against the possibility of a container that does not support get(), we must
catch Container: :Bad_opsomewhere. We could now write the Shipexample like this:
class Ship: public Object{ /* ... */ };
void f1(Container* pc)
{
try{
while(Object* po= pc->get()) {
if(Ship* ps= dynamic_cast<Ship*>(po)) {
/ / use ship
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
440 Library Organization and Containers Chapter 16
else{
/ / Oops, do something else
}
}
}
catch(Container: :Bad_op& bad) {
/ / Oops, do something else
}
}
This is tedious, so the checking for Bad_opwill typically be elsewhere. By relying on exceptions
caught elsewhere, we can reduce the example to:
void f2(Container* pc)
{
while(Object* po= pc->get()) {
Ship& s= dynamic_cast<Ship&>(*po) ;
/ / use ship
}
}
However, I find unnecessary reliance on run-time checking distasteful and inefficient. In this kind
of case, I prefer the statically-checked alternative:
void f3(Itor<Ship>* i)
{
while(Ship* ps= i->next()) {
/ / use ship
}
}
The strengths and weakness of the ‘‘based object’’ approach to container design can be summarized
like this (see also §16.5[10]):
– Operations on individual containers incur virtual function overhead.
– All containers must be derived from Container. This implies the use of fat interfaces,
requires a large degree of foresight, and relies on run-time type checking. Fitting an independently developed container into the common framework is awkward at best (see
§16.5[12]).
+ The common base Containermakes it easy to use containers that supply similar sets of
operations interchangeably.
– Containers are heterogeneous and not type safe by default (all we can rely on is that elements are of type Object*). When desired, type-safe and homogeneous containers can be
defined using templates.
– The containers are intrusive (that is, every element must be of a type derived from Object).
Objects of built-in types and structs with externally imposed layouts cannot be placed
directly in containers.
– An element retrieved from a container must be given a proper type using explicit type conversion before it can be used.
+ Class Containerand class Objectare handles for implementing services for every object or
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 16.2.2 Based Containers 441
every container. This greatly eases the provision of universal services such as persistence
and object I/O.
As before (§16.2.1), + indicates an advantage and - indicates a disadvantage.
Compared to the approach using unrelated containers and iterators, the based-object approach
unnecessarily pushes complexity onto the user, imposes significant run-time overheads, and
restricts the kinds of objects that can be placed in a container. In addition, for many classes, to
derive from Objectis to expose an implementation detail. Thus, this approach is far from ideal for
a standard library.
However, the generality and flexibility of this approach should not be underestimated. Like its
alternatives, it has been used successfully in many applications. Its strengths lie in areas in which
efficiency is less important than the simplicity afforded by a single Containerinterface and services such as object I/O.
16.2.3 STL Containers [org.stl]
The standard library containers and iterators (often called the STL framework, §3.10) can be understood as an approach to gain the best of the two traditional models described previously. That
wasn’t the way the STL was designed, though. The STL was the result of a single-minded search
for uncompromisingly efficient and generic algorithms.
The aim of efficiency rules out hard-to-inline virtual functions for small, frequently-used access
functions. Therefore, we cannot present a standard interface to containers or a standard iterator
interface as an abstract class. Instead, each kind of container supports a standard set of basic operations. To avoid the problems of fat interfaces (§16.2.2, §24.4.3), operations that cannot be efficiently implemented for all containers are not included in the set of common operations. For example, subscripting is provided for vectorbut not for list. In addition, each kind of container provides
its own iterators that support a standard set of iterator operations.
The standard containers are not derived from a common base. Instead, every container implements all of the standard container interface. Similarly, there is no common iterator base class. No
explicit or implicit run-time type checking is involved in using the standard containers and iterators.
The important and difficult issue of providing common services for all containers is handled
through ‘‘allocators’’ passed as template arguments (§19.4.3) rather than through a common base.
Before I go into details and code examples, the strengths and weaknesses of the STL approach
can be summarized:
+ Individual containers are simple and efficient (not quite as simple as truly independent containers can be, but just as efficient).
+ Each container provides a set of standard operations with standard names and semantics.
Additional operations are provided for a particular container type as needed. Furthermore,
wrapper classes (§25.7.1) can be used to fit independently developed containers into a common framework (§16.5[14]).
+ Additional commonality of use is provided through standard iterators. Each container provides iterators that support a set of standard operations with standard names and semantics.
An iterator type is defined for each particular container type so that these iterators are as
simple and efficient as possible.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
442 Library Organization and Containers Chapter 16
+ To serve different needs for containers, different iterators and other generalized interfaces
can be defined in addition to the standard iterators.
+ Containers are by default type-safe and homogeneous (that is, all elements in a container are
of the same type). A heterogeneous container can be provided as a homogeneous container
of pointers to a common base.
+ The containers are non-intrusive (that is, an object need not have a special base class or link
field to be a member of a container). Non-intrusive containers work well with built-in types
and with structs with externally imposed layouts.
+ Intrusive containers can be fitted into the general framework. Naturally, an intrusive container will impose constraints on its element types.
+ Each container takes an argument, called an allocator, which can be used as a handle for
implementing services for every container. This greatly eases the provision of universal services such as persistence and object I/O (§19.4.3).
– There is no standard run-time representation of containers or iterators that can be passed as a
function argument (although it is easy to define such representations for the standard containers and iterators where needed for a particular application; §19.3).
As before (§16.2.1), + indicates an advantage and - indicates a disadvantage.
In other words, containers and iterators do not have fixed standard representations. Instead,
each container provides a standard interface in the form of a set of operations so that containers can
be used interchangeably. Iterators are handled similarly. This implies minimal overheads in time
and space while allowing users to exploit commonality both at the level of containers (as with the
based-object approach) and at the level of iterators (as with the specialized container approach).
The STL approach relies heavily on templates. To avoid excessive code replication, partial specialization to provide shared implementations for containers of pointers is usually required (§13.5).
16.3 Vector [org.vector]
Here, vectoris described as an example of a complete standard container. Unless otherwise stated,
what is said about vectorholds for every standard container. Chapter 17 describes features peculiar
to lists, sets, maps, etc. The facilities offered by vector– and similar containers – are described in
some detail. The aim is to give an understanding both of the possible uses of vectorand of its role
in the overall design of the standard library.
An overview of the standard containers and the facilities they offer can be found in §17.1.
Below, vectoris introduced in stages: member types, iterators, element access, constructors, stack
operations, list operations, size and capacity, helper functions, and vector<bool>.
16.3.1 Types [org.types]
The standard vectoris a template defined in namespace stdand presented in <vector>. It first
defines a set of standard names of types:
template<class T, class A= allocator<T> > class std: :vector{
public:
/ / types:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 16.3.1 Types 443
typedef T value_type; / / type of element
typedef A allocator_type; / / type of memory manager
typedef typename A: :size_type size_type;
typedef typename A: :difference_type difference_type;
typedefimplementation_dependent1 iterator; / / T*
typedefimplementation_dependent2 const_iterator; / / const T*
typedef std: :reverse_iterator<iterator> reverse_iterator;
typedef std: :reverse_iterator<const_iterator> const_reverse_iterator;
typedef typename A: :pointer pointer; / / pointer to element
typedef typename A: :const_pointer const_pointer;
typedef typename A: :reference reference; / / reference to element
typedef typename A: :const_reference const_reference;
/ / ...
};
Every standard container defines these typenames as members. Each defines them in the way most
appropriate to its implementation.
The type of the container’s elements is passed as the first template argument and is known as its
value_type. The allocator_type, which is optionally supplied as the second template argument,
defines how the value_typeinteracts with various memory management mechanisms. In particular,
an allocator supplies the functions that a container uses to allocate and deallocate memory for its
elements. Allocators are discussed in §19.4. In general, size_typespecifies the type used for
indexing into the container, and difference_typeis the type of the result of subtracting two iterators
for a container. For most containers, they correspond to size_tand ptrdiff_t(§6.2.1).
Iterators were introduced in §2.7.2 and are described in detail in Chapter 19. They can be
thought of as pointers to elements of the container. Every container provides a type called iterator
for pointing to elements. It also provides a const_iteratortype for use when elements don’t need
to be modified. As with pointers, we use the safer constversion unless there is a reason to do otherwise. The actual types of vector’s iterators are implementation-defined. The obvious definitions
for a conventionally-defined vectorwould be T* and const T*, respectively.
The reverse iterator types for vectorare constructed from the standard reverse_iteratortemplates (§19.2.5). They present a sequence in the reverse order.
As shown in §3.8.1, these member typenames allow a user to write code using a container without having to know about the actual types involved. In particular, they allow a user to write code
that will work for any standard container. For example:
template<class C> typename C: :value_type sum(const C& c)
{
typename C: :value_type s= 0;
typename C: :const_iterator p= c.begin() ; / / start at the beginning
while(p!=c.end()) { / / continue until the end
s+= *p; / / get value of element
++p; / / make p point to next element
}
return s;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
444 Library Organization and Containers Chapter 16
Having to add typenamebefore the names of member types of a template parameter is a nuisance.
However, the compiler isn’t psychic. There is no general way for it to know whether a member of
a template argument type is a typename (§C.13.5).
As for pointers, prefix * means dereference the iterator (§2.7.2, §19.2.1) and ++ means increment the iterator.
16.3.2 Iterators [org.begin]
As shown in the previous subsection, iterators can be used to navigate containers without the programmers having to know the actual type used to identify elements. A few key member functions
allow the programmer to get hold of the ends of the sequence of elements:
template<class T, class A= allocator<T> > class vector{
public:
/ / ...
/ / iterators:
iterator begin() ; / / points to first element
const_iterator begin() const;
iterator end() ; / / points to one-past-last element
const_iterator end() const;
reverse_iterator rbegin() ; / / points to first element of reverse sequence
const_reverse_iterator rbegin() const;
reverse_iterator rend() ; / / points to one-past-last element of reverse sequence
const_reverse_iterator rend() const;
/ / ...
};
The begin()/end() pair gives the elements of the container in the ordinary element order. That
is, element 0is followed by element 1, element 2, etc. The rbegin()/rend() pair gives the elements in the reverse order. That is, element n-1is followed by element n-2, element n-3, etc.
For example, a sequence seen like this using an iterator:
begin() end()
A B C . . . . ..
.
. .. . . . .
.
.
.
can be viewed like this using a reverse_iterator(§19.2.5):
rbegin() rend()
C B A . . . . ..
.
. .. . . . .
.
.
.
This allows us to use algorithms in a way that views a sequence in the reverse order. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 16.3.2 Iterators 445
template<class C>
typename C: :iterator find_last(const C& c, typename C: :value_type v)
{
return find_first(c.rbegin() ,c.rend() ,v).base() ;
}
The base() function returns an iteratorcorresponding to the reverse_iterator(§19.2.5). Without
reverse iterators, we could have had to write something like:
template<class C>
typename C: :iterator find_last(const C& c, typename C: :value_type v)
{
typename C: :iterator p= c.end() ; / /search backwards from end
while(p!=c.begin()) {
--p;
if(*p==v) return p;
}
return p;
}
A reverse iterator is a perfectly ordinary iterator, so we could have written:
template<class C>
typename C: :reverse_iterator find_last(const C& c, typename C: :value_type v)
{
typename C: :reverse_iterator p= c.rbegin() ; / / view sequence in reverse order
while(p!=c.rend()) {
if(*p==v) return p;
++p; / / note: not decrement (--)
}
return p;
}
16.3.3 Element Access [org.element]
One important aspect of a vectorcompared with other containers is that one can easily and efficiently access individual elements in any order:
template<class T, class A= allocator<T> > class vector{
public:
/ / ...
/ / element access:
reference operator[](size_type n) ; / / unchecked access
const_reference operator[](size_type n) const;
reference at(size_type n) ; / / checked access
const_reference at(size_type n) const;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
446 Library Organization and Containers Chapter 16
reference front() ; / / first element
const_reference front() const;
reference back() ; / / last element
const_reference back() const;
/ / ...
};
Indexing is done by operator[]() and at(); operator[]() provides unchecked access, whereas
at() does a range check and throws out_of_rangeif an index is out of range. For example:
void f(vector<int>& v, int i1, int i2)
try{
for(int i= 0; i< v.size() ; i++) {
/ / range already checked: use unchecked v[i] here
}
v.at(i1) = v.at(i2) ; / / check range on access
/ / ...
}
catch(out_of_range) {
/ / oops: out-of-range error
}
This illustrates one idea for use. That is, if the range has already been checked, the unchecked subscripting operator can be used safely; otherwise, it is wise to use the range-checked at() function.
This distinction is important when efficiency is at a premium. When that is not the case or when it
is not perfectly obvious whether a range has been correctly checked, it is safer to use a vector with a
checked [] operator (such as Vecfrom §3.7.1) or a checked iterator (§19.3).
The default access is unchecked to match arrays. Also, you can build a safe (checked) facility
on top of a fast one but not a faster facility on top of a slower one.
The access operations return values of type referenceor const_referencedepending on
whether or not they are applied to a constobject. A reference is some suitable type for accessing
elements. For the simple and obvious implementation of vector<X>, referenceis simply X& and
const_referenceis simply const X&. The effect of trying to create an out-of-range reference is
undefined. For example:
void f(vector<double>& v)
{
double d= v[v.size()] ; / / undefined: bad index
list<char> lst;
char c= lst.front() ; / / undefined: list is empty
}
Of the standard sequences, only vectorand deque(§17.2.3) support subscripting. The reason is the
desire not to confuse users by providing fundamentally inefficient operations. For example, subscripting could have been provided for list(§17.2.2), but doing that would have been dangerously
inefficient (that is, O(n)).
The members front() and back() return references to the first and last element, respectively.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 16.3.3 Element Access 447
They are most useful where these elements are known to exist and in code where these elements are
of particular interest. A vectorused as a stack(§16.3.5) is an obvious example. Note that front()
returns a reference to the element to which begin() returns an iterator. I often think of front() as
the first element and begin() as a pointer to the first element. The correspondence between
back() and end() is less simple: back() is the last element and end() points to the last-plus-one
element position.
16.3.4 Constructors [org.ctor]
Naturally, vectorprovides a complete set (§11.7) of constructors, destructor, and copy operations:
template<class T, class A= allocator<T> > class vector{
public:
/ / ...
/ / constructors, etc.:
explicit vector(const A& = A()) ;
explicit vector(size_type n, const T& val= T() , const A& = A()) ; / / n copies of val
template<class In> / / In must be an input iterator (§19.2.1)
vector(In first, In last, const A& = A()) ; / / copy from [first:last[
vector(const vector& x) ;
~vector() ;
vector& operator=(const vector& x) ;
template<class In> / / In must be an input iterator (§19.2.1)
void assign(In first, In last) ; / / copy from [first:last[
void assign(size_type n, const T& val) ; / / n copies of val
/ / ...
};
A vectorprovides fast access to arbitrary elements, but changing its size is relatively expensive.
Consequently, we typically give an initial size when we create a vector. For example:
vector<Record> vr(10000) ;
void f(int s1, int s2)
{
vector<int> vi(s1) ;
vector<double>* p= new vector<double>(s2) ;
}
Elements of a vector allocated this way are initialized by the default constructor for the element
type. That is, each of vr’s 10000elements is initialized by Record() and each of vi’s s1elements
is initialized by int(). Note that the default constructor for a built-in type performs initialization to
0of the appropriate type (§4.9.5, §10.4.2).
If a type does not have a default constructor, it is not possible to create a vector with elements
of that type without explicitly providing the value of each element. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
448 Library Organization and Containers Chapter 16
class Num{ / / infinite precision
public:
Num(long) ;
/ / no default constructor
/ / ...
};
vector<Num> v1(1000) ; / / error: no default Num
vector<Num> v2(1000,Num(0)) ; / / ok
Since a vectorcannot have a negative number of elements, its size must be non-negative. This is
reflected in the requirement that vector’s size_typemust be an unsignedtype. This allows a
greater range of vector sizes on some architectures. However, it can also lead to surprises:
void f(int i)
{
vector<char> vc0(-1) ; / / fairly easy for compiler to warn against
vector<char> vc1(i) ;
}
void g()
{
f(-1) ; / / trick f() into accepting a large positive number!
}
In the call f(-1), -1is converted into a (rather large) positive integer (§C.6.3). If we are lucky,
the compiler will find a way of complaining.
The size of a vectorcan also be provided implicitly by giving the initial set of elements. This is
done by supplying the constructor with a sequence of values from which to construct the vector.
For example:
void f(const list<X>& lst)
{
vector<X> v1(lst.begin() ,lst.end()) ; / / copy elements from list
char p[] = "despair";
vector<char> v2(p,&p[sizeof(p)-1]) ; / / copy characters from C-style string
}
In each case, the vectorconstructor adjusts the size of the vectoras it copies elements from its
input sequence.
The vectorconstructors that can be invoked with a single argument are declared explicitto prevent accidental conversions (§11.7.1). For example:
vector<int> v1(10) ; / / ok: vector of 10 ints
vector<int> v2= vector<int>(10) ; / / ok: vector of 10 ints
vector<int> v3= v2; / / ok: v3 is a copy of v2
vector<int> v4= 10; / / error: attempted implicit conversion of 10 to vector<int>
The copy constructor and the copy-assignment operators copy the elements of a vector. For a
vectorwith many elements, that can be an expensive operation, so vectors are typically passed by
reference. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 16.3.4 Constructors 449
void f1(vector<int>&) ; / / common style
void f2(const vector<int>&) ; / / common style
void f3(vector<int>) ; / / rare style
void h()
{
vector<int> v(10000) ;
/ / ...
f1(v) ; / / pass a reference
f2(v) ; / / pass a reference
f3(v) ; / / copy the 10000 elements into a new vector for f3() to use
}
The assignfunctions exist to provide counterparts to the multi-argument constructors. They are
needed because = takes a single right-hand operand, so assign() is used where a default argument
value or a range of values is needed. For example:
class Book{
/ / ...
};
void f(vector<Num>& vn, vector<char>& vc, vector<Book>& vb, list<Book>& lb)
{
vn.assign(10,Num(0)) ; / / assign vector of 10 copies of Num(0) to vn
char s[] = "literal";
vc.assign(s,&s[sizeof(s)-1]) ; / / assign "literal" to vc
vb.assign(lb.begin() ,lb.end()) ; / / assign list elements
/ / ...
}
Thus, we can initialize a vectorwith any sequence of its element type and similarly assign any such
sequence. Importantly, this is done without explicitly introducing a multitude of constructors and
conversion functions. Note that assignment completely changes the elements of a vector. Conceptually, all old elements are erased and the new ones are inserted. After assignment, the size of a
vectoris the number of elements assigned. For example:
void f()
{
vector<char> v(10,´x´) ; / / v.size()==10, each element has the value ’x’
v.assign(5,´a´) ; / / v.size()==5, each element has the value ’a’
/ / ...
}
Naturally, what assign() does could be done indirectly by first creating a suitable vectorand then
assigning that. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
450 Library Organization and Containers Chapter 16
void f2(vector<Book>& vh, list<Book>& lb)
{
vector<Book> vt(lb.begin() ,lb.end()) ;
vh= vt;
/ / ...
}
However, this can be both ugly and inefficient.
Constructing a vectorwith two arguments of the same type can lead to an apparent ambiguity:
vector<int> v(10,50) ; / / vector(size,value) or vector(iterator1,iterator2)? vector(size,value)!
However, an intisn’t an iterator and the implementation must ensure that this actually invokes
vector(vector<int>: :size_type, const int&, const vector<int>: :allocator_type&) ;
rather than
vector(vector<int>: :iterator, vector<int>: :iterator, const vector<int>: :allocator_type&) ;
The library achieves this by suitable overloading of the constructors and handles the equivalent
ambiguities for assign() and insert() (§16.3.6) similarly.
16.3.5 Stack Operations [org.stack]
Most often, we think of a vectoras a compact data structure that we can index to access elements.
However, we can ignore this concrete notion and view vectoras an example of the more abstract
notion of a sequence. Looking at a vectorthis way, and observing common uses of arrays and
vectors, it becomes obvious that stack operations make sense for a vector:
template<class T, class A= allocator<T> > class vector{
public:
/ / ...
/ / stack operations:
void push_back(const T& x) ; / / add to end
void pop_back() ; / / remove last element
/ / ...
};
These functions treat a vectoras a stack by manipulating its end. For example:
void f(vector<char>& s)
{
s.push_back(´a´) ;
s.push_back(´b´) ;
s.push_back(´c´) ;
s.pop_back() ;
if(s[s.size()-1] != ´b´) error("impossible!") ;
s.pop_back() ;
if(s.back() != ´a´) error("should never happen!") ;
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 16.3.5 Stack Operations 451
Each time push_back() is called, the vector sgrows by one element and that element is added at
the end. So s[s.size()-1], also known as s.back() (§16.3.3), is the element most recently
pushed onto the vector.
Except for the word vectorinstead of stack, there is nothing unusual in this. The suffix _back
is used to emphasize that elements are added to the end of the vectorrather than to the beginning.
Adding an element to the end of a vectorcould be an expensive operation because extra memory
needs to be allocated to hold it. However, an implementation must ensure that repeated stack operations incur growth-related overhead only infrequently.
Note that pop_back() does not return a value. It just pops, and if we want to know what was
on the top of the stack before the pop, we must look. This happens not to be my favorite style of
stack (§2.5.3, §2.5.4), but it’s arguably more efficient and it’s the standard.
Why would one do stack-like operations on a vector? An obvious reason is to implement a
stack(§17.3.1), but a more common reason is to construct a vectorincrementally. For example,
we might want to read a vectorof points from input. However, we don’t know how many points
will be read, so we can’t allocate a vector of the right size and then read into it. Instead, we might
write:
vector<Point> cities;
void add_points(Point sentinel)
{
Point buf;
while(cin>> buf) {
if(buf== sentinel) return;
/ / check new point
cities.push_back(buf) ;
}
}
This ensures that the vectorexpands as needed. If all we needed to do with a new point were to put
it into the vector, we might have initialized citiesdirectly from input in a constructor (§16.3.4).
However, it is common to do a bit of processing on input and expand a data structure gradually as a
program progresses; push_back() supports that.
In C programs, this is one of the most common uses of the C standard library function realloc(). Thus, vector– and, in general, any standard container – provides a more general, more
elegant, and no less efficient alternative to realloc().
The size() of a vectoris implicitly increased by push_back() so the vectorcannot overflow
(as long as there is memory available to acquire; see §19.4.1). However, a vectorcan underflow:
void f()
{
vector<int> v;
v.pop_back() ; / / undefined effect: the state of v becomes undefined
v.push_back(7) ; / / undefined effect (the state of v is undefined), probably bad
}
The effect of underflow is undefined, but the obvious implementation of pop_back() causes memory not owned by the vectorto be overwritten. Like overflow, underflow must be avoided.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
452 Library Organization and Containers Chapter 16
16.3.6 List Operations [org.list]
The push_back(), pop_back(), and back() operations (§16.3.5) allow a vectorto be used effectively as a stack. However, it is sometimes also useful to add elements in the middle of a vector
and to remove elements from a vector:
template<class T, class A= allocator<T> > class vector{
public:
/ / ...
/ / list operations:
iterator insert(iterator pos, const T& x) ; / / add x before ’pos’
void insert(iterator pos, size_type n, const T& x) ;
template<class In> / / In must be an input iterator (§19.2.1)
void insert(iterator pos, In first, In last) ; / / insert elements from sequence
iterator erase(iterator pos) ; / / remove element at pos
iterator erase(iterator first, iterator last) ; / / erase sequence
void clear() ; / / erase all elements
/ / ...
};
To see how these operations work, let’s do some (nonsensical) manipulation of a vectorof names
of fruit. First, we define the vectorand populate it with some names:
vector<string> fruit;
fruit.push_back("peach") ;
fruit.push_back("apple") ;
fruit.push_back("kiwifruit") ;
fruit.push_back("pear") ;
fruit.push_back("starfruit") ;
fruit.push_back("grape") ;
If I take a dislike to fruits whose names start with the letter p, I can remove those names like this:
sort(fruit.begin() ,fruit.end()) ;
vector<string>: :iterator p1= find_if(fruit.begin() ,fruit.end() ,initial(´p´)) ;
vector<string>: :iterator p2= find_if(p1,fruit.end() ,initial_not(´p´)) ;
fruit.erase(p1,p2) ;
In other words, sort the vector, find the first and the last fruit with a name that starts with the letter
p, and erase those elements from fruit. How to write predicate functions such as initial(x) (is the
initial letter x?) and initial_not() (is the initial letter different from p?) is explained in §18.4.2.
The erase(p1,p2) operation removes elements starting from p1up to and not including p2.
This can be illustrated graphically:
fruit[]:
p1 p2
| |
v v
apple grape kiwifruit peach pear starfruit
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 16.3.6 List Operations 453
The erase(p1,p2) removes peachand pear, yielding:
fruit[]:
apple grape kiwifruit starfruit
As usual, the sequence specified by the user is from the beginning to one-past-the-end of the
sequence affected by the operation.
It would be tempting to write:
vector<string>: :iterator p1= find_if(fruit.begin() ,fruit.end() ,initial(´p´)) ;
vector<string>: :reverse_iterator p2= find_if(fruit.rbegin() ,fruit.rend() ,initial(´p´)) ;
fruit.erase(p1,p2+1) ; / / oops!: type error
However, vector<fruit>: :iteratorand vector<fruit>: :reverse_iteratorneed not be the same
type, so we couldn’t rely on the call of erase() to compile. To be used with an iterator, a
reverse_iteratormust be explicitly converted:
fruit.erase(p1,p2.base()) ; / / extract iterator from reverse_iterator (§19.2.5)
Erasing an element from a vectorchanges the size of the vector, and the elements after the erased
elements are copied into the freed positions. In this example, fruit.size() becomes 4and the starfruitthat used to be fruit[5] is now fruit[3].
Naturally, it is also possible to erase() a single element. In that case, only an iterator for that
element is needed (rather than a pair of iterators). For example,
fruit.erase(find(fruit.begin() ,fruit.end() ,"starfruit")) ;
fruit.erase(fruit.begin()+1) ;
gets rid of the starfruitand the grape, thus leaving fruitwith two elements:
fruit[]:
apple kiwifruit
It is also possible to insert elements into a vector. For example:
fruit.insert(fruit.begin()+1,"cherry") ;
fruit.insert(fruit.end() ,"cranberry") ;
The new element is inserted before the position mentioned, and the elements from there to the end
are moved to make space. We get:
fruit[]:
apple cherry kiwifruit cranberry
Note that f.insert(f.end() ,x) is equivalent to f.push_back(x).
We can also insert whole sequences:
fruit.insert(fruit.begin()+2,citrus.begin() ,citrus.end()) ;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
454 Library Organization and Containers Chapter 16
If citrusis a container
citrus[]:
lemon grapefruit orange lime
we get:
fruit[]:
apple cherry lemon grapefruit orange lime kiwifruit cranberry
The elements of citrusare copied into fruitby insert(). The value of citrusis unchanged.
Clearly, insert() and erase() are more general than are operations that affect only the tail end
of a vector(§16.3.5). They can also be more expensive. For example, to make room for a new element, insert() may have to reallocate every element to a new part of memory. If insertions into
and deletions from a container are common, maybe that container should be a listrather than a
vector. A listis optimized for insert() and erase() rather than for subscripting (§16.3.3).
Insertion into and erasure from a vector(but not a listor an associative container such as map)
potentially move elements around. Consequently, an iterator pointing to an element of a vector
may after an insert() or erase() point to another element or to no element at all. Never access an
element through an invalid iterator; the effect is undefined and quite likely disastrous. In particular,
beware of using the iterator that was used to indicate where an insertion took place; insert()
makes its first argument invalid. For example:
void duplicate_elements(vector<string>& f)
{
for(vector<string>: :iterator p= f.begin() ; p!=f.end() ; ++p) f.insert(p,*p) ;/ / No!
}
Just think of it (§16.5[15]). A vectorimplementation would move all elements – or at least all elements after p– to make room for the new element.
The operation clear() erases all elements of a container. Thus, c.clear() is a shorthand for
c.erase(c.begin() ,c.end()). After c.clear(), c.size() is 0.
16.3.7 Addressing Elements [org.addressing]
Most often, the target of an erase() or insert() is a well-known place (such as begin() or
end()), the result of a search operation (such as find()), or a location found during an iteration.
In such cases, we have an iterator pointing to the relevant element. However, we often refer to elements of a vectorby subscripting. How do we get an iterator suitable as an argument for erase()
or insert() for the element with index 7of a container c? Since that element is the 7th element
after the beginning, c.begin()+7is a good answer. Other alternatives that may seem plausible by
analogy to arrays should be avoided. Consider:
template<class C> void f(C& c)
{
c.erase(c.begin()+7) ; / / ok
c.erase(&c[7]) ; / / not general
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 16.3.7 Addressing Elements 455
c.erase(c+7) ; / / error: adding 7 to a container makes no sense
c.erase(c.back()) ; / / error: c.back() is a reference, not an iterator
c.erase(c.end()-2) ; / / ok (second to last element)
c.erase(c.rbegin()+2) ; / / error: vector::reverse_iterator and vector::iterator
/ / are different types
c.erase((c.rbegin()+2).base()) ; / / obscure, but ok (see §19.2.5)
}
The most tempting alternative, &c[7], actually happens to work with the obvious implementation
of vector, where c[7] refers directly to the element and its address is a valid iterator. However,
this is not true for other containers. For example, a listor mapiterator is almost certainly not a
simple pointer to an element. Consequently, their iterators do not support []. Therefore, &c[7]
would be an error that the compiler catches.
The alternatives c+7and c.back() are simple type errors. A container is not a numeric variable to which we can add 7, and c.back() is an element with a value like "pear" that does not
identify the pear’s location in the container c.
16.3.8 Size and Capacity [org.size]
So far, vectorhas been described with minimal reference to memory management. A vectorgrows
as needed. Usually, that is all that matters. However, it is possible to ask directly about the way a
vectoruses memory, and occasionally it is worthwhile to affect it directly. The operations are:
template<class T, class A= allocator<T> > class vector{
public:
/ / ...
/ / capacity:
size_type size() const; / / number of elements
bool empty() const{ return size()==0; }
size_type max_size() const; / / size of the largest possible vector
void resize(size_type sz, T val= T()) ; / / added elements initialized by val
size_type capacity() const; / / size of the memory (in number of elements) allocated
void reserve(size_type n) ; / / make room for a total of n elements; don’t initialize
/ / throw a length_error if n>max_size()
/ / ...
};
At any given time, a vectorholds a number of elements. This number can be obtained by calling
size() and can be changed using resize(). Thus, a user can determine the size of a vector and
change it if it seems insufficient or excessive. For example:
class Histogram{
vector<int> count;
public:
Histogram(int h) : count(max(h,8)) {}
void record(int i) ;
/ / ...
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
456 Library Organization and Containers Chapter 16
void Histogram: :record(int i)
{
if(i<0) i= 0;
if(count.size()<=i) count.resize(i+i) ; / / make lots of room
count[i]++;
}
Using resize() on a vectoris very similar to using the C standard library function realloc() on a
C array allocated on the free store.
When a vectoris resized to accommodate more (or fewer) elements, all of its elements may be
moved to new locations. Consequently, it is a bad idea to keep pointers to elements in a vectorthat
might be resized; after resize(), such pointers could point to deallocated memory. Instead, we can
keep indices. Note that push_back(), insert(), and erase() implicitly resize a vector.
In addition to the elements held, an application may keep some space for potential expansion.
A programmer who knows that expansion is likely can tell the vectorimplementation to reserve()
space for future expansion. For example:
struct Link{
Link* next;
Link(Link* n=0) : next(n) {}
/ / ...
};
vector<Link> v;
void chain(size_t n) / / fill v with n Links so that each Link points to its predecessor
{
v.reserve(n) ;
v.push_back(Link(0)) ;
for(int i= 1; i<n; i++) v.push_back(Link(&v[i-1])) ;
/ / ...
}
A call v.reserve(n) ensures that no allocation will be needed when the size of vis increased until
v.size() exceeds n.
Reserving space in advance has two advantages. First, even a simple-minded implementation
can then allocate sufficient space in one operation rather than slowly acquiring enough memory
along the way. However, in many cases there is a logical advantage that outweighs the potential
efficiency gain. The elements of a container are potentially relocated when a vectorgrows. Thus,
the links built between the elements of vin the previous example are guaranteed only because the
call of reserve() ensures that there are no allocations while the vector is being built. That is, in
some cases reserve() provides a guarantee of correctness in addition to whatever efficiency
advantages it gives.
That same guarantee can be used to ensure that potential memory exhaustion and potentially
expensive reallocation of elements take place at predictable times. For programs with stringent
real-time constraints, this can be of great importance.
Note that reserve() doesn’t change the size of a vector. Thus, it does not have to initialize any
new elements. In both respects, it differs from resize().
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 16.3.8 Size and Capacity 457
In the same way as size() gives the current number of elements, capacity() gives the current
number of reserved memory slots; c.capacity()-c.size() is the number of elements that can be
inserted without causing reallocation.
Decreasing the size of a vectordoesn’t decrease its capacity. It simply leaves room for the
vectorto grow into later. If you want to give memory back to the system, assign a new value to the
vector. For example:
v= vector<int>(4,99) ;
A vectorgets the memory it needs for its elements by calling member functions of its allocator
(supplied as a template parameter). The default allocator, called allocator(§19.4.1), uses newto
obtain storage so that it will throw bad_allocif no more storage is obtainable. Other allocators can
use different strategies (see §19.4.2).
The reserve() and capacity() functions are unique to vectorand similar compact containers.
Containers such as listdo not provide equivalents.
16.3.9 Other Member Functions [org.etc]
Many algorithms – including important sort algorithms – involve swapping elements. The obvious
way of swapping (§13.5.2) simply copies elements. However, a vectoris typically implemented
with a structure that acts as a handle (§13.5, §17.1.3) to the elements. Thus, two vectors can be
swapped much more efficiently by interchanging the handles; vector: :swap() does that. The
time difference between this and the default swap() is orders of magnitude in important cases:
template<class T, class A= allocator<T> > class vector{
public:
/ / ...
void swap(vector&) ;
allocator_type get_allocator() const;
};
The get_allocator() function gives the programmer a chance to get hold of a vector’s allocator
(§16.3.1, §16.3.4). Typically, the reason for this is to ensure that data from an application that is
related to a vectoris allocated similarly to the vectoritself (§19.4.1).
16.3.10 Helper Functions [org.algo]
Two vectors can be compared using == and <:
template<class T, class A>
bool std: :operator==(const vector<T,A>& x, const vector<T,A>& y) ;
template<class T, class A>
bool std: :operator<(const vector<T,A>& x, const vector<T,A>& y) ;
Two vectors v1and v2compare equal if v1.size()==v2.size() and v1[n]==v2[n] for every
valid index n. Similarly, < is a lexicographical ordering. In other words, < for vectors could be
defined like this:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
458 Library Organization and Containers Chapter 16
template<class T, class A>
inline bool std: :operator<(const vector<T,A>& x, const vector<T,A>& y)
{
return lexicographical_compare(x.begin() ,x.end() ,y.begin() ,y.end()) ;/ / see §18.9
}
This means that xis less than yif the first element x[i] that is not equal to the corresponding element y[i] is less than y[i] , or x.size()<y.size() with every x[i] equal to its corresponding
y[i].
The standard library also provides !=, <=, >, and >=, with definitions that correspond to those
of == and <.
Because swap() is a member, it is called using the v1.swap(v2) syntax. However, not every
type has a swap() member, so generic algorithms use the conventional swap(a,b) syntax. To
make that work for vectors also, the standard library provides the specialization:
template<class T, class A> void std: :swap(vector<T,A>& x, vector<T,A>& y)
{
x.swap(y) ;
}
16.3.11 Vector<bool> [org.vector.bool]
The specialization (§13.5) vector<bool> is provided as a compact vectorof bool. A boolvariable
is addressable, so it takes up at least one byte. However, it is easy to implement vector<bool> so
that each element takes up only a bit.
The usual vectoroperations work for vector<bool> and retain their usual meanings. In particular, subscripting and iteration work as expected. For example:
void f(vector<bool>& v)
{
for(int i= 0; i<v.size() ; ++i) cin>> v[i] ; / / iterate using subscripting
typedef vector<bool>: :const_iterator VI;
for(VI p= v.begin() ; p!=v.end() ; ++p) cout<<*p; / / iterate using iterators
}
To achieve this, an implementation must simulate addressing of a single bit. Since a pointer cannot
address a unit of memory smaller than a byte, vector<bool>: :iteratorcannot be a pointer. In particular, one cannot rely on bool* as an iterator for a vector<bool>:
void f(vector<bool>& v)
{
bool* p= v.begin() ; / / error: type mismatch
/ / ...
}
A technique for addressing a single bit is outlined in §17.5.3.
The library also provides bitsetas a set of Boolean values with Boolean set operations
(§17.5.3).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 16.4 Advice 459
16.4 Advice [org.advice]
[1] Use standard library facilities to maintain portability; §16.1.
[2] Don’t try to redefine standard library facilities; §16.1.2.
[3] Don’t believe that the standard library is best for everything.
[4] When building a new facility, consider whether it can be presented within the framework
offered by the standard library; §16.3.
[5] Remember that standard library facilities are defined in namespace std; §16.1.2.
[6] Declare standard library facilities by including its header, not by explicit declaration; §16.1.2.
[7] Take advantage of late abstraction; §16.2.1.
[8] Avoid fat interfaces; §16.2.2.
[9] Prefer algorithms with reverse iterators over explicit loops dealing with reverse order; §16.3.2.
[10] Use base() to extract an iteratorfrom a reverse_iterator; §16.3.2.
[11] Pass containers by reference; §16.3.4.
[12] Use iterator types, such as list<char>: :iterator, rather than pointers to refer to elements of a
container; §16.3.1.
[13] Use constiterators where you don’t need to modify the elements of a container; §16.3.1.
[14] Use at(), directly or indirectly, if you want range checking; §16.3.3.
[15] Use push_back() or resize() on a container rather than realloc() on an array; §16.3.5.
[16] Don’t use iterators into a resized vector; §16.3.8.
[17] Use reserve() to avoid invalidating iterators; §16.3.8.
[18] When necessary, use reserve() to make performance predictable; §16.3.8.
16.5 Exercises [org.exercises]
The solutions to several exercises for this chapter can be found by looking at the source text of an
implementation of the standard library. Do yourself a favor: try to find your own solutions before
looking to see how your library implementer approached the problems.
1. (∗1.5) Create a vector<char> containing the letters of the alphabet in order. Print the elements
of that vector in order and in reverse order.
2. (∗1.5) Create a vector<string> and read a list of names of fruits from cininto it. Sort the list
and print it.
3. (∗1.5) Using the vectorfrom §16.5[2], write a loop to print the names of all fruits with the initial letter a.
4. (∗1) Using the vectorfrom §16.5[2], write a loop to delete all fruits with the initial letter a.
5. (∗1) Using the vectorfrom §16.5[2], write a loop to delete all citrus fruits.
6. (∗1.5) Using the vectorfrom §16.5[2], write a loop to delete all fruits that you don’t like.
7. (∗2) Complete the Vector, List, and Itorclasses from §16.2.1.
8. (∗2.5) Given an Itorclass, consider how to provide iterators for forwards iteration, backwards
iteration, iteration over a container that might change during an iteration, and iteration over an
immutable container. Organize this set of containers so that a user can interchangeably use iterators that provide sufficient functionality for an algorithm. Minimize replication of effort in the
implementation of the containers. What other kinds of iterators might a user need? List the
strengths and weaknesses of your approach.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
460 Library Organization and Containers Chapter 16
9. (∗2) Complete the Container, Vector, and Listclasses from §16.2.2.
10. (∗2.5) Generate 10,000 uniformly distributed random numbers in the range 0 to 1,023 and store
them in (a) an standard library vector, (b) a Vectorfrom §16.5[7], and (3) a Vectorfrom
§16.5[9]. In each case, calculate the arithmetic mean of the elements of the vector (as if you
didn’t know it already). Time the resulting loops. Estimate, measure, and compare the memory
consumption for the three styles of vectors.
11. (∗1.5) Write an iterator to allow Vectorfrom §16.2.2 to be used as a container in the style of
§16.2.1.
12. (∗1.5) Write a class derived from Containerto allow Vectorfrom §16.2.1 to be used as a container in the style of §16.2.2.
13. (∗2) Write classes to allow Vectorfrom §16.2.1 and Vectorfrom §16.2.2 to be used as standard
containers.
14. (∗2) Write a template that implements a container with the same member functions and member
types as the standard vectorfor an existing (nonstandard, non-student-exercise) container type.
Do not modify the (pre)existing container type. How would you deal with functionality offered
by the nonstandard vectorbut not by the standard vector?
15. (∗1.5) Outline the possible behavior of duplicate_elements() from §16.3.6 for a
vector<string> with the three elements don´t do this.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
_ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
17 _ _ _______________________________________________________________________________________________________________________________ _______________________________________ ________________________________
Standard Containers
Now is a good time to put your work
on a firm theoretical foundation.
– Sam Morgan
Standard containers — container and operation summaries — efficiency — representation — element requirements — sequences — vector— list— deque— adapters —
stack— queue— priority_queue— associative containers — map— comparisons —
multimap— set— multiset— ‘‘almost containers’’ — bitset— arrays — hash tables
— implementing a hash_map— advice — exercises.
17.1 Standard Containers [cont.intro]
The standard library defines two kinds of containers: sequences and associative containers. The
sequences are all much like vector(§16.3). Except where otherwise stated, the member types and
functions mentioned for vectorcan also be used for any other container and produce the same
effect. In addition, associative containers provide element access based on keys (§3.7.4).
Built-in arrays (§5.2), strings (Chapter 20), valarrays (§22.4), and bitsets (§17.5.3) hold elements and can therefore be considered containers. However, these types are not fully-developed
standard containers. If they were, that would interfere with their primary purpose. For example, a
built-in array cannot both hold its own size and remain layout-compatible with C arrays.
A key idea for the standard containers is that they should be logically interchangeable wherever
reasonable. The user can then choose between them based on efficiency concerns and the need for
specialized operations. For example, if lookup based on a key is common, a map(§17.4.1) can be
used. On the other hand, if general list operations dominate, a list(§17.2.2) can be used. If many
additions and removals of elements occur at the ends of the container, a deque(double-ended
queue, §17.2.3), a stack(§17.3.1), or a queue(§17.3.2) should be considered. In addition, a user
can design additional containers to fit into the framework provided by the standard containers
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
462 Standard Containers Chapter 17
(§17.6). By default, a vector(§16.3) should be used; it will be implemented to perform well over a
wide range of uses.
The idea of treating different kinds of containers – and more generally all kinds of information
sources – in uniform ways leads to the notion of generic programming (§2.7.2, §3.8). The standard
library provides many generic algorithms to support this idea (Chapter 18). Such algorithms can
save the programmer from having to deal directly with details of individual containers.
17.1.1 Operations Summary [cont.operations]
This section lists the common and almost common members of the standard containers. For more
details, read your standard headers (<vector>, <list>, <map>, etc.; §16.1.2). __________________________________________________________________________
__________________________________________________________________________ Member Types (§16.3.1) __________________________________________________________________________
value_typeType of element.
allocator_typeType of memory manager.
size_typeType of subscripts, element counts, etc.
difference_typeType of difference between iterators.
iteratorBehaves like value_type*.
const_iteratorBehaves like const value_type*.
reverse_iteratorView container in reverse order; like value_type*.
const_reverse_iteratorView container in reverse order; like const value_type*.
referenceBehaves like value_type&.
const_referenceBehaves like const value_type&.
key_typeType of key (for associative containers only).
mapped_typeType of mapped_value(for associative containers only).
__________________________________________________________________________ key_compareType of comparison criterion (for associative containers only). 



































A container can be viewed as a sequence either in the order defined by the container’s iteratoror in
reverse order. For an associative container, the order is based on the container’s comparison criterion (by default <):
_ _____________________________________________________
_ _____________________________________________________ Iterators (§16.3.2) _ _____________________________________________________
begin()Points to first element.
end()Points to one-past-last element.
rbegin()Points to first element of reverse sequence.
_ _____________________________________________________ rend()Points to one-past-last element of reverse sequence. 













Some elements can be accessed directly: _ ______________________________________________
_ ______________________________________________ Element Access (§16.3.3) _ ______________________________________________
front()First element.
back()Last element.
[]Subscripting, unchecked access (not for list).
_ ______________________________________________ at()Subscripting, checked access (not for list). 













The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.1.1 Operations Summary 463
Most containers provide efficient operations at the end (back) of their sequence of elements. In
addition, lists and deques provide the equivalent operations on the start (front) of their sequences: _ _____________________________________________________
_ _____________________________________________________ Stack and Queue Operations (§16.3.5, §17.2.2.2) _ _____________________________________________________
push_back()Add to end.
pop_back()Remove last element.
push_front()Add new first element (for list and deque only).
_ _____________________________________________________ pop_front()Remove first element (for list and deque only). 













Containers provide list operations: _ ___________________________________________________
_ ___________________________________________________ List Operations (§16.3.6) _ ___________________________________________________
insert(p,x)Add xbefore p.
insert(p,n,x)Add ncopies of xbefore p.
insert(p,first,last)Add elements from [first:last[ before p.
erase(p)Remove element at p.
erase(first,last)Erase [first:last[.
_ ___________________________________________________
clear()Erase all elements. 

















All containers provide operations related to the number of elements and a few other operations: _ ________________________________________________________________
_ ________________________________________________________________ Other Operations (§16.3.8, §16.3.9, §16.3.10) _ ________________________________________________________________
size()Number of elements.
empty()Is the container empty?
max_size()Size of the largest possible container.
capacity()Space allocated for vector(for vector only).
reserve()Reserve space for future expansion (for vector only).
resize()Change size of container (for vector, list, and deque only).
swap()Swap elements of two containers.
get_allocator()Get a copy of the container’s allocator.
==Is the content of two containers the same?
!=Is the content of two containers different?
_ ________________________________________________________________ <Is one container lexicographically before another? 




























Containers provide a variety of constructors and assignment operations: _ __________________________________________________________________
_ __________________________________________________________________ Constructors, etc. (§16.3.4) _ __________________________________________________________________
container()Empty container.
container(n) nelements default value (not for associative containers).
container(n,x) ncopies of x(not for associative containers).
container(first,last)Initial elements from [first:last[.
container(x)Copy constructor; initial elements from container x.
_ __________________________________________________________________
˜container()Destroy the container and all of its elements. 

















The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
464 Standard Containers Chapter 17
_ ____________________________________________________________
_ ____________________________________________________________ Assignments (§16.3.4) _ ____________________________________________________________
operator=(x)Copy assignment; elements from container x.
assign(n,x)Assign ncopies of x(not for associative containers).
_ ____________________________________________________________
assign(first,last)Assign from [first:last[. 











Associative containers provide lookup based on keys: _ ______________________________________________________________________
_ ______________________________________________________________________ Associative Operations (§17.4.1) _ ______________________________________________________________________
operator[](k)Access the element with key k(for containers with unique keys).
find(k)Find the element with key k.
lower_bound(k)Find the first element with key k.
upper_bound(k)Find the first element with key greater than k.
equal_range(k)Find the lower_boundand upper_boundof elements with key k.
key_comp()Copy of the key comparison object.
_ ______________________________________________________________________
value_comp()Copy of the mapped_valuecomparison object. 



















In addition to these common operations, most containers provide a few specialized operations.
17.1.2 Container Summary [cont.summary]
The standard containers can be summarized like this: _ _______________________________________________________________________
_ _______________________________________________________________________ Standard Container Operations _ _______________________________________________________________________
[] List Front Back (Stack) Iterators
Operations Operations Operations
§16.3.3 §16.3.6 §17.2.2.2 §16.3.5 §19.2.1
_ _______________________________________________________________________ §17.4.1.3 §20.3.9 §20.3.9 §20.3.12
vectorconst O(n)+ const+ Ran
listconst const const Bi
_ _______________________________________________________________________ dequeconst O(n) const const Ran
stackconst+
queueconst const+
_ _______________________________________________________________________ priority_queueO(log(n)) O(log(n))
mapO(log(n)) O(log(n))+ Bi
multimapO(log(n))+ Bi
setO(log(n))+ Bi
_ _______________________________________________________________________ multisetO(log(n))+ Bi
stringconst O(n)+ O(n)+ const+ Ran
arrayconst Ran
valarrayconst Ran
_ _______________________________________________________________________ bitsetconst 















































In the iterators column, Ranmeans random-access iterator and Bimeans bidirectional iterator; the
operations for a bidirectional operator are a subset of those of a random-access iterator (§19.2.1).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.1.2 Container Summary 465
Other entries are measures of the efficiency of the operations. A constentry means the operation
takes an amount of time that does not depend on the number of elements in the container. Another
conventional notation for constant time is O(1). An O(n) entry means the entry takes time proportional to the number of elements involved. A + suffix indicates that occasionally a significant
extra cost is incurred. For example, inserting an element into a listhas a fixed cost (so it is listed as
const), whereas the same operation on a vectorinvolves moving the elements following the insertion point (so it is listed as O(n)). Occasionally, all elements must be relocated (so I added a +).
The ‘‘big O’’ notation is conventional. I added the + for the benefit of programmers who care
about predictability in addition to average performance. A conventional term for O(n)+ is
amortized linear time.
Naturally, if a constant is large it can dwarf a small cost proportional to the number of elements.
However, for large data structures consttends to mean ‘‘cheap,’’ O(n) to mean ‘‘expensive,’’ and
O(log(n)) to mean ‘‘fairly cheap.’’ For even moderately large values of n, O(log(n)) is closer
to constant time than to O(n). People who care about cost must take a closer look. In particular,
they must understand what elements are counted to get the n. No basic operation is ‘‘very expensive,’’ that is, O(n*n) or worse.
Except for string, the measures of costs listed here reflect requirements in the standard. The
stringestimates are my assumptions.
These measures of complexity and cost are upper bounds. The measures exist to give users
some guidance as to what they can expect from implementations. Naturally, implementers will try
to do better in important cases.
17.1.3 Representation [cont.rep]
The standard doesn’t prescribe a particular representation for each standard container. Instead, the
standard specifies the container interfaces and some complexity requirements. Implementers will
choose appropriate and often cleverly optimized implementations to meet the general requirements.
A container will almost certainly be represented by a data structure holding the elements accessed
through a handle holding size and capacity information. For a vector, the element data structure is
most likely an array:
size
rep
. . elements . . . . . . . . . . . . . . . ..
.
. .. . . . . . . . . . . . . . . .
.
.
. extra space
vector:
Similarly, a listis most likely represented by a set of links pointing to the elements:
list: rep
elements:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
466 Standard Containers Chapter 17
A mapis most likely implemented as a (balanced) tree of nodes pointing to (key,value) pairs:
rep
... map:
node
node
(key,value) pairs:
A stringmight be implemented as outlined in §11.12 or maybe as a sequence of arrays holding a
few characters each:
string: rep
segment descriptors
string segments:
17.1.4 Element Requirements [cont.elem]
Elements in a container are copies of the objects inserted. Thus, to be an element of a container, an
object must be of a type that allows the container implementation to copy it. The container may
copy elements using a copy constructor or an assignment; in either case, the result of the copy must
be an equivalent object. This roughly means that any test for equality that you can devise on the
value of the objects must deem the copy equal to the original. In other words, copying an element
must work much like an ordinary copy of built-in types (including pointers). For example,
X& X: :operator=(const X& a) / / proper assignment operator
{
/ / copy all of a’s members to *this
return*this;
}
makes Xacceptable as an element type for a standard container, but
void Y: :operator=(const Y& a) / / improper assignment operator
{
/ / zero out all of a’s members
}
renders Yunsuitable because Y’s assignment has neither the conventional return type nor the conventional semantics.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.1.4 Element Requirements 467
Some violations of the rules for standard containers can be detected by a compiler, but others
cannot and might then cause unexpected behavior. For example, a copy operation that throws an
exception might leave a partially copied element behind. It could even leave the container itself in
a state that could cause trouble later. Such copy operations are themselves bad design (§14.4.6.1).
When copying elements isn’t right, the alternative is to put pointers to objects into containers
instead of the objects themselves. The most obvious example is polymorphic types (§2.5.4,
§12.2.6). For example, we use vector<Shape*> rather than vector<Shape> to preserve polymorphic behavior.
17.1.4.1 Comparisons [cont.comp]
Associative containers require that their elements can be ordered. So do many operations that can
be applied to containers (for example sort()). By default, the < operator is used to define the
order. If < is not suitable, the programmer must provide an alternative (§17.4.1.5, §18.4.2). The
ordering criterion must define a strict weak ordering. Informally, this means that both less-than
and equality must be transitive. That is, for an ordering criterion cmp:
[1] cmp(x,x) is false.
[2] If cmp(x,y) and cmp(y,z), then cmp(x,z).
[3] Define equiv(x,y) to be !(cmp(x,y)||cmp(y,x)). If equiv(x,y) and equiv(y,z),
then equiv(x,z).
Consider:
template<class Ran> void sort(Ran first, Ran last) ; / / use < for comparison
template<class Ran, class Cmp> void sort(Ran first, Ran last, Cmp cmp) ;/ / use cmp
The first version uses < and the second uses a user-supplied comparison cmp. For example, we
might decide to sort fruitusing a comparison that isn’t case-sensitive. We do that by defining a
function object (§11.9, §18.4) that does the comparison when invoked for a pair of strings:
class Nocase{ / / case-insensitive string compare
public:
bool operator()(const string&, const string&) const;
};
bool Nocase: :operator()(const string& x, const string& y) const
/ / return true if x is lexicographically less than y, not taking case into account
{
string: :const_iterator p= x.begin() ;
string: :const_iterator q= y.begin() ;
while(p!=x.end() && q!=y.end() && toupper(*p)==toupper(*q)) {
++p;
++q;
}
if(p== x.end()) return q!= y.end() ;
return toupper(*p) < toupper(*q) ;
}
We can call sort() using that comparison criterion. For example, given:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
468 Standard Containers Chapter 17
fruit:
apple pear Apple Pear lemon
Sorting using sort(fruit.begin() ,fruit.end() ,Nocase()) would yield:
fruit:
Apple apple lemon Pear pear
whereas plain sort(fruit.begin() ,fruit.end()) would give:
fruit:
Apple Pear apple lemon pear
assuming a character set in which uppercase letters precede lowercase letters.
Beware that < on C-style strings (that is, char*) does not define lexicographical order
(§13.5.2). Thus, associative containers will not work as most people would expect them to when
C-style strings are used as keys. To make them work properly, a less-than operation that compares
based on lexicographical order must be used. For example:
struct Cstring_less{
bool operator()(const char* p, const char* q) const{ return strcmp(p,q)<0; }
};
map<char*,int,Cstring_less> m; / / map that uses strcmp() to compare const char* keys
17.1.4.2 Other Relational Operators [cont.relops]
By default, containers and algorithms use < when they need to do a less-than comparison. When
the default isn’t right, a programmer can supply a comparison criterion. However, no mechanism is
provided for also passing an equality test. Instead, when a programmer supplies a comparison cmp,
equality is tested using two comparisons. For example:
if(x== y) / / not done where the user supplied a comparison
if(!cmp(x,y) && !cmp(y,x)) / / done where the user supplied a comparison cmp
This saves us from having to add an equality parameter to every associative container and most
algorithms. It may look expensive, but the library doesn’t check for equality very often, and in
50% of the cases, only a single call of cmp() is needed.
Using an equivalence relationship defined by less-than (by default <) rather than equality (by
default ==) also has practical uses. For example, associative containers (§17.4) compare keys
using an equivalence test !(cmp(x,y)||cmp(y,x)). This implies that equivalent keys need not
be equal. For example, a multimap(§17.4.2) that uses case-insensitive comparison as its comparison criteria will consider the strings Last, last, lAst, laSt, and lasTequivalent, even though == for
strings deems them different. This allows us to ignore differences we consider insignificant when
sorting.
Given < and ==, we can easily construct the rest of the usual comparisons. The standard library
defines them in the namespace std: :rel_opsand presents them in <utility>:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.1.4.2 Other Relational Operators 469
template<class T> bool rel_ops: :operator!=(const T& x, const T& y) { return!(x==y) ; }
template<class T> bool rel_ops: :operator>(const T& x, const T& y) { return y<x; }
template<class T> bool rel_ops: :operator<=(const T& x, const T& y) { return!(y<x) ; }
template<class T> bool rel_ops: :operator>=(const T& x, const T& y) { return!(x<y) ; }
Placing these operations in rel_opsensures that they are easy to use when needed, yet they don’t
get created implicitly unless extracted from that namespace:
void f()
{
using namespace std;
/ / !=, >, etc., not generated by default
}
void g()
{
using namespace std;
using namespace std: :rel_ops;
/ / !=, >, etc., generated by default
}
The !=, etc., operations are not defined directly in stdbecause they are not always needed and
sometimes their definition would interfere with user code. For example, if I were writing a generalized math library, I would want my relational operators and not the standard library versions.
17.2 Sequences [cont.seq]
Sequences follow the pattern described for vector(§16.3). The fundamental sequences provided by
the standard library are:
vector list deque
From these,
stack queue priority_queue
are created by providing suitable interfaces. These sequences are called container adapters,
sequence adapters, or simply adapters (§17.3).
17.2.1 Vector [cont.vector]
The standard vectoris described in detail in §16.3. The facilities for reserving space (§16.3.8) are
unique to vector. By default, subscripting using [] is not range checked. If a check is needed, use
at() (§16.3.3), a checked vector (§3.7.1), or a checked iterator (§19.3). A vectorprovides
random-access iterators (§19.2.1).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
470 Standard Containers Chapter 17
17.2.2 List [cont.list]
A listis a sequence optimized for insertion and deletion of elements. Compared to vector(and
deque; §17.2.3), subscripting would be painfully slow, so subscripting is not provided for list.
Consequently, listprovides bidirectional iterators (§19.2.1) rather than random-access iterators.
This implies that a listwill typically be implemented using some form of a doubly-linked list (see
§17.8[16]).
A listprovides all of the member types and operations offered by vector(§16.3), with the
exceptions of subscripting, capacity(), and reserve():
template<class T, class A= allocator<T> > class std: :list{
public:
/ / types and operations like vector’s, except [], at(), capacity(), and reserve()
/ / ...
};
17.2.2.1 Splice, Sort, and Merge [cont.splice]
In addition to the general sequence operations, listprovides several operations specially suited for
list manipulation:
template<class T, class A= allocator<T> > class list{
public:
/ / ...
/ / list-specific operations:
void splice(iterator pos, list& x) ; / / move all elements from x to before
/ / pos in this list without copying.
void splice(iterator pos, list& x, iterator p) ; / / move *p from x to before
/ / pos in this list without copying.
void splice(iterator pos, list& x, iterator first, iterator last) ;
void merge(list&) ; / / merge sorted lists
template<class Cmp> void merge(list&, Cmp) ;
void sort() ;
template<class Cmp> void sort(Cmp) ;
/ / ...
};
These listoperations are all stable; that is, they preserve the relative order of elements that have
equivalent values.
The fruitexamples from §16.3.6 work with fruitdefined to be a list. In addition, we can
extract elements from one list and insert them into another by a single ‘‘splice’’ operation. Given:
fruit:
apple pear
citrus:
orange grapefruit lemon
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.2.2.1 Splice, Sort, and Merge 471
we can splice the orangefrom citrusinto fruitlike this:
list<string>: :iterator p= find_if(fruit.begin() ,fruit.end() ,initial(´p´)) ;
fruit.splice(p,citrus,citrus.begin()) ;
The effect is to remove the first element from citrus(citrus.begin()) and place it just before the
first element of fruitwith the initial letter p, thereby giving:
fruit:
apple orange pear
citrus:
grapefruit lemon
Note that splice() doesn’t copy elements the way insert() does (§16.3.6). It simply modifies the
listdata structures that refer to the element.
In addition to splicing individual elements and ranges, we can splice() all elements of a list:
fruit.splice(fruit.begin() ,citrus) ;
This yields:
fruit:
grapefruit lemon apple orange pear
citrus:
<empty>
Each version of splice() takes as its second argument the listfrom which elements are taken. This
allows elements to be removed from their original list. An iterator alone wouldn’t allow that
because there is no general way to determine the container holding an element given only an iterator to that element (§18.6).
Naturally, an iterator argument must be a valid iterator for the listinto which it is supposed to
point. That is, it must point to an element of that listor be the list’s end(). If not, the result is
undefined and possibly disastrous. For example:
list<string>: :iterator p= find_if(fruit.begin() ,fruit.end() ,initial(´p´)) ;
fruit.splice(p,citrus,citrus.begin()) ; / / ok
fruit.splice(p,citrus,fruit.begin()) ; / / error: fruit.begin() doesn’t point into citrus
citrus.splice(p,fruit,fruit.begin()) ; / / error: p doesn’t point into citrus
The first splice() is ok even though citrusis empty.
A merge() combines two sorted lists by removing the elements from one listand entering
them into the other while preserving order. For example,
f1:
apple quince pear
f2:
lemon grapefruit orange lime
can be sorted and merged like this:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
472 Standard Containers Chapter 17
f1.sort() ;
f2.sort() ;
f1.merge(f2) ;
This yields:
f1:
apple grapefruit lemon lime orange pear quince
f2:
<empty>
If one of the lists being merged is not sorted, merge() will still produce a list containing the union
of elements of the two lists. However, there are no guarantees made about the order of the result.
Like splice(), merge() refrains from copying elements. Instead, it removes elements from
the source list and splices them into the target list. After an x.merge(y), the ylist is empty.
17.2.2.2 Front Operations [cont.front]
Operations that refer to the first element of a listare provided to complement the operations referring to the last element provided by every sequence (§16.3.6):
template<class T, class A= allocator<T> > class list{
public:
/ / ...
/ / element access:
reference front() ; / / reference to first element
const_reference front() const;
void push_front(const T&) ; / / add new first element
void pop_front() ; / / remove first element
/ / ...
};
The first element of a container is called its front. For a list, front operations are as efficient and
convenient as back operations (§16.3.5). When there is a choice, back operations should be preferred over front operations. Code written using back operations can be used for a vectoras well as
for a list. So if there is a chance that the code written using a listwill ever evolve into a generic
algorithm applicable to a variety of containers, it is best to prefer the more widely available back
operations. This is a special case of the rule that to achieve maximal flexibility, it is usually wise to
use the minimal set of operations to do a task (§17.1.4.1).
17.2.2.3 Other Operations [cont.list.etc]
Insertion and removal of elements are particularly efficient for lists. This, of course, leads people
to prefer lists when these operations are frequent. That, in turn, makes it worthwhile to support
common ways of removing elements directly:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.2.2.3 Other Operations 473
template<class T, class A= allocator<T> > class list{
public:
/ / ...
void remove(const T& val) ;
template<class Pred> void remove_if(Pred p) ;
void unique() ; / / remove duplicates using ==
template<class BinPred> void unique(BinPred b) ; / / remove duplicates using b
void reverse() ; / / reverse order of elements
};
For example, given
fruit:
apple orange grapefruit lemon orange lime pear quince
we can remove all elements with the value "orange" like this:
fruit.remove("orange") ;
yielding:
fruit:
apple grapefruit lemon lime pear quince
Often, it is more interesting to remove all elements that meet some criterion rather than simply all
elements with a given value. The remove_if() operation does that. For example,
fruit.remove_if(initial(´l´)) ;
removes every element with the initial ´l´ from fruitgiving:
fruit:
apple grapefruit pear quince
A common reason for removing elements is to eliminate duplicates. The unique() operation is
provided for that. For example:
fruit.sort() ;
fruit.unique() ;
The reason for sorting is that uniqueremoves only duplicates that appear consecutively. For example, had fruit contained:
apple pear apple apple pear
a simple fruit.unique() would have produced
apple pear apple pear
whereas sorting first gives:
apple pear
If only certain duplicates should be eliminated, we can provide a predicate to specify which
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
474 Standard Containers Chapter 17
duplicates we want to remove. For example, we might define a binary predicate (§18.4.2)
initial2(x) to compare strings that have the initial xbut yield falsefor every stringthat doesn’t.
Given:
pear pear apple apple
we can remove consecutive duplicates of every fruitwith the initial pby a call
fruit.unique(initial2(´p´)) ;
This would give
pear apple apple
As noted in §16.3.2, we sometimes want to view a container in reverse order. For a list, it is possible to reverse the elements so that the first becomes the last, etc., without copying the elements.
The reverse() operation is provided to do that. Given:
fruit:
banana cherry lime strawberry
fruit.reverse() produces:
fruit:
strawberry lime cherry banana
An element that is removed from a list is destroyed. However, note that destroying a pointer does
not imply that the object it points to is deleted. If you want a container of pointers that deletes elements pointed to when the pointer is removed from the container or the container is destroyed, you
must write one yourself (§17.8[13]).
17.2.3 Deque [cont.deque]
A deque(it rhymes with check) is a double-ended queue. That is, a dequeis a sequence optimized
so that operations at both ends are about as efficient as for a list, whereas subscripting approaches
the efficiency of a vector:
template<class T, class A= allocator<T> > class std: :deque{
/ / types and operations like vector (§16.3.3, §16.3.5, §16.3.6)
/ / plus front operations (§17.2.2.2) like list
};
Insertion and deletion of elements ‘‘in the middle’’ have vector-like (in)efficiencies rather than
list-like efficiencies. Consequently, a dequeis used where additions and deletions take place ‘‘at
the ends.’’ For example, we might use a dequeto model a section of a railroad or to represent a
deck of cards in a game:
deque<car> siding_no_3;
deque<Card> bonus;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.3 Sequence Adapters 475
17.3 Sequence Adapters [cont.adapters]
The vector, list, and dequesequences cannot be built from each other without loss of efficiency.
On the other hand, stacks and queues can be elegantly and efficiently implemented using those
three basic sequences. Therefore, stackand queueare defined not as separate containers, but as
adaptors of basic containers.
A container adapter provides a restricted interface to a container. In particular, adapters do not
provide iterators; they are intended to be used only through their specialized interfaces.
The techniques used to create a container adapter from a container are generally useful for nonintrusively adapting the interface of a class to the needs of its users.
17.3.1 Stack [cont.stack]
The stackcontainer adapter is defined in <stack>. It is so simple that the best way to describe it is
to present an implementation:
template<class T, class C= deque<T> > class std: :stack{
protected:
C c;
public:
typedef typename C: :value_type value_type;
typedef typename C: :size_type size_type;
typedef C container_type;
explicit stack(const C& a= C()) : c(a) { }
bool empty() const{ return c.empty() ; }
size_type size() const{ return c.size() ; }
value_type& top() { return c.back() ; }
const value_type& top() const{ return c.back() ; }
void push(const value_type& x) { c.push_back(x) ; }
void pop() { c.pop_back() ; }
};
That is, a stackis simply an interface to a container of the type passed to it as a template argument.
All stackdoes is to eliminate the non-stack operations on its container from the interface and give
back(), push_back(), and pop_back() their conventional names: top(), push(), and pop().
By default, a stackmakes a dequeto hold its elements, but any sequence that provides back(),
push_back(), and pop_back() can be used. For example:
stack<char> s1; / / uses a deque<char> to store elements of type char
stack< int,vector<int> > s2; / / uses a vector<int> to store elements of type int
It is possible to supply an existing container to initialize a stack. For example:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
476 Standard Containers Chapter 17
void print_backwards(vector<int>& v)
{
stack<int> state(v) ; / / initialize state from v
while(state.size()) {
cout<< state.top() ;
state.pop() ;
}
}
However, the elements of a container argument are copied, so supplying an existing container can
be expensive.
Elements are added to a stackusing push_back() on the container that is used to store the elements. Consequently, a stackcannot overflow as long as there is memory available on the machine
for the container to acquire (using its allocator; see §19.4).
On the other hand, a stackcan underflow:
void f()
{
stack<int> s;
s.push(2) ;
if(s.empty()) { / / underflow is preventable
/ / don’t pop
}
else{ / / but not impossible
s.pop() ; / / fine: s.size() becomes 0
s.pop() ; / / undefined effect, probably bad
}
}
Note that one does not pop() an element to use it. Instead, the top() is accessed and then
pop()’d when it is no longer needed. This is not too inconvenient, and it is more efficient when
the pop() isn’t necessary:
void f(stack<char>& s)
{
if(s.top()==´c´) s.pop() ; / / remove optional initial ’c’
/ / ...
}
Unlike fully developed containers, stack(like other container adapters) doesn’t have an allocator
template parameter. Instead, the stackand its users rely on the allocator from the container used to
implement the stack.
17.3.2 Queue [cont.queue]
Defined in <queue>, a queueis an interface to a container that allows the insertion of elements at
the back() and the extraction of elements at the front():
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.3.2 Queue 477
template<class T, class C= deque<T> > class std: :queue{
protected:
C c;
public:
typedef typename C: :value_type value_type;
typedef typename C: :size_type size_type;
typedef C container_type;
explicit queue(const C& a= C()) : c(a) { }
bool empty() const{ return c.empty() ; }
size_type size() const{ return c.size() ; }
value_type& front() { return c.front() ; }
const value_type& front() const{ return c.front() ; }
value_type& back() { return c.back() ; }
const value_type& back() const{ return c.back() ; }
void push(const value_type& x) { c.push_back(x) ; }
void pop() { c.pop_front() ; }
};
By default, a queuemakes a dequeto hold its elements, but any sequence that provides front(),
back(), push_back(), and pop_front() can be used. Because a vectordoes not provide
pop_front(), a vectorcannot be used as the underlying container for a queue.
Queues seem to pop up somewhere in every system. One might define a server for a simple
message-based system like this:
struct Message{
/ / ...
};
void server(queue<Message>& q)
{
while(!q.empty()) {
Message& m= q.front() ; / / get hold of message
m.service() ; / / call function to serve request
q.pop() ; / / destroy message
}
}
Messages would be put on the queueusing push().
If the requester and the server are running in different processes or threads, some form of synchronization of the queue access would be necessary. For example:
void server2(queue<Message>& q, Lock& lck)
{
while(!q.empty()) {
Message m;
{ LockPtr h(lck) ; / / hold lock only while extracting message (see §14.4.7)
if(q.empty()) return; / / somebody else got the message
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
478 Standard Containers Chapter 17
m= q.front() ;
q.pop() ;
}
m.service() ; / / call function to serve request
}
}
There is no standard definition of concurrency or locking in C++ or in the world in general. Have a
look to see what your system has to offer and how to access it from C++ (§17.8[8]).
17.3.3 Priority Queue [cont.pqueue]
A priority_queueis a queue in which each element is given a priority that controls the order in
which the elements get to be top():
template<class T, class C= vector<T>, class Cmp= less<typename C: :value_type> >
class std: :priority_queue{
protected:
C c;
Cmp cmp;
public:
typedef typename C: :value_type value_type;
typedef typename C: :size_type size_type;
typedef C container_type;
explicit priority_queue(const Cmp& a1= Cmp() , const C& a2= C())
: c(a2) , cmp(a1) { }
template<class In>
priority_queue(In first, In last, const Cmp& = Cmp() , const C& = C()) ;
bool empty() const{ return c.empty() ; }
size_type size() const{ return c.size() ; }
const value_type& top() const{ return c.front() ; }
void push(const value_type&) ;
void pop() ;
};
The declaration of priority_queueis found in <queue>.
By default, the priority_queuesimply compares elements using the < operator and pop()
returns the largest element:
struct Message{
int priority;
bool operator<(const Message& x) const{ return priority< x.priority; }
/ / ...
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.3.3 Priority Queue 479
void server(priority_queue<Message>& q, Lock& lck)
{
while(!q.empty()) {
Message m;
{ LockPtr h(lck) ; / / hold lock only while extracting message (see §14.4.7)
if(q.empty()) return; / / somebody else got the message
m= q.top() ;
q.pop() ;
}
m.service() ; / / call function to serve request
}
}
This example differs from the queueexample (§17.3.2) in that messageswith higher priority will
get served first. The order in which elements with equal priority come to the head of the queue is
not defined. Two elements are considered of equal priority if neither has higher priority than the
other (§17.4.1.5).
An alternative to < for comparison can be provided as a template argument. For example, we
could sort strings in a case-insensitive manner by placing them in
priority_queue<string,Nocase> pq; / / use Nocase::operator()() for comparisons (§17.1.4.1)
using pq.push() and then retrieving them using pq.top() and pq.pop().
Objects defined by templates given different template arguments are of different types
(§13.6.3.1). For example:
void f(priority_queue<string>& pq1)
{
pq= pq1; / / error: type mismatch
}
We can supply a comparison criterion without affecting the type of a priority_queueby providing
a comparison object of the appropriate type as a constructor argument. For example:
struct String_cmp{ / / type used to express comparison criteria at run time
String_cmp(int n= 0) ; / / use comparison criteria n
/ / ...
};
void g(priority_queue<string,String_cmp>& pq)
{
priority_queue<string> pq2(String_cmp(nocase)) ;
pq= pq2; / / ok: pq and pq2 are of the same type, pq now also uses String_cmp(nocase)
}
Keeping elements in order isn’t free, but it needn’t be expensive either. One useful way of implementing a priority_queueis to use a tree structure to keep track of the relative positions of elements. This gives an O(log(n)) cost of both push() and pop().
By default, a priority_queuemakes a vectorto hold its elements, but any sequence that provides front(), push_back(), pop_back(), and random iterators can be used. A priority_queue
is most likely implemented using a heap(§18.8).
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
480 Standard Containers Chapter 17
17.4 Associative Containers [cont.assoc]
An associative array is one of the most useful general, user-defined types. In fact, it is often a
built-in type in languages primarily concerned with text processing and symbolic processing. An
associative array, often called a map and sometimes called a dictionary, keeps pairs of values.
Given one value, called the key, we can access the other, called the mapped value. An associative
array can be thought of as an array for which the index need not be an integer:
template<class K, class V> class Assoc{
public:
V& operator[](const K&) ; / / return a reference to the V corresponding to K
/ / ...
};
Thus, a key of type Knames a mapped value of type V.
Associative containers are a generalization of the notion of an associative array. The mapis a
traditional associative array, where a single value is associated with each unique key. A multimap
is an associative array that allows duplicate elements for a given key, and setand multisetcan be
seen as degenerate associative arrays in which no value is associated with a key.
17.4.1 Map [cont.map]
A mapis a sequence of (key,value) pairs that provides for fast retrieval based on the key. At most
one value is held for each key; in other words, each key in a mapis unique. A mapprovides bidirectional iterators (§19.2.1).
The maprequires that a less-than operation exist for its key types (§17.1.4.1) and keeps its elements sorted so that iteration over a mapoccurs in order. For elements for which there is no obvious order or when there is no need to keep the container sorted, we might consider using a
hash_map(§17.6).
17.4.1.1 Types [cont.map.types]
A maphas the usual container member types (§16.3.1) plus a few relating to its specific function:
template<class Key, class T, class Cmp= less<Key>,
class A= allocator< pair<const Key,T> > >
class std: :map{
public:
/ / types:
typedef Key key_type;
typedef T mapped_type;
typedef pair<const Key, T> value_type;
typedef Cmp key_compare;
typedef A allocator_type;
typedef typename A: :reference reference;
typedef typename A: :const_reference const_reference;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.4.1.1 Types 481
typedefimplementation_defined1 iterator;
typedefimplementation_defined2 const_iterator;
typedef typename A: :size_type size_type;
typedef typename A: :difference_type difference_type;
typedef std: :reverse_iterator<iterator> reverse_iterator;
typedef std: :reverse_iterator<const_iterator> const_reverse_iterator;
/ / ...
};
Note that the value_typeof a mapis a (key,value) pair. The type of the mapped values is referred
to as the mapped_type. Thus, a mapis a sequence of pair<const Key,mapped_type> elements.
As usual, the actual iterator types are implementation-defined. Since a mapmost likely is
implemented using some form of a tree, these iterators usually provide some form of tree traversal.
The reverse iterators are constructed from the standard reverse_iteratortemplates (§19.2.5).
17.4.1.2 Iterators and Pairs [cont.map.iter]
A mapprovides the usual set of functions that return iterators (§16.3.2):
template<class Key, class T, class Cmp= less<Key>,
class A= allocator< pair<const Key,T> > > class map{
public:
/ / ...
/ / iterators:
iterator begin() ;
const_iterator begin() const;
iterator end() ;
const_iterator end() const;
reverse_iterator rbegin() ;
const_reverse_iterator rbegin() const;
reverse_iterator rend() ;
const_reverse_iterator rend() const;
/ / ...
};
Iteration over a mapis simply an iteration over a sequence of pair<const Key,mapped_type> elements. For example, we might print out the entries of a phone book like this:
void f(map<string,number>& phone_book)
{
typedef map<string,number>: :const_iterator CI;
for(CI p= phone_book.begin() ; p!=phone_book.end() ; ++p)
cout<< p->first<< ´\t´ << p->second<< ´\n´;
}
A mapiterator presents the elements in ascending order of its keys (§17.4.1.5). Therefore, the
phone_bookentries will be output in lexicographical order.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
482 Standard Containers Chapter 17
We refer to the first element of any pairas firstand the second as secondindependently of
what types they actually are:
template<class T1, class T2> struct std: :pair{
typedef T1 first_type;
typedef T2 second_type;
T1 first;
T2 second;
pair() :first(T1()) , second(T2()) { }
pair(const T1& x, const T2& y) :first(x) , second(y) { }
template<class U, class V>
pair(const pair<U, V>& p) :first(p.first) , second(p.second) { }
};
The last constructor exists to allow conversions in the initializer (§13.6.2). For example:
pair<int,double> f(char c, int i)
{
return pair<int,double>(c,i) ; / / conversions required
}
In a map, the key is the first element of the pair and the mapped value is the second.
The usefulness of pairis not limited to the implementation of map, so it is a standard library
class in its own right. The definition of pairis found in <utility>. A function to make it convenient to create pairs is also provided:
template<class T1, class T2> pair<T1,T2> std: :make_pair(T1 t1, T2 t2)
{
return pair<T1,T2>(t1,t2) ;
}
A pairis by default initialized to the default values of its element types. In particular, this implies
that elements of built-in types are initialized to 0(§5.1.1) and strings are initialized to the empty
string (§20.3.4). A type without a default constructor can be an element of a paironly provided the
pair is explicitly initialized.
17.4.1.3 Subscripting [cont.map.element]
The characteristic mapoperation is the associative lookup provided by the subscript operator:
template<class Key, class T, class Cmp= less<Key>,
class A= allocator< pair<const Key,T> > >
class map{
public:
/ / ...
mapped_type& operator[](const key_type& k) ; / / access element with key k
/ / ...
};
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.4.1.3 Subscripting 483
The subscript operator performs a lookup on the key given as an index and returns the corresponding value. If the key isn’t found, an element with the key and the default value of the mapped_type
is inserted into the map. For example:
void f()
{
map<string,int> m; / / map starting out empty
int x= m["Henry"] ; / / create new entry for "Henry", initialize to 0, return 0
m["Harry"] = 7; / / create new entry for "Harry", initialize to 0, and assign 7
int y= m["Henry"] ; / / return the value from "Henry"’s entry
m["Harry"] = 9; / / change the value from "Harry"’s entry to 9
}
As a slightly more realistic example, consider a program that calculates sums of items presented as
input in the form of (item-name,value) pairs such as
nail 100 hammer 2 saw 3 saw 4 hammer 7 nail 1000 nail 250
and also calculates the sum for each item. The main work can be done while reading the (itemname,value) pairs into a map:
void readitems(map<string,int>& m)
{
string word;
int val= 0;
while(cin>> word>> val) m[word] += val;
}
The subscript operation m[word] identifies the appropriate (string,int) pair and returns a reference to its intpart. This code takes advantage of the fact that a new element gets its intvalue set to
0by default.
A mapconstructed by readitems() can then be output using a conventional loop:
int main()
{
map<string,int> tbl;
readitems(tbl) ;
int total= 0;
typedef map<string,int>: :const_iterator CI;
for(CI p= tbl.begin() ; p!=tbl.end() ; ++p) {
total+= p->second;
cout<< p->first<< ´\t´ << p->second<< ´\n´;
}
cout<< "----------------\ntotal\t" << total<< ´\n´;
return!cin;
}
Given the input above, the output is:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
484 Standard Containers Chapter 17
hammer 9
nail 1350
saw 7
----------------
total 1366
Note that the items are printed in lexical order (§17.4.1, §17.4.1.5).
A subscripting operation must find the key in the map. This, of course, is not as cheap as subscripting an array with an integer. The cost is O(log(size_of_map)), which is acceptable for
many applications. For applications for which this is too expensive, a hashed container is often the
answer (§17.6).
Subscripting a mapadds a default element when the key is not found. Therefore, there is no
version of operator[]() for const maps. Furthermore, subscripting can be used only if the
mapped_type(value type) has a default value. If the programmer simply wants to see if a key is
present, the find() operation (§17.4.1.6) can be used to locate a keywithout modifying the map.
17.4.1.4 Constructors [cont.map.ctor]
A mapprovides the usual complement of constructors, etc. (§16.3.4) :
template<class Key, class T, class Cmp=less<Key>,
class A=allocator<pair<const Key,T> > >
class map{
public:
/ / ...
/ / construct/copy/destroy:
explicit map(const Cmp& = Cmp() , const A& = A()) ;
template<class In> map(In first, In last, const Cmp& = Cmp() , const A& = A()) ;
map(const map&) ;
~map() ;
map& operator=(const map&) ;
/ / ...
};
Copying a container implies allocating space for its elements and making copies of each element
(§16.3.4). This can be very expensive and should be done only when necessary. Consequently,
containers such as maps tend to be passed by reference.
The member template constructor takes a sequence of pair<const Key,T>s described by a pair
input iterator In. It insert()s (§17.4.1.7) the elements from the sequence into the map.
17.4.1.5 Comparisons [cont.map.comp]
To find an element in a mapgiven a key, the mapoperations must compare keys. Also, iterators
traverse a mapin order of increasing key values, so insertion will typically also compare keys (to
place an element into a tree structure representing the map).
By default, the comparison used for keys is < (less than), but an alternative can be provided as a
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.4.1.5 Comparisons 485
template parameter or as a constructor argument (see §17.3.3). The comparison given is a comparison of keys, but the value_typeof a mapis a (key,value) pair. Consequently, value_comp() is
provided to compare such pairs using the key comparison function:
template<class Key, class T, class Cmp= less<Key>,
class A= allocator< pair<const Key,T> > >
class map{
public:
/ / ...
typedef Cmp key_compare;
class value_compare: public binary_function<value_type,value_type,bool> {
friend class map;
protected:
Cmp cmp;
value_compare(Cmp c) : cmp(c) {}
public:
bool operator()(const T& x, const T& y) const{ return cmp(x.first, y.first) ; }
};
key_compare key_comp() const;
value_compare value_comp() const;
/ / ...
};
For example:
map<string,int> m1;
map<string,int,Nocase> m2; / / specify comparison type (§17.1.4.1)
map<string,int,String_cmp> m3; / / specify comparison type (§17.1.4.1)
map<string,int> m4(String_cmp(literary)) ; / / pass comparison object
The key_comp() and value_comp() member functions make it possible to query a mapfor the
kind of comparisons used for keys and values. This is usually done to supply the same comparison
criterion to some other container or algorithm. For example:
void f(map<string,int>& m)
{
map<string,int> mm; / / compare using < by default
map<string,int> mmm(m.key_comp()) ; / / compare the way m does
/ / ...
}
See §17.1.4.1 for an example of how to define a particular comparison and §18.4 for an explanation
of function objects in general.
17.4.1.6 Map Operations [cont.map.map]
The crucial idea for maps and indeed for all associative containers is to gain information based on a
key. Several specialized operations are provided for that:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
486 Standard Containers Chapter 17
template<class Key, class T, class Cmp= less<Key>,
class A= allocator< pair<const Key,T> > >
class map{
public:
/ / ...
/ / map operations:
iterator find(const key_type& k) ; / / find element with key k
const_iterator find(const key_type& k) const;
size_type count(const key_type& k) const; / / find number of elements with key k
iterator lower_bound(const key_type& k) ; / / find first element with key k
const_iterator lower_bound(const key_type& k) const;
iterator upper_bound(const key_type& k) ; / / find first element with key greater than k
const_iterator upper_bound(const key_type& k) const;
pair<iterator,iterator> equal_range(const key_type& k) ;
pair<const_iterator,const_iterator> equal_range(const key_type& k) const;
/ / ...
};
A m.find(k) operation simply yields an iterator to an element with the key k. If there is no such
element, the iterator returned is m.end(). For a container with unique keys, such as mapand set,
the resulting iterator will point to the unique element with the key k. For a container with nonunique keys, such as multimapand multiset, the resulting iterator will point to the first element that
has that key. For example:
void f(map<string,int>& m)
{
map<string,int>: :iterator p= m.find("Gold") ;
if(p!=m.end()) { / / if "Gold" was found
/ / ...
}
else if(m.find("Silver")!=m.end()) { / / look for "Silver"
/ / ...
}
/ / ...
}
For a multimap(§17.4.2), finding the first match is rarely as useful as finding all matches;
m.lower_bound(k) and m.upper_bound(k) give the beginning and the end of the subsequence
of elements of mwith the key k. As usual, the end of a sequence is an iterator to the one-past-thelast element of the sequence. For example:
void f(multimap<string,int>& m)
{
multimap<string,int>: :iterator lb= m.lower_bound("Gold") ;
multimap<string,int>: :iterator ub= m.upper_bound("Gold") ;
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.4.1.6 Map Operations 487
for(multimap<string,int>: :iterator p= lb; p!=ub; ++p) {
/ / ...
}
}
Finding the upper bound and lower bound by two separate operations is neither elegant nor efficient. Consequently, the operation equal_range() is provided to deliver both. For example:
void f(multimap<string,int>& m)
{
typedef multimap<string,int>: :iterator MI;
pair<MI,MI> g= m.equal_range("Gold") ;
for(MI p= g.first; p!=g.second; ++p) {
/ / ...
}
}
If lower_bound(k) doesn’t find k, it returns an iterator to the first element that has a key greater
than k, or end() if no such greater element exists. This way of reporting failure is also used by
upper_bound() and equal_range().
17.4.1.7 List Operations [cont.map.modifier]
The conventional way of entering a value into an associative array is simply to assign to it using
subscripting. For example:
phone_book["Order department"] = 8226339;
This will make sure that the Order department has the desired entry in the phone_bookindependently of whether it had a prior entry. It is also possible to insert() entries directly and to remove
entries using erase():
template<class Key, class T, class Cmp= less<Key>,
class A= allocator< pair<const Key,T> > >
class map{
public:
/ / ...
/ / list operations:
pair<iterator, bool> insert(const value_type& val) ; / / insert (key,value) pair
iterator insert(iterator pos, const value_type& val) ; / / pos is just a hint
template<class In> void insert(In first, In last) ; / / insert elements from sequence
void erase(iterator pos) ; / / erase the element pointed to
size_type erase(const key_type& k) ; / / erase element with key k (if present)
void erase(iterator first, iterator last) ; / / erase range
void clear() ;
/ / ...
};
The operation m.insert(val) attempts to add a (Key,T) pair valto m. Since maps rely on
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
488 Standard Containers Chapter 17
unique keys, insertion takes place only if there is not already an element in the mwith that key.
The return value of m.insert(val) is a pair<iterator,bool>. The boolis trueif valwas actually
inserted. The iterator refers to the element of mholding the key k. For example:
void f(map<string,int>& m)
{
pair<string,int> p99("Paul",99) ;
pair<map<string,int>: :iterator,bool> p= m.insert(p99) ;
if(p.second) {
/ / "Paul" was inserted
}
else{
/ / "Paul" was there already
}
map<string,int>: :iterator i= p.first; / / points to m["Paul"]
/ / ...
}
Usually, we do not care whether a key is newly inserted or was present in the mapbefore the
insert(). When we are interested, it is often because we want to register the fact that a value is in
a mapsomewhere else (outside the map). The other two versions of insert() do not return an indication of whether a value was actually inserted.
Specifying a position, insert(pos,val), is simply a hint to the implementation to start the
search for the key valat pos. If the hint is good, significant performance improvements can result.
If the hint is bad, you’d have done better without it both notationally and efficiency-wise. For
example:
void f(map<string,int>& m)
{
m["Dilbert"] = 3; / / neat, possibly less efficient
m.insert(m.begin() ,make_pair(const string("Dogbert") ,99)) ; / / ugly
}
In fact, [] is little more than a convenient notation for insert(). The result of m[k] is equivalent
to the result of (*(m.insert(make_pair(k,V())).first)).second, where V() is the default
value for the mapped type. When you understand that equivalence, you probably understand associative containers.
Because [] always uses V(), you cannot use subscripting on a mapwith a value type that does
not have a default value. This is an unfortunate limitation of the standard associative containers.
However, the requirement of a default value is not a fundamental property of associative containers
(see §17.6.2).
You can erase elements specified by a key. For example:
void f(map<string,int>& m)
{
int count= phone_book.erase("Ratbert") ;
/ / ...
}
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.4.1.7 List Operations 489
The integer returned is the number of erased elements. In particular, countis 0if there was no element with the key "Ratbert" to erase. For a multimapor multiset, the value can be larger than 1.
Alternatively, one can erase an element given an iterator pointing to it or a range of elements given
a sequence. For example:
void g(map<string,int>& m)
{
m.erase(m.find("Catbert")) ;
m.erase(m.find("Alice") ,m.find("Wally")) ;
}
Naturally, it is faster to erase an element for which you already have an iterator than to first find the
element given its key and then erase it. After erase(), the iterator cannot be used again because
the element to which it pointed is no longer there. Erasing end() is harmless.
17.4.1.8 Other Functions [cont.map.etc]
Finally, a mapprovides the usual functions dealing with the number of elements and a specialized
swap():
template<class Key, class T, class Cmp= less<Key>,
class A= allocator< pair<const Key,T> > >
class map{
public:
/ / ...
/ / capacity:
size_type size() const; / / number of elements
size_type max_size() const; / / size of largest possible map
bool empty() const{ return size()==0; }
void swap(map&) ;
};
As usual, a value returned by size() or max_size() is a number of elements.
In addition, mapprovides ==, !=, <, >, <=, >=, and swap() as nonmember functions:
template<class Key, class T, class Cmp, class A>
bool operator==(const map<Key,T,Cmp,A>&, const map<Key,T,Cmp,A>&) ;
/ / similarly !=, <, >, <=, and >=
template<class Key, class T, class Cmp, class A>
void swap(map<Key,T,Cmp,A>&, map<Key,T,Cmp,A>&) ;
Why would anyone want to compare two maps? When we specifically compare two maps, we usually want to know not just if the maps differ, but also how they differ if they do. In such cases, we
don’t use == or !=. However, by providing ==, <, and swap() for every container, we make it
possible to write algorithms that can be applied to every container. For example, these functions
allow us to sort() a vectorof maps and to have a setof maps.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
490 Standard Containers Chapter 17
17.4.2 Multimap [cont.multimap]
A multimapis like a map, except that it allows duplicate keys:
template<class Key, class T, class Cmp= less<Key>,
class A= allocator< pair<const Key,T> > >
class std: :multimap{
public:
/ / like map, except:
iterator insert(const value_type&) ; / / returns iterator, not pair
/ / no subscript operator []
};
For example (using Cstring_lessfrom §17.1.4.1 to compare C-style strings):
void f(map<char*,int,Cstring_less>& m, multimap<char*,int,Cstring_less>& mm)
{
m.insert(make_pair("x",4)) ;
m.insert(make_pair("x",5)) ; / / no effect: there already is an entry for "x" (§17.4.1.7)
/ / now m["x"] == 4
mm.insert(make_pair("x",4)) ;
mm.insert(make_pair("x",5)) ;
/ / mm now holds both ("x",4) and ("x",5)
}
This implies that multimapcannot support subscripting by key values in the way mapdoes. The
equal_range(), lower_bound(), and upper_bound() operations (§17.4.1.6) are the primary
means of accessing multiple values with the same key.
Naturally, where several values can exist for a single key, a multimapis preferred over a map.
That happens far more often than people first think when they hear about multimap. In some ways,
a multimapis even cleaner and more elegant than a map.
Because a person can easily have several phone numbers, a phone book is a good example of a
multimap. I might print my phone numbers like this:
void print_numbers(const multimap<string,int>& phone_book)
{
typedef multimap<string,int>: :const_iterator I;
pair<I,I> b= phone_book.equal_range("Stroustrup") ;
for(I i= b.first; i!= b.second; ++i) cout<< i->second<< ´\n´;
}
For a multimap, the argument to insert() is always inserted. Consequently, the
multimap: :insert() returns an iterator rather than a pair<iterator,bool> like mapdoes. For uniformity, the library could have provided the general form of insert() for both mapand multimap
even though the boolwould have been redundant for a multimap. Yet another design alternative
would have been to provide a simple insert() that didn’t return a boolin either case and then supply users of mapwith some other way of figuring out whether a key was newly inserted. This is a
case in which different interface design ideas clash.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.4.3 Set 491
17.4.3 Set [cont.set]
A setcan be seen as a map(§17.4.1), where the values are irrelevant, so we keep track of only the
keys. This leads to only minor changes to the user interface:
template<class Key, class Cmp= less<Key>, class A= allocator<Key> >
class std: :set{
public:
/ / like map except:
typedef Key value_type; / / the key itself is the value
typedef Cmp value_compare;
/ / no subscript operator []
};
Defining value_typeas the key_typetype is a trick to allow code that uses maps and sets to be
identical in many cases.
Note that setrelies on a comparison operation (by default <) rather than equality (==). This
implies that equivalence of elements is defined by inequality (§17.1.4.1) and that iteration through
a sethas a well-defined order.
Like map, setprovides ==, !=, <, >, <=, >=, and swap().
17.4.4 Multiset [cont.multiset]
A multisetis a setthat allows duplicate keys:
template<class Key, class T, class Cmp= less<Key>, class A= allocator<Key> >
class std: :multiset{
public:
/ / like set, except:
iterator insert(const value_type&) ; / / returns iterator, not pair
};
The equal_range(), lower_bound(), and upper_bound() operations (§17.4.1.6) are the primary
means of accessing multiple occurrences of a key.
17.5 Almost Containers [cont.etc]
Built-in arrays (§5.2), strings (Chapter 20), valarrays (§22.4), and bitsets (§17.5.3) hold elements
and can therefore be considered containers for many purposes. However, each lacks some aspect or
other of the standard container interface, so these ‘‘almost containers’’ are not completely interchangeable with fully developed containers such as vectorand list.
17.5.1 String [cont.string]
A basic_stringprovides subscripting, random-access iterators, and most of the notational conveniences of a container (Chapter 20). However, basic_stringdoes not provide as wide a selection of
types as elements. It also is optimized for use as a string of characters and is typically used in ways
that differ significantly from a container.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
492 Standard Containers Chapter 17
17.5.2 Valarray [cont.valarray]
A valarray(§22.4) is a vector for optimized numeric computation. Consequently, a valarray
doesn’t attempt to be a general container. A valarrayprovides many useful numeric operations.
However, of the standard container operations (§17.1.1), it offers only size() and a subscript operator (§22.4.2). A pointer to an element of a valarrayis a random-access iterator (§19.2.1).
17.5.3 Bitset [cont.bitset]
Often, aspects of a system, such as the state of an input stream (§21.3.3), are represented as a set of
flags indicating binary conditions such as good/bad, true/false, and on/off. C++ supports the notion
of small sets of flags efficiently through bitwise operations on integers (§6.2.4). These operations
include & (and), | (or), ^ (exclusive or), << (shift left), and >> (shift right). Class bitset<N> generalizes this notion and offers greater convenience by providing operations on a set of Nbits
indexed from 0through N-1, where Nis known at compile time. For sets of bits that don’t fit into
a long int, using a bitsetis much more convenient than using integers directly. For smaller sets,
there may be an efficiency tradeoff. If you want to name the bits, rather than numbering them,
using a set(§17.4.3), an enumeration (§4.8), or a bitfield (§C.8.1) are alternatives.
A bitset<N> is an array of Nbits. A bitsetdiffers from a vector<bool> (§16.3.11) by being of
fixed size, from set(§17.4.3) by having its bits indexed by integers rather than associatively by
value, and from both vector<bool> and setby providing operations to manipulate the bits.
It is not possible to address a single bit directly using a built-in pointer (§5.1). Consequently,
bitsetprovides a reference-to-bit type. This is actually a generally useful technique for addressing
objects for which a built-in pointer for some reason is unsuitable:
template<size_t N> class std: :bitset{
public:
class reference{ / / reference to a single bit:
friend class bitset;
reference() ;
public: / / b[i] refers to the (i+1)’th bit:
~reference() ;
reference& operator=(bool x) ; / / for b[i] = x;
reference& operator=(const reference&) ; / / for b[i] = b[j];
bool operator~() const; / / return ˜b[i]
operator bool() const; / / for x = b[i];
reference& flip() ; / / b[i].flip();
};
/ / ...
};
The bitsettemplate is defined in namespace stdand presented in <bitset>.
For historical reasons, bitsetdiffers somewhat in style from other standard library classes. For
example, if an index (also known as a bit position) is out of range, an out_of_rangeexception is
thrown. No iterators are provided. Bit positions are numbered right to left in the same way bits
often are in a word, so the value of b[i] is pow(i,2). Thus, a bitset can be thought of as an N-bit
binary number:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.5.3 Bitset 493
1 1 1 1 0 1 1 1 0 1
9 8 7 6 5 4 3 2 1 0
bitset<10>:
position:
17.5.3.1 Constructors [cont.bitset.ctor]
A bitsetcan be constructed with default values, from the bits in an unsigned long int, or from a
string:
template<size_t N> class bitset{
public:
/ / ...
/ / constructors:
bitset() ; / / N zero-bits
bitset(unsigned long val) ; / / bits from val
template<class Ch, class Tr, class A> / / Tr is a character trait (§20.2)
explicit bitset(const basic_string<Ch,Tr,A>& str, / / bits from string str
basic_string<Ch,Tr,A>: :size_type pos= 0,
basic_string<Ch,Tr,A>: :size_type n= basic_string<Ch,Tr,A>: :npos) ;
/ / ...
};
The default value of a bit is 0. When an unsigned long intargument is supplied, each bit in the
integer is used to initialize the corresponding bit in the bitset (if any). A basic_string(Chapter 20)
argument does the same, except that the character ´0´ gives the bitvalue 0, the character ´1´ gives
the bitvalue 1, and other characters cause an invalid_argumentexception to be thrown. By default,
a complete string is used for initialization. However, in the style of a basic_stringconstructor
(§20.3.4), a user can specify that only the range of characters from posto the end of the string or to
pos+nare to be used. For example:
void f()
{
bitset<10> b1; / / all 0
bitset<16> b2= 0xaaaa; / / 1010101010101010
bitset<32> b3= 0xaaaa; / / 00000000000000001010101010101010
bitset<10> b4("1010101010") ; / / 1010101010
bitset<10> b5("10110111011110",4) ; / / 0111011110
bitset<10> b6("10110111011110",2,8) ; / / 0011011101
bitset<10> b7("n0g00d") ; / / invalid_argument thrown
bitset<10> b8= "n0g00d"; / / error: no char* to bitset conversion
}
A key idea in the design of bitsetis that an optimized implementation can be provided for bitsets
that fit in a single word. The interface reflects this assumption.
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
494 Standard Containers Chapter 17
17.5.3.2 Bit Manipulation Operations [cont.bitset.oper]
A bitsetprovides the operators for accessing individual bits and for manipulating all bits in the set:
template<size_t N> class std: :bitset{
public:
/ / ...
/ / bitset operations:
reference operator[](size_t pos) ; / / b[i]
bitset& operator&=(const bitset& s) ; / / and
bitset& operator|=(const bitset& s) ; / / or
bitset& operator^=(const bitset& s) ; / / exclusive or
bitset& operator<<=(size_t n) ; / / logical left shift (fill with zeros)
bitset& operator>>=(size_t n) ; / / logical right shift (fill with zeros)
bitset& set() ; / / set every bit to 1
bitset& set(size_t pos, int val= 1) ; / / b[pos]=val
bitset& reset() ; / / set every bit to 0
bitset& reset(size_t pos) ; / / b[pos]=0
bitset& flip() ; / / change the value of every bit
bitset& flip(size_t pos) ; / / change the value of b[pos]
bitset operator~() const{ return bitset<N>(*this).flip() ; } / / make complement set
bitset operator<<(size_t n) const{ return bitset<N>(*this)<<=n; } / / make shifted set
bitset operator>>(size_t n) const{ return bitset<N>(*this)>>=n; } / / make shifted set
/ / ...
};
The subscript operator throws out_of_rangeif the subscript is out of range. There is no unchecked
subscript operation.
The bitset& returned by these operations is *this. An operator returning a bitset(rather than a
bitset&) makes a copy of *this, applies its operation to that copy, and returns the result. In particular, >> and << really are shift operations rather than I/O operations. The output operator for a bitsetis a << that takes an ostreamand a bitset(§17.5.3.3).
When bits are shifted, a logical (rather than cyclic) shift is used. That implies that some bits
‘‘fall off the end’’ and that some positions get the default value 0. Note that because size_tis an
unsigned type, it is not possible to shift by a negative number. It does, however, imply that b<<-1
shifts by a very large positive value, thus leaving every bit of the bitset bwith the value 0. Your
compiler should warn against this.
17.5.3.3 Other Operations [cont.bitset.etc]
A bitsetalso supports common operations such as size(), ==, I/O , etc.:
The C++ Programming Language, Third Edition by Bjarne Stroustrup. Copyright ©1997 by AT&T.
Published by Addison Wesley Longman, Inc. ISBN 0-201-88954-4. All rights reserved.
Section 17.5.3.3 Other Operations 495
template<size_t N> class bitset{
public:
/ / ...
unsigned long to_ulong() const;
